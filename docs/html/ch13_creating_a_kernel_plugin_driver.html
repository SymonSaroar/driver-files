<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 13: Creating a Kernel PlugIn Driver"/>
<title>Jungo WinDriver: Chapter 13: Creating a Kernel PlugIn Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch13_creating_a_kernel_plugin_driver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 13: Creating a Kernel PlugIn Driver </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap13"></a>The easiest way to write a Kernel PlugIn driver is to use DriverWizard to generate the Kernel PlugIn code for your hardware (see <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a> and <br  />
 <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_4_3_the_generated_driverwizard_kernel_plugin_directory">12.5.4.3. The Generated DriverWizard Kernel PlugIn Directory</a>).</p>
<p >Alternatively, you can use one of the WinDriver Kernel PlugIn samples as the basis for your Kernel PlugIn development. You can also develop your code "from scratch", if you wish.</p>
<p >As indicated in <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a>, the Kernel PlugIn documentation in this manual focuses on the generated DriverWizard code, and the generic PCI Kernel PlugIn sample — <code>KP_PCI</code>, located in the <code>WinDriver/samples/c/pci_diag/kp_pci</code> directory. If you are using the a PCI Express card with the Xilinx Bus Master DMA (BMD) design, you can also use the <code>KP_BMD</code> Kernel PlugIn sample as the basis for your development; the <code>WinDriver/samples/c/xilinx/bmd_design</code> directory contains all the relevant sample files — see the Xilinx BMD Kernel PlugIn directory structure note at the end of (<a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_4_1_pci_diag_and_kp_pci_sample_directories">12.5.4.1. pci_diag and kp_pci Sample Directories</a>).</p>
<p >The following is a step-by-step guide to creating your Kernel PlugIn driver.</p>
<h1><a class="anchor" id="ch13_1_determine_whether_a_kernel_plugin_is_needed"></a>
13.1. Determine Whether a Kernel PlugIn is Needed</h1>
<p >The Kernel PlugIn should be used only after your driver code has been written and debugged in the user mode. This way, all of the logical problems of creating a device driver are solved in the user mode, where development and debugging are much easier.</p>
<p >Determine whether a Kernel PlugIn should be written by consulting <a class="el" href="ch11_improving_pci_performance.html">Chapter 11: Improving PCI Performance</a>, which explains how to improve the performance of your driver. In addition, the Kernel PlugIn affords greater flexibility, which is not always available when writing the driver in the user mode (specifically in regard to the interrupt handling).</p>
<h1><a class="anchor" id="ch13_2_what_programming_languages_can_be_used_with_a_kernel_plugin"></a>
13.2. What programming languages can be used with a Kernel PlugIn?</h1>
<p >The Kernel PlugIn is a kernel module, and therefore must be written in the C language. The user application that calls the Kernel PlugIn can be of any langauge supported by WinDriver: C, C#.NET, Visual Basic.NET, Python, Java.</p>
<p >When generating code in the DriverWizard in languages other than C with Kernel PlugIn, the Kernel PlugIn code will still be generated in C.</p>
<h1><a class="anchor" id="ch13_3_prepare_the_user-mode_source_code"></a>
13.3. Prepare the User-Mode Source Code</h1>
<p >Please follow this step:</p>
<ul>
<li>Isolate the functions you need to move into the Kernel PlugIn.</li>
<li>Remove any platform-specific code from the functions. Use only functions that can also be used from the kernel.</li>
<li>Recompile your driver in the user mode.</li>
<li>Debug your driver in user mode again to see that your code still works after changes have been made.</li>
</ul>
<p >Keep in mind that the kernel stack is relatively limited in size. Therefore, code that will be moved into the Kernel PlugIn should not contain static memory allocations. Use the <code><a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a></code> function to allocate memory dynamically instead. This is especially important for large data structures.</p>
<p >If the user-mode code that you are porting to the kernel accesses memory addresses directly using the user-mode mapping of the physical address returned from the low-level <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> function — note that in the kernel you will need to use the kernel mapping of the physical address instead (the kernel mapping is also returned by <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> ).</p>
<p >When using the API of the WDC library to access memory, you do not need to worry about this, since this API ensures that the correct mapping of the memory is used depending on whether the relevant APIs are used from the user mode or from the kernel mode.</p>
<h1><a class="anchor" id="ch13_4_create_a_new_kernel_plugin_project"></a>
13.4. Create a New Kernel PlugIn Project</h1>
<p >As indicated above, you can use DriverWizard to generate a new Kernel PlugIn project (and a corresponding user-mode project) for your device (recommended), or use one of the WinDriver Kernel PlugIn samples as the basis for your development.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;To successfully build a Kernel PlugIn project using MS Visual Studio, the path to the project directory must not contain any spaces. </p>
</blockquote>
</blockquote>
<p>If you select to start your development with the KP_PCI sample, follow these steps:</p>
<ul>
<li>Make a copy of the <code>WinDriver/samples/c/pci_diag/kp_pci</code> directory. For example, to create a new Kernel PlugIn project called KP_MyDrv, copy <code>WinDriver/samples/c/pci_diag/kp_pci</code> to <code>WinDriver/samples/c/mydrv</code>.</li>
<li>Change all instances of "KP_PCI" and "kp_pci", in all the Kernel PlugIn files in your new directory, to "KP_MyDrv" and "kp_mydrv" (respectively).</li>
</ul>
<p >The names of the KP_PCI_xxx() functions in the <a class="el" href="kp__pci_8c.html">kp_pci.c</a> files do not have to be changed, but the code will be clearer if you use your selected driver name in the function names.</p><ul>
<li>Change all occurrences of "KP_PCI" in file names to "kp_mydrv".</li>
<li>To use the shared <code>pci_lib</code> library API from your Kernel PlugIn driver and user-mode application, copy the <code>pci_lib.h</code> and <code>pci_lib.c</code> files from the <code>WinDriver/samples/c/pci_diag</code> directory to your new mydrv directory.</li>
</ul>
<p >You can change the names of the library functions to use your driver's name (MyDrv) instead of "PCI", but note that in this case you will also need to modify the names in all calls to these functions from your Kernel PlugIn project and usermode application. If you do not copy the shared library to your new project, you will need to modify the sample Kernel PlugIn code and replace all references to the <code>PCI_xxx</code> library APIs with alternative code.</p>
<ul>
<li>Modify the files and directory paths in the project and make files, and the <code>#include</code> paths in the source files, as needed (depending on the location in which you selected to save your new project directory).</li>
<li>To use the <code>pci_diag</code> user-mode application, copy <code>WinDriver/samples/c/pci_diag/pci_diag.c</code> and the relevant <code>pci_diag</code> project, solution, or make files to your mydrv directory, rename the files (if you wish), and replace all <code>pci_diag</code> references in the files with your preferred usermode application name.</li>
</ul>
<p >To use the solution files, also replace the references to "KP_PCI" in the files with your new Kernel PlugIn driver, e.g., "KP_MyDrv". Then modify the sample code to implement your desired driver functionality.</p>
<p >For a general description of the sample and generated Kernel PlugIn code and its structure, <br  />
 see <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a> and <br  />
 <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_4_kernel_plugin_sample-generated_code_directory_structure">12.5.4. Kernel PlugIn Sample/Generated Code Directory Structure</a> (respectively).</p>
<h1><a class="anchor" id="ch13_5_open_a_handle_to_the_kernel_plugin"></a>
13.5. Open a Handle to the Kernel PlugIn</h1>
<p >To open a handle to a Kernel PlugIn driver, WD_KernelPlugIn() needs to be called from the user mode. This low-level function is called from <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> — when it is called with the name of a Kernel PlugIn driver.</p>
<p >When using the high-level WDC API you should use the following method to open a Kernel PlugIn handle:</p>
<ul>
<li>First open a regular device handle — by calling the relevant <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> function without the name of a Kernel PlugIn driver. Then call <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a>, passing to it the handle to the opened device. <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> opens a handle to the Kernel PlugIn driver, and stores it within the kerPlug field of the provided device structure .</li>
<li>Open a handle to the device, using the relevant <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> function, and pass the name of a Kernel PlugIn driver within the function's pcKPDriverName parameter. The device handle returned by the function will also contain (within the kerPlug field) a Kernel PlugIn handle opened by the function.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;This method cannot be used to open a handle to a 64-bit Kernel PlugIn driver from a 32-bit application, or to open a Kernel PlugIn handle from a .NET application. </p>
</blockquote>
</blockquote>
<p>To ensure that your code works correctly in all the supported configurations, use the first method described above.</p>
<p >The generated DriverWizard and the sample <code>pci_diag</code> shared library (<code>xxx_lib.c</code> / <code>pci_lib.c</code>) demonstrate how to open a handle to the Kernel PlugIn — see the generated/sample <code>XXX_DeviceOpen()</code> / <code>PCI_DeviceOpen()</code> library function (which is called from the generated/sample <code>xxx_diag</code>/<code>pci_diag</code> user-mode application).</p>
<p >The handle to the Kernel PlugIn driver is closed when the <a class="el" href="windrvr_8h_a3b108638d5a2bcdbd8fc740e5063effe.html#a3b108638d5a2bcdbd8fc740e5063effe" title="Closes the WinDriver Kernel PlugIn handle obtained from WD_KernelPlugInOpen()">WD_KernelPlugInClose()</a> function is called from the user mode.</p>
<p >When using the low-level WinDriver API, this function is called directly from the user-mode application.</p>
<p >When using the high-level WDC API , the function is called automatically when calling <a class="el" href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188" title="Uninitializes a WDC PCI device structure and frees the memory allocated for it.">WDC_PciDeviceClose()</a> / <a class="el" href="wdc__lib_8h_a2a4b820da9b800812dedf52b775e71e1.html#a2a4b820da9b800812dedf52b775e71e1" title="Uninitializes a WDC ISA device structure and frees the memory allocated for it.">WDC_IsaDeviceClose()</a> ) with a device handle that contains an open Kernel PlugIn handle. The function is also called by WinDriver as part of the application cleanup, for any identified open Kernel PlugIn handles.</p>
<h1><a class="anchor" id="ch13_6_set_interrupt_handling_in_the_kernel_plugin"></a>
13.6. Set Interrupt Handling in the Kernel PlugIn</h1>
<p >Kindly follow these instructions:</p>
<ul>
<li>When calling <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> (after having opened a handle to the Kernel PlugIn driver, as explained in <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_5_open_a_handle_to_the_kernel_plugin">13.5. Open a Handle to the Kernel PlugIn</a>), set the fUseKP function parameter to TRUE to indicate that you wish to enable interrupts in the Kernel PlugIn driver with which the device was opened.</li>
</ul>
<p >The generated DriverWizard and the sample <code>pci_diag</code> shared library (<code>xxx_lib.c</code> / <code>pci_lib.c</code>) demonstrate how this should be done — see the generated/sample XXX_IntEnable()/PCI_IntEnable() library function (which is called from the generated/sample <code>xxx_diag</code>/<code>pci_diag</code> user-mode application).</p>
<p >If you are not using the WDC_xxx API , in order to enable interrupts in the Kernel PlugIn call <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> or <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> (which calls <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a>), and pass the handle to the Kernel PlugIn driver that you received from <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> (within the hKernelPlugIn field of the <a class="el" href="structWD__KERNEL__PLUGIN.html">WD_KERNEL_PLUGIN</a> structure that was passed to the function).</p><ul>
<li>When calling <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> / <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> / <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a>, to enable interrupts in the Kernel PlugIn, WinDriver will activate your Kernel PlugIn's KP_IntEnable callback function.</li>
</ul>
<p >You can implement this function to set the interrupt context that will be passed to the high-IRQL and DPC Kernel PlugIn interrupt handler routines, as well as write to the device to actually enable the interrupts in the hardware, for example, or implement any other code required in order to correctly enable your device's interrupts.</p><ul>
<li>Move the implementation of the user-mode interrupt handler, or the relevant portions of this implementation, to the Kernel PlugIn's interrupt handler functions. High-priority code, such as the code for acknowledging (clearing) level-sensitive interrupts, should be moved to the relevant high-IRQL handler — KP_IntAtIrql (legacy interrupts) or KP_IntAtIrqlMSI (MSI/MSI-X) — which runs at high interrupt request level.</li>
</ul>
<p >Deferred processing of the interrupt can be moved to the relevant DPC handler — KP_IntAtDpc — which will be executed once the high-IRQL handler completes it processing and returns TRUE. You can also modify the code to make it more efficient, due to the advantages of handling the interrupts directly in the kernel, which provides you with greater flexibility (e.g., you can read from a specific register and write back the value that was read, or toggle specific register bits). For a detailed explanation on how to handle interrupts in the kernel using a Kernel PlugIn, refer to <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_5_handling_interrupts_in_the_kernel_plugin">12.5.5. Handling Interrupts in the Kernel PlugIn</a> of the manual.</p>
<h1><a class="anchor" id="ch13_7_set_i-o_handling_in_the_kernel_plugin"></a>
13.7. Set I/O Handling in the Kernel PlugIn</h1>
<p >Perform the next steps:</p><ul>
<li>Move your I/O handling code (if needed) from the user mode to the Kernel PlugIn message handler — KP_Call() .</li>
<li>To activate the kernel code that performs the I/O handling from the user mode, call <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> or the low-level <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> function with a relevant message for each of the different functionality that you wish to perform in the Kernel PlugIn. Implement a different message for each functionality.</li>
<li>Define these messages in a header file that is shared by the user-mode application (which will send the messages) and the Kernel PlugIn driver (that implements the messages).</li>
</ul>
<p >In the sample/generated DriverWizard Kernel PlugIn projects, the message IDs and other information that should be shared by the user-mode application and Kernel PlugIn driver are defined in the <code>pci_lib.h</code>/<code>xxx_lib.h</code> shared library header file.</p>
<h1><a class="anchor" id="ch13_8_compile_your_kernel_plugin_driver"></a>
13.8. Compile Your Kernel PlugIn Driver</h1>
<p >The Kernel PlugIn is not backward compatible. Therefore, when switching to a different version of WinDriver, you need to rebuild your Kernel PlugIn driver using the new version.</p>
<h2><a class="anchor" id="ch13_8_1_windows_kernel_plugin_driver_compilation"></a>
13.8.1. Windows Kernel PlugIn Driver Compilation</h2>
<p >The sample <code>WinDriver\samples\c\pci_diag\kp_pci</code> Kernel PlugIn directory and the generated DriverWizard Kernel PlugIn <code>&lt;project_dir&gt;\kermode</code> directory (where <code>&lt;project_dir&gt;</code> is the directory in which you selected to save the generated driver project) contain the following Kernel PlugIn project files (where <code>xxx</code> is the driver name — pci for the sample / the name you selected when generating the code with the wizard):</p><ul>
<li><code>x86</code> — 32-bit project files:<ul>
<li><code>msdev_&lt;version&gt;\kp_xxx.vcxproj</code> — 32-bit MS Visual Studio project file (where <code>&lt;version&gt;</code> signifies the IDE version — e.g., "2019")</li>
<li><code>win_gcc/makefile</code> — 32-bit Windows GCC (MinGW/Cygwin) makefile</li>
</ul>
</li>
<li><code>amd64</code> — 64-bit project files:<ul>
<li><code>msdev_&lt;version&gt;\kp_xxx.vcxproj</code> — 64-bit MS Visual Studio project file (where <code>&lt;version&gt;</code> signifies the IDE version — e.g., "2019")</li>
<li><code>win_gcc/makefile</code> — 64-bit Windows GCC (MinGW/Cygwin) makefile</li>
</ul>
</li>
</ul>
<p >The sample <code>WinDriver\samples\c\pci_diag</code> directory and the generated <code>&lt;project_dir&gt;</code> directory contain the following project files for the user-mode application that drives the respective Kernel PlugIn driver (where <code>xxx</code> is the driver name — <code>pci</code> for the sample / the name you selected when generating the code with the wizard):</p><ul>
<li><code>x86</code> — 32-bit project files:<ul>
<li><code>msdev_&lt;version&gt;\xxx_diag.vcxproj</code> — 32-bit MS Visual Studio project file (where <code>&lt;version&gt;</code> signifies the IDE version — e.g., "2019")</li>
<li><code>win_gcc/makefile</code> — 32-bit Windows GCC (MinGW/Cygwin) makefile</li>
</ul>
</li>
<li><code>amd64</code> — 64-bit project files:<ul>
<li><code>msdev_&lt;version&gt;\xxx_diag.vcxproj</code> — 64-bit MS Visual Studio project file (where <code>&lt;version&gt;</code> signifies the IDE version — e.g., "2019")</li>
<li><code>win_gcc/makefile</code> — 64-bit Windows GCC (MinGW/Cygwin) makefile</li>
</ul>
</li>
</ul>
<p >The <code>msdev_&lt;version&gt;</code> MS Visual Studio directories listed above also contain <code>xxx_diag.sln</code> solution files that include both the Kernel PlugIn and user-mode projects.</p>
<p >If you used DriverWizard to generate your code and you selected to generate a dynamic link library (DLL), the generated <code>&lt;project_dir&gt;</code> directory will also have a libproj DLL project directory. This directory has x86 (32-bit) and/or amd64 (64-bit) directories that contain msdev_&lt;version&gt; directories for your selected IDEs, and each IDE directory has an xxx_libapi.vcproj project file for building the DLL. The DLL is used from the wizard-generated user-mode diagnostics project (<code>xxx_diag.vcxproj</code>).</p>
<p >To build your Kernel PlugIn driver and respective user-mode application on Windows, follow these steps:</p><ul>
<li>Verify that the Windows Driver Kit (WDK) is installed.</li>
<li>Build the Kernel PlugIn SYS driver (<code>kp_pci.sys</code> — sample / <code>kp_xxx.sys</code> — wizard generated code):<ul>
<li>Using MS Visual Studio — Start Microsoft Visual Studio, and do the following:</li>
</ul>
</li>
</ul>
<p >From your driver project directory, open the Visual Studio Kernel PlugIn solution file — <code>&lt;project_dir&gt;\msdev_&lt;version&gt;\xxx_diag.sln</code>, where <code>&lt;project_dir&gt;</code> is your driver pro<code>ject directory (</code>pci_diag<code>for the sample code / the directory in which you selected to save the generated DriverWizard code),</code>msdev_&lt;version&gt;<code>is your target Visual Studio directory (e.g.,</code>msdev_2019<code>), and</code>xxx<code>is the driver name (</code>pci` for the sample / the name you selected when generating the code with the wizard).</p>
<p >When using DriverWizard to generate code for MS Visual Studio, you can use the IDE to Invoke option to have the wizard automatically open the generated solution file in your selected IDE, after generating the code files.</p>
<ol type="1">
<li>To successfully build a Kernel PlugIn project using MS Visual Studio, the path to the project directory must not contain any spaces.<ul>
<li>Set the Kernel PlugIn project (<code>kp_pci.vcxproj</code> / <code>kp_xxx.vcxproj</code>) as the active project.</li>
<li>Select the active configuration for your target platform: From the Build menu, choose Configuration Manager..., and select the desired configuration.</li>
</ul>
</li>
<li>To build the driver for multiple operating systems, select the lowest OS version that the driver must support from the <code>Project Properties -&gt; Driver Settings -&gt; Target OS Version</code>, select Windows 8 as it is the lowest version currently supported by WinDriver.<ul>
<li>Build your driver: Build the project from the Build menu or using the relevant shortcut key (e.g. CTRL+SHIFT+B in Visual Studio).</li>
</ul>
</li>
<li>Build the user-mode application that drives the Kernel PlugIn driver (<code>pci_diag.exe</code> — sample / <code>xxx_diag.exe</code> — wizard-generated code):<ul>
<li>Using MS Visual Studio —</li>
</ul>
</li>
<li>Set the user-mode project (<code>pci_diag.vcxproj</code> — <code>sample / xxx_diag.vcxproj</code> — wizard generated code) as the active project. Then build the application: Build the project from the Build menu or using the relevant shortcut key (e.g., CTRL+SHIFT+B in Visual Studio 2017).<ul>
<li>Using Windows GCC —</li>
</ul>
</li>
</ol>
<p >Do the following from your selected Windows GCC development environment (MinGW/Cygwin):</p>
<p >Change directory to your target Windows GCC application directory — <code>&lt;project_dir&gt;/&lt;CPU&gt;/win_gcc</code>, where <code>&lt;project_dir&gt;</code> is your driver project directory (<code>pci_diag</code> for the sample code / the directory in which you selected to save the generated DriverWizard code), and <code>&lt;CPU&gt;</code> is the target CPU architecture (x86 for x86 platforms, and amd64 for x64 platforms).</p>
<p >For example:</p>
<ul>
<li>When building a 32-bit version of the sample <code>pci_diag</code> application, which drives the sample KP_PCI driver —</li>
</ul>
<div class="fragment"><div class="line">$ cd WinDriver/samples/c/pci_diag/x86/win_gcc</div>
</div><!-- fragment --><ul>
<li>When building a 64-bit wizard-generated user-mode application that drivers a wizard-generated Kernel PlugIn driver —</li>
</ul>
<div class="fragment"><div class="line">$ cd &lt;project_dir&gt;/amd64/win_gcc</div>
</div><!-- fragment --><p >— where <code>&lt;project_dir&gt;</code> signifies the path to your generated DriverWizard project directory (for example, <code>~/WinDriver/wizard/my_projects/my_kp</code>).</p>
<ul>
<li>Build the application using the make command.</li>
</ul>
<h2><a class="anchor" id="ch13_8_2_linux_kernel_plugin_driver_compilation"></a>
13.8.2. Linux Kernel PlugIn Driver Compilation</h2>
<p >To build your Kernel PlugIn driver and respective user-mode application on Linux, follow these steps:</p>
<ul>
<li>Open a shell terminal.</li>
<li>Change directory to your Kernel PlugIn directory.</li>
</ul>
<p >For example:</p>
<ul>
<li>When building the sample KP_PCI driver —</li>
</ul>
<div class="fragment"><div class="line">$ cd WinDriver/samples/c/pci_diag/kp_pci</div>
</div><!-- fragment --><ul>
<li>When building a wizard-generated Kernel PlugIn driver —</li>
</ul>
<div class="fragment"><div class="line">$ cd &lt;project_dir&gt;/kermode/linux/</div>
</div><!-- fragment --><p >— where <code>&lt;project_dir&gt;</code> signifies the path to your generated DriverWizard project directory (for example, <code>~/WinDriver/wizard/my_projects/my_kp</code>).</p><ul>
<li>Generate the makefile using the configure script:</li>
</ul>
<div class="fragment"><div class="line">$ ./configure</div>
</div><!-- fragment --><p >If you have renamed the WinDriver kernel module, be sure to uncomment the following line in your Kernel PlugIn configuration script (by removing the pound sign — "#"), before executing the script, in order to build the driver with the <code>-DWD_DRIVER_NAME_CHANGE</code> flag (see <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_2_2_linux_driver_renaming">17.2.2. Linux Driver Renaming</a>):</p>
<div class="fragment"><div class="line"># ADDITIONAL_FLAGS=&quot;-DWD_DRIVER_NAME_CHANGE&quot;</div>
</div><!-- fragment --><p >The configuration script creates a makefile based on the running kernel. You may select to use another installed kernel source, by executing the script with the <code>--with-kernel-source=&lt;path&gt;</code> option, where <code>&lt;path&gt;</code> is the full path to the kernel source directory — e.g., <code>/usr/src/linux</code>. If the Linux kernel version is 2.6.26 or higher, the configuration script generates makefiles that use kbuild to compile the kernel modules.</p>
<div class="fragment"><div class="line">./configure --help</div>
</div><!-- fragment --><ul>
<li>Build the Kernel PlugIn module using the <code>make</code> command.</li>
</ul>
<p >This command creates a new <code>LINUX.&lt;kernel version&gt;.&lt;CPU&gt;</code> directory, which contains the created <code>kp_xxx_module.o/.ko</code> driver.</p><ul>
<li>Change directory to the directory that holds the makefile for the sample user-mode diagnostics application.</li>
</ul>
<p >For the KP_PCI sample driver —</p>
<div class="fragment"><div class="line">$ cd ../LINUX/</div>
</div><!-- fragment --><p >For the generated DriverWizard Kernel PlugIn driver —</p>
<div class="fragment"><div class="line">$ cd ../../linux/</div>
</div><!-- fragment --><ul>
<li>Compile the sample diagnostics program using the <code>make</code> command.</li>
</ul>
<h2><a class="anchor" id="ch13_8_3_porting_a_kernel_plugin_project_developed_prior_to_version_10_3_0_to_support_working_with_a_32-bit_user-mode_application_and_a_64-bit_kernel_plugin_driver"></a>
13.8.3. Porting a Kernel PlugIn project developed prior to version 10.3.0, to support working with a 32-bit user-mode application and a 64-bit Kernel PlugIn driver</h2>
<p >Beginning with version 10.3.0 of WinDriver, you can communicate with a 64-bit Kernel PlugIn driver from a 32-bit user-mode application. To support such a configuration, you need to keep in mind the following points:</p>
<ul>
<li>The application must open a handle to the Kernel PlugIn driver using <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> (or the low-level <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> function, if you are not using the WDC library).</li>
</ul>
<p >The handle cannot be opened using one of the WDC device-open functions, e.g. <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a>, by calling it with the name of a Kernel PlugIn driver. In all Kernel PlugIn configurations, except for a 64-bit driver that interacts with a 32-bit application, either of these methods can be used to open a handle to the Kernel PlugIn from the application.</p>
<ul>
<li>The Kernel PlugIn driver must implement a <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open</a> callback that correctly translates the 32-bit data received from the user mode, into 64-bit kernel data.</li>
</ul>
<p >The Kernel PlugIn driver’s <a class="el" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5" title="You must define a KP_Init() function to link to the device driver.">KP_Init()</a> function must set this callback in the funcOpen_32_64 field of the <a class="el" href="structKP__INIT.html">KP_INIT</a> structure that it initializes. This field was added in version 10.3.0 of WinDriver.</p>
<p >The callback set in the <a class="el" href="structKP__INIT.html">KP_INIT</a> funcOpen_32_64 field, is called by WinDriver when a 32-bit application opens a handle to a Kernel PlugIn driver. This callback will hereby be referred to as the funcOpen_32_64 callback. The callback set in the <a class="el" href="structKP__INIT.html">KP_INIT</a> funcOpen field is the standard KP_Open callback, which is called by WinDriver whenever an application opens a Kernel PlugIn handle, except for the specific configuration in which the funcOpen_32_64 callback is used. This callback will hereby be referred to as the funcOpen callback. When writing your Kernel PlugIn driver, you can select whether to provide both of these callback types or just one of them — depending on how you plan to build the driver and how you expect it to be used. For example, if you are not planning to use the driver on a 64-bit operating system, you do not need to implement and set funcOpen_32_64.</p>
<p >In version 10.3.0 and above of WinDriver, the generated DriverWizard Kernel PlugIn projects, and the sample PCI Kernel PlugIn project (kp_pci), are written so as to support all types of user-mode and Kernel PlugIn configurations, including using a 32-bit application with a 64-bit Kernel PlugIn.</p>
<p >To modify code developed with earlier versions of WinDriver to afford the same support, follow these steps:</p>
<p ><em>In the user-mode code, do the following:</em></p>
<ul>
<li>Separate the steps of opening a handle to the device and opening a handle to the Kernel PlugIn. In version 10.2.1 and below of WinDriver, the sample and generated code used the <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> functions (e.g., <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a>) to open both of these handles. As explained above, this method cannot be used if you also wish to work with a 32-bit application and a 64-bit Kernel PlugIn driver. If your code uses this method, modify the call to <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> so that you pass NULL for the last two parameters — <code>pcKPDriverName</code> and <code>pKPOpenData</code>.</li>
<li>Use <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> to open the handle to the Kernel PlugIn driver.</li>
</ul>
<p >For the function’s hDev parameter, pass the same handle whose address was passed as the <code>phDev</code> parameter of the device-open function.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;You are passing hDev — WDC_DEVICE_HANDLE — and not &amp;hDev — WDC_DEVICE_HANDLE* — like in the first parameter of <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a>. </p>
</blockquote>
</blockquote>
<p>For the pcKPDriverName parameter, pass the name of your Kernel PlugIn driver (as previously done for the equivalent device-open function parameter, if you used it to also open the Kernel PlugIn handle).</p>
<p >For the pKPOpenData parameter, pass the data you wish to pass down from the application to the Kernel PlugIn (similar to the device-open function parameter of the same name).</p>
<p >In the older WinDriver sample and generated code, the device handle was passed as the open-data. However, to reduce the work that would need to be done in the Kernel PlugIn to convert the 32-bit data to64-bit, the newer code now passes only the necessary information to the Kernel PlugIn, we recommend that you do the same:</p><ul>
<li>Define the following types, to be used both by the user-mode and Kernel PlugIn code (in the sample and generated code, these types are defined in the xxx_lib.h file):</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/* Device address description struct */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    DWORD dwNumAddrSpaces;    <span class="comment">/* Total number of device address spaces */</span></div>
<div class="line">    <a class="code hl_struct" href="structWDC__ADDR__DESC.html">WDC_ADDR_DESC</a> *pAddrDesc; <span class="comment">/* Array of device address spaces information */</span></div>
<div class="line">} PCI_DEV_ADDR_DESC;</div>
<div class="ttc" id="astructWDC__ADDR__DESC_html"><div class="ttname"><a href="structWDC__ADDR__DESC.html">WDC_ADDR_DESC</a></div><div class="ttdoc">Address space information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00027">wdc_defs.h:27</a></div></div>
</div><!-- fragment --><ul>
<li>Allocate a variable of type PCI_DEV_ADDR_DESC and set its fields according to the information returned by the previous call to the <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> function. In the sample and generated code, this is done in the xxx_lib.c file as shown below:</li>
</ul>
<div class="fragment"><div class="line">PCI_DEV_ADDR_DESC devAddrDesc;</div>
<div class="line"><a class="code hl_struct" href="structWDC__DEVICE.html">PWDC_DEVICE</a> pDev; </div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">dwStatus = <a class="code hl_function" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee">WDC_PciDeviceOpen</a>(&amp;hDev, pDeviceInfo, pDevCtx, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div>
<div class="line">...</div>
<div class="line">pDev = hDev;</div>
<div class="line">devAddrDesc.dwNumAddrSpaces = pDev-&gt;<a class="code hl_variable" href="structWDC__DEVICE_aaef64eb6c013ba0dc8451fd9c38e1cb0.html#aaef64eb6c013ba0dc8451fd9c38e1cb0">dwNumAddrSpaces</a>;</div>
<div class="line">devAddrDesc.pAddrDesc = pDev-&gt;<a class="code hl_variable" href="structWDC__DEVICE_af5c98f10666fd64f12076a3e85639dfb.html#af5c98f10666fd64f12076a3e85639dfb">pAddrDesc</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44">WDC_KernelPlugInOpen</a>(hDev, KP_PCI_DRIVER_NAME, &amp;devAddrDesc);</div>
<div class="ttc" id="akpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00268">kpstdlib.h:268</a></div></div>
<div class="ttc" id="astructWDC__DEVICE_aaef64eb6c013ba0dc8451fd9c38e1cb0_html_aaef64eb6c013ba0dc8451fd9c38e1cb0"><div class="ttname"><a href="structWDC__DEVICE_aaef64eb6c013ba0dc8451fd9c38e1cb0.html#aaef64eb6c013ba0dc8451fd9c38e1cb0">WDC_DEVICE::dwNumAddrSpaces</a></div><div class="ttdeci">DWORD dwNumAddrSpaces</div><div class="ttdoc">PCI device slot location information.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00050">wdc_defs.h:50</a></div></div>
<div class="ttc" id="astructWDC__DEVICE_af5c98f10666fd64f12076a3e85639dfb_html_af5c98f10666fd64f12076a3e85639dfb"><div class="ttname"><a href="structWDC__DEVICE_af5c98f10666fd64f12076a3e85639dfb.html#af5c98f10666fd64f12076a3e85639dfb">WDC_DEVICE::pAddrDesc</a></div><div class="ttdeci">WDC_ADDR_DESC * pAddrDesc</div><div class="ttdoc">Total number of device's address spaces.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00053">wdc_defs.h:53</a></div></div>
<div class="ttc" id="astructWDC__DEVICE_html"><div class="ttname"><a href="structWDC__DEVICE.html">WDC_DEVICE</a></div><div class="ttdoc">Device information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00046">wdc_defs.h:46</a></div></div>
<div class="ttc" id="awdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee_html_a458f2b87b43dac172f259ce78d5380ee"><div class="ttname"><a href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee">WDC_PciDeviceOpen</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_PciDeviceOpen(_Outptr_ WDC_DEVICE_HANDLE *phDev, _In_ const WD_PCI_CARD_INFO *pDeviceInfo, _In_ const PVOID pDevCtx)</div><div class="ttdoc">Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...</div></div>
<div class="ttc" id="awdc__lib_8h_a8e405829088b75e2980d866a70d55c44_html_a8e405829088b75e2980d866a70d55c44"><div class="ttname"><a href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44">WDC_KernelPlugInOpen</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_KernelPlugInOpen(_In_ WDC_DEVICE_HANDLE hDev, _In_ const CHAR *pcKPDriverName, _In_ PVOID pKPOpenData)</div><div class="ttdoc">Opens a handle to a Kernel PlugIn driver.</div></div>
</div><!-- fragment --><p >In the Kernel PlugIn driver code, do the following:</p>
<ul>
<li>Modify your funcOpen callback.</li>
</ul>
<p >If you have changed the type of the open-data that is passed from the user mode to the driver, you need to adjust the implementation of your open-callback accordingly. If your existing code was based on the sample or generated Kernel PlugIn code in earlier versions of WinDriver, and you have selected to pass the address of a PCI_DEV_ADDR_DESC struct as your Kernel PlugIn open-data modify your funcOpen callback as follows:</p>
<ul>
<li>Replace the PWDC_DEVICE <code>hDev;</code> definition with PCI_DEV_ADDR_DESC <code>*pDevAddrDesc;</code> and replace instances of <a class="el" href="structWDC__DEVICE.html" title="Device information struct.">WDC_DEVICE</a> and pDev in the function with PCI_DEV_ADDR_DESC and pDevAddrDesc respectively.</li>
<li>Remove the temp variable definition and replace the two COPY_FROM_USER calls (which use the temp variable) with the following call: COPY_FROM_USER(pDevAddrDesc, pOpenData, dwSize).</li>
<li>As an additional unrelated fix to previous sample and generated WinDriver funcOpen implementations, move the call to the library initialization function (PCI_LibInit() in the PCI sample / XXX_LibInit in the generated DriverWizard code — where XXX is the name of your driver project) to the beginning of the function — right after the variable declarations and before the first call to the Kernel PlugIn trace messages function (KP_PCI_Trace() in the PCI sample /KP_XXX_Trace() in the wizard-generated code).</li>
<li>Create your funcOpen_32_64 callback.</li>
</ul>
<p >Copy your funcOpen callback function, and rename it. The renamed function will be modified to implement your funcOpen_32_64 callback — for opening a handle to a64-bit Kernel PlugIn driver from a 32-bit application. In the <code>WinDriver/samples/c/pci_diag/kp_pci/kp_pci.c</code> sample, the funcOpen function is named <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec" title="Kernel PlugIn open function.">KP_PCI_Open()</a>, and the funcOpen_32_64 function is named <a class="el" href="kp__pci_8c_aef82dc4d6be42eed5b8b9e6352a027a9.html#aef82dc4d6be42eed5b8b9e6352a027a9" title="KP_PCI_Open_32_64 is called when WD_KernelPlugInOpen() is called from a 32-bit user mode application ...">KP_PCI_Open_32_64()</a>. The generated DriverWizard Kernel PlugIn open functions are named in a similar manner, except that “PCI” is replaced with your selected driver project name.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;If you only plan to support a 32-bit application and 64-bit Kernel PlugIn configuration, you can skip this step, and in the next step modify your <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open</a> callback to use it as your funcOpen_32_64 callback, and then assign this callback to the <a class="el" href="structKP__INIT.html">KP_INIT</a> funcOpen_32_64 field, instead of to the funcOpenfield. </p>
</blockquote>
</blockquote>
<p>However, to keep your code portable, it’s best to implement both types of callbacks.</p>
<ul>
<li>Edit your Kernel PlugIn code to handle the translation of the 32-bit data passed from the user mode, into 64-bit kernel data:</li>
<li>Add a 32-bit definition of the Kernel PlugIn open-data type.</li>
<li>In your funcOpen_32_64 callback, translate the 32-bit open-date received from the user mode, into the equivalent 64-bit type.</li>
</ul>
<p >For example, if your original code was based on the sample or generated Kernel PlugIn code in earlier versions of WinDriver, and you have selected to pass the address of a PCI_DEV_ADDR_DESC struct as your Kernel PlugIn open-data modify the code as follows:</p><ol type="1">
<li>Add the following definitions at the beginning of the file:</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#define PTR32 DWORD</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>WDC_DEV_ADDR_DESC_32B {</div>
<div class="line">    DWORD dwNumAddrSpaces; <span class="comment">/* Total number of device address spaces */</span></div>
<div class="line">    <a class="code hl_define" href="kp__pci_8c_a9022ff467e2be5f7966e67de496a33ca.html#a9022ff467e2be5f7966e67de496a33ca">PTR32</a> pAddrDesc;       <span class="comment">/* Array of device address spaces information */</span></div>
<div class="line">} WDC_DEV_ADDR_DESC_32B, *PWDC_DEV_ADDR_DESC_32B;</div>
<div class="ttc" id="akp__pci_8c_a9022ff467e2be5f7966e67de496a33ca_html_a9022ff467e2be5f7966e67de496a33ca"><div class="ttname"><a href="kp__pci_8c_a9022ff467e2be5f7966e67de496a33ca.html#a9022ff467e2be5f7966e67de496a33ca">PTR32</a></div><div class="ttdeci">#define PTR32</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00046">kp_pci.c:46</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Modify your funcOpen_32_64 callback as follows: Add the following definition:</li>
</ol>
<div class="fragment"><div class="line">WDC_DEV_ADDR_DESC_32B devAddrDesc_32;</div>
</div><!-- fragment --><p >Then add the following lines after the kpOpenCall field assignments, in order to copy to the kernel mode the 32-bit data that was received from the user mode:</p>
<div class="fragment"><div class="line"><span class="comment">/* Copy device information sent from a 32-bit user application */</span></div>
<div class="line">COPY_FROM_USER(&amp;devAddrDesc_32, pOpenData, <span class="keyword">sizeof</span>(PCI_DEV_ADDR_DESC_32B));</div>
</div><!-- fragment --><p >Then replace the following line — <code>COPY_FROM_USER(pDevAddrDesc, pOpenData, dwSize)</code> — with these lines, in order to copy the 32-bit data into a 64-bit structure:</p>
<div class="fragment"><div class="line"><span class="comment">/* Copy the 32-bit data to a 64-bit struct */</span></div>
<div class="line">pDevAddrDesc-&gt;dwNumAddrSpaces = devAddrDesc_32.dwNumAddrSpaces;</div>
</div><!-- fragment --><p >Replace the second COPY_FROM_USER() call — <code>COPY_FROM_USER(pAddrDesc, pDevAddrDesc-&gt;pAddrDesc, dwSize)</code> — with the following:</p>
<div class="fragment"><div class="line">COPY_FROM_USER(pAddrDesc, (PVOID)(<a class="code hl_typedef" href="windrvr_8h_af00bce214d17682d9198b17439f07091.html#af00bce214d17682d9198b17439f07091">KPTR</a>)devAddrDesc_32.pAddrDesc, dwSize);</div>
<div class="ttc" id="awindrvr_8h_af00bce214d17682d9198b17439f07091_html_af00bce214d17682d9198b17439f07091"><div class="ttname"><a href="windrvr_8h_af00bce214d17682d9198b17439f07091.html#af00bce214d17682d9198b17439f07091">KPTR</a></div><div class="ttdeci">UINT32 KPTR</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00351">windrvr.h:351</a></div></div>
</div><!-- fragment --><ul>
<li>Update your <a class="el" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5" title="You must define a KP_Init() function to link to the device driver.">KP_Init()</a> function.</li>
</ul>
<p >Notify WinDriver of your funcOpen_32_64 callback, by assigning your funcOpen_32_64 callback to the funcOpen_32_64 field of the <a class="el" href="structKP__INIT.html">KP_INIT</a> struct that is initialized in <a class="el" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5" title="You must define a KP_Init() function to link to the device driver.">KP_Init()</a>:</p>
<div class="fragment"><div class="line">kpInit-&gt;funcOpen_32_64 = &lt;Your funcOpen_32_64 callback &gt;;</div>
</div><!-- fragment --><p >For example, this is the assignment line from the updated <code><a class="el" href="kp__pci_8c.html">kp_pci.c</a></code> sample:</p>
<div class="fragment"><div class="line">kpInit-&gt;funcOpen_32_64 = <a class="code hl_function" href="kp__pci_8c_aef82dc4d6be42eed5b8b9e6352a027a9.html#aef82dc4d6be42eed5b8b9e6352a027a9">KP_PCI_Open_32_64</a>;</div>
<div class="ttc" id="akp__pci_8c_aef82dc4d6be42eed5b8b9e6352a027a9_html_aef82dc4d6be42eed5b8b9e6352a027a9"><div class="ttname"><a href="kp__pci_8c_aef82dc4d6be42eed5b8b9e6352a027a9.html#aef82dc4d6be42eed5b8b9e6352a027a9">KP_PCI_Open_32_64</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_Open_32_64(KP_OPEN_CALL *kpOpenCall, HANDLE hWD, PVOID pOpenData, PVOID *ppDrvContext)</div><div class="ttdoc">KP_PCI_Open_32_64 is called when WD_KernelPlugInOpen() is called from a 32-bit user mode application ...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00234">kp_pci.c:234</a></div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;If you select to only implement a funcOpen_32_64 callback, and not to implement a standard funcOpencallback, remove the assignment to the <a class="el" href="structKP__INIT.html">KP_INIT</a> funcOpen field in <a class="el" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5" title="You must define a KP_Init() function to link to the device driver.">KP_Init()</a>. </p>
</blockquote>
</blockquote>
<ul>
<li>Edit all remaining device-open type handling.</li>
</ul>
<p >If you have changed the type of the open-data that is passed from the user mode to the driver, you need to edit the related type handling in your Kernel PlugIn code. For example, if you previously passed PWDC_DEVICE as the open-data type, and you now pass PCI_DEV_ADDR_DESC, and your code was previously developed using the a WinDriver sample or wizard-generated Kernel PlugIn driver, you would need to make the following additional changes:</p>
<ul>
<li>In <a class="el" href="kp__pci_8c_a94c55a14dd58912cfdf7f467932d9b1c.html#a94c55a14dd58912cfdf7f467932d9b1c">KP_Close</a>, replace this line — free(((PWDC_DEVICE)pDrvContext)-&gt;pAddrDesc) — with the following, to free the correct type:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (((PCI_DEV_ADDR_DESC *)pDrvContext)-&gt;pAddrDesc)</div>
<div class="line">    <a class="code hl_function" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a>(((PCI_DEV_ADDR_DESC *)pDrvContext)-&gt;pAddrDesc);</div>
<div class="ttc" id="akpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650_html_acc3b4a8c7b4ba9ec1fd2138ca3f6f650"><div class="ttname"><a href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a></div><div class="ttdeci">void __cdecl free(void *buf)</div></div>
</div><!-- fragment --><ul>
<li>In KP_IntAtIrql, replace this line — <code>PWDC_DEVICE pDev = (PWDC_DEVICE)pIntContext;</code> — with the following:</li>
</ul>
<div class="fragment"><div class="line">PCI_DEV_ADDR_DESC *pDevAddrDesc = (PCI_DEV_ADDR_DESC *)pIntContext;</div>
</div><!-- fragment --><p >and edit any remaining pDev instances in the function. For example, replace this line — <code>pAddrDesc = &amp;pDev-&gt;pAddrDesc[INTCSR_ADDR_SPACE];</code> — with the following:</p>
<div class="fragment"><div class="line">pAddrDesc = &amp;pDevAddrDesc-&gt;pAddrDesc[INTCSR_ADDR_SPACE];</div>
</div><!-- fragment --><h1><a class="anchor" id="ch13_9_install_your_kernel_plugin_driver"></a>
13.9. Install Your Kernel PlugIn Driver</h1>
<h2><a class="anchor" id="ch13_9_1_windows_kernel_plugin_driver_installation"></a>
13.9.1. Windows Kernel PlugIn Driver Installation</h2>
<p >Verify that the WinDriver kernel module is installed: Before installing your Kernel PlugIn driver, verify that the WinDriver driver — <code>windrvr&lt;version&gt;.sys/.o/.ko</code> in the newer WinDriver versions (e.g., <code>windrvr1511.sys/.o/.ko</code>) — is installed, since the Kernel PlugIn module depends on the WinDriver module for its successful operation. You can run the Debug Monitor to verify that WinDriver is loaded.</p>
<p >Install your Kernel PlugIn driver:</p><ul>
<li>Remember to copy your Kernel PlugIn driver (my_kp.sys/.kext/.o/.ko) to the operating system’s drivers/modules directory before attempting to install the driver.</li>
<li>Don’t forget to install your Kernel PlugIn driver before running your application:On Windows: Use the wdreg installation utility (or wdreg_gui/wdreg_frontend — depending on the WinDriver version and OS that you are using) to install the driver. To install a <code>my_kp.sys</code> driver, run this command: <div class="fragment"><div class="line">wdreg -name MY_KP install</div>
</div><!-- fragment --></li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;The Kernel PlugIn is not backward compatible. Therefore, when switching to a different version of WinDriver, you need to rebuild your Kernel PlugIn driver using the new version. </p>
</blockquote>
</blockquote>
<p>Driver installation on Windows requires administrator privileges.</p>
<p >The following steps can also be performed with the <code>wdreg_frontend.exe</code> GUI application. For additional information, refer to <a class="el" href="ch16_dynamically_loading_your_driver.html#ch16_3_the_wdreg_frontend_utility">16.3. The wdreg_frontend utility</a>.</p>
<ul>
<li>Copy the driver file (<code>xxx.sys</code>) to the target platform's drivers directory: <code>windir%\system32\drivers</code> (e.g., <code>C:\WINDOWS\system32\drivers</code>).</li>
<li>Register/load your driver, using the <code>wdreg.exe</code> or <code>wdreg_gui.exe</code> utility:</li>
</ul>
<p >In the following instructions, KP_NAME stands for your Kernel PlugIn driver's name, without the <code>.sys</code> extension. To install your driver, run this command:</p>
<div class="fragment"><div class="line">WinDriver\util\wdreg -name KP_NAME install</div>
</div><!-- fragment --><p >Kernel PlugIn drivers are dynamically loadable — i.e., they can be loaded and unloaded without reboot. For additional information, refer to <a class="el" href="ch16_dynamically_loading_your_driver.html#ch16_2_3_dynamically_loading-unloading_your_kernel_plugin_driver_windows">16.2.3. Dynamically Loading/Unloading Your Kernel PlugIn Driver</a>.</p>
<h2><a class="anchor" id="ch13_9_2_linux_kernel_plugin_driver_installation"></a>
13.9.2. Linux Kernel PlugIn Driver Installation</h2>
<p >On Linux, you do not need to copy the driver file, since the driver installation (<code>make install</code>) will handle this for you:</p>
<ul>
<li>Change directory to your Kernel PlugIn driver directory.</li>
</ul>
<p >For example, when installing the sample KP_PCI driver, run</p>
<div class="fragment"><div class="line">$ cd WinDriver/samples/c/pci_diag/kp_pci</div>
</div><!-- fragment --><p >When installing a driver created using the Kernel PlugIn files generated by DriverWizard, run the following command, where <code>&lt;path&gt;</code> signifies the path to your generated DriverWizard project directory (e.g., <code>~/WinDriver/wizard/my_projects/my_kp</code>):</p>
<div class="fragment"><div class="line">$ cd &lt;path&gt;/kermode/</div>
</div><!-- fragment --><ul>
<li>Execute the following command to install your Kernel PlugIn driver:</li>
</ul>
<p >The following command must be executed with root privileges.</p>
<div class="fragment"><div class="line"># make install</div>
</div><!-- fragment --><p >Kernel PlugIn drivers are dynamically loadable — i.e., they can be loaded and unloaded without reboot. For additional information, refer to <a class="el" href="ch16_dynamically_loading_your_driver.html#ch16_4_1_dynamically_loading-unloading_your_kernel_plugin_driver_linux">16.4.1. Dynamically Loading/Unloading Your Kernel PlugIn Driver</a>.</p>
<h1><a class="anchor" id="ch13_10_faq_creating_a_kernel_plugin_driver"></a>
13.10. FAQ</h1>
<h2><a class="anchor" id="ch13_10_1_i_would_like_to_execute_in_the_kernel_some_pieces_of_code_written_in_languages_other_than_c-cpp_python-java-c-sharp-visual_basic_dotnet_using_the_kernel_plugin_is_it_possible"></a>
13.10.1. I would like to execute in the kernel some pieces of code written in languages other than C/C++ (Python/Java/C#/Visual Basic.NET), using the Kernel PlugIn. Is it possible?</h2>
<p >The Kernel PlugIn is a kernel module, and therefore must be written in the C language. However, the user application that calls the Kernel PlugIn can be of any langauge supported by WinDriver: C, C#.NET, Visual Basic.NET, Java, Python. When generating code in the DriverWizard in languages other than C with Kernel PlugIn, the Kernel PlugIn code will still be generated in C. This user application would communicate with the C-language Kernel PlugIn.</p>
<p >If you select to implement such a design, in order to ensure the correct interaction between the user mode and Kernel PlugIn applications, you will need to implement a file in your programming language that contains common definitions for the Kernel PlugIn and the user mode applications — as done in the library header files of the sample and DriverWizard generated Kernel PlugIn C projects (e.g. <code>WinDriver\samples\pci_diag\pci_lib.h</code>, used by the sample KP_PCI driver). WinDriver implements these files for you when you generate code with DriverWizard, and they should be generated in your project directory, for you to start as fast and easy as possible.</p>
<p >For further examples check: <code>WinDriver/include/windrvr.h</code> C header file and the corresponding <code>WinDriver/samples/python/wdlib/windrvr.py</code> (Python), <code>WinDriver/src/wdapi_dotnet/windrvr.h</code> (.NET), <code>WinDriver/lib/wdapi_javaXXX.jar</code> (Java) as examples of implementing the same code both in C and other supported/ languages.</p>
<h2><a class="anchor" id="ch13_10_2_how_do_i_allocate_locked_memory_in_the_kernel_that_can_be_used_inside_the_interrupt_handler"></a>
13.10.2. How do I allocate locked memory in the kernel that can be used inside the interrupt handler?</h2>
<p >WinDriver implements <code><a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a></code> and <code><a class="el" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free()</a></code> in its Kernel PlugIn library (<code>kp_nt1511.lib</code>/<code>kp_linux1511.o_shipped</code>), to which your Kernel PlugIn code is linked.</p>
<p >These functions are implemented to allocate locked memory when called from the kernel mode, so you can use that memory in your interrupt handler as well.</p>
<h2><a class="anchor" id="ch13_10_3_how_do_i_handle_shared_pci_interrupts_in_the_kernel_plugin"></a>
13.10.3. How do I handle shared PCI interrupts in the Kernel PlugIn?</h2>
<p >PCI interrupts are normally handled at the kernel level. Therefore, the best way to handle PCI interrupts with WinDriver is using the Kernel PlugIn feature, which lets you implement code directly at the kernel level. This is specifically true when handling interrupts that are shared between different hardware devices — a very common phenomenon in the case of PCI interrupts, which are by definition sharable.</p>
<p >The Kernel PlugIn consists of two interrupt handler functions:</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Replace “KP_” in the function names below with the name of your Kernel PlugIn driver. For example, the Kernel PlugIn interrupt handler functions for the sample KP_PCI driver are <code>KP_PCI_IntAtIrql</code> and <code>KP_PCI_IntAtDpc</code>. </p>
</blockquote>
</blockquote>
<ul>
<li><a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> — this function is executed in the kernel at high IRQ (Interrupt Request) level immediately upon the detection of an interrupt. The function should contain the write/read commands for clearing the source of the interrupt (acknowledging the interrupt) and any additional high-priority interrupt-handling code.</li>
</ul>
<p >If additional deferred kernel- or user-mode interrupt processing is required, <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> should return TRUE, in which case the deferred <a class="el" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_IntAtDpc</a> routine (see below) will be executed once the high-level processing is completed. Otherwise, the function should return FALSE and <a class="el" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_IntAtDpc</a> (as well as any existing user-mode interrupt-handler routine) will not be executed. The generated and sample WinDriver Kernel PlugIn projects, for example, schedule deferred interrupt processing once every five interrupts by implementing code that returns TRUE only for every fifth <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> call.</p><ul>
<li><a class="el" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_IntAtDpc</a> — this function is executed in the kernel at raised execution level, provided <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> returned TRUE (see above), and should contain any lower-priority kernel interrupt handling that you wish to perform. The return value of this function determines how many times, if at all, the user-mode interrupt-handler routine (which can be set in the call to <code>WDC_InterruptEnable()</code> from the user-mode) will be executed once the control returns to the user mode.</li>
</ul>
<p >To handle shared PCI interrupts with WinDriver, perform the following steps:</p>
<ul>
<li>Generate a Kernel PlugIn project using WinDriver’s DriverWizard utility. When generating C code with the DriverWizard, you will be given the option to generate Kernel PlugIn code — simply check the relevant check-box and proceed to generate the code. Alternatively, you can also use the generic WinDriver Kernel PlugIn sample — KP_PCI(<code>WinDriver\samples\c\pci_diag\kp_pci\<a class="el" href="kp__pci_8c.html">kp_pci.c</a></code>) — as the basis for your Kernel PlugIn project. If you are developing a driver for a Xilinx PCI Express card with Bus Master DMA (BMD) design, you can use the sample Kernel PlugIn driver for this design — KP_BMD (<code>WinDriver\samples\c\xilinx\bmd_design\kp\kp_bmd.c</code>) — or select to generate customized DriverWizard code for this design, including Kernel Plugin code.</li>
</ul>
<p >The advantage of using the DriverWizard is that the generated code will utilize the specific device configuration information detected for your device, as well as any hardware-specific information that you define with the DriverWizard. When generating Kernel PlugIn code for handling PCI interrupts, in the DriverWizard’s Registers tab define the registers that you wish to access upon the detection of an interrupt, and then in the Interrupts tab assign the registers read/write commands that you wish to perform at high IRQ level (<a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a>) to the interrupt. The exact commands for acknowledging the interrupt are hardware-specific and you should therefore consult your hardware specification to determine the correct commands to set.</p>
<ul>
<li>The correct way to handle PCI interrupts with the Kernel PlugIn, and shared interrupts in particular, is to include a command in <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> that reads information from the hardware (normally you would read from the interrupt status register — INTCSR) in order to determine if your hardware generated the interrupt. (You can define a relevant read command in the DriverWizard before generating your Kernel PlugIn code — refer to step #1 above — or manually modify the generated/sample code to add such a command.) If the interrupt was indeed generated by your hardware, the function can set the value of the <code>fIsMyInterrupt</code> parameter to TRUE in order to accept control of the interrupt, and then proceed to write/read the relevant hardware register(s) in order to acknowledge the interrupt, and either return TRUE to perform additional deferred processing or return FALSEif no such processing is required (see above). If, however, you determine that the interrupt was not generated by your hardware, <code>fIsMyInterrupt</code> should be set to FALSE, in order to ensure that the interrupt will be passed on to other drivers in the system, and <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> should return FALSE. Important to mention that there is no real harm in setting <code>fIsMyInterrupt</code> to FALSE even if the interrupt belongs to you, as done by default in the generated and sample WinDriver code, since other drivers in the system, assuming they were implemented correctly, should not attempt to handle the interrupt if it was not generated by their hardware.</li>
</ul>
<p >The portion of the code that performs the check whether your hardware generated the interrupt is based on hardware-specific logic that cannot be defined in the DriverWizard. You will therefore need to modify the generated/sample <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> implementation and add a relevant “if” clause to ensure that you do not accept control of an interrupt that was not generated by your hardware and do not attempt to clear the source of such an interrupt in the hardware.</p>
<p >Following is a sample <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> implementation. The code reads the INTCSR memory register (defined elsewhere in the code) and only proceeds to accept control of the interrupt and acknowledge it if the value read from the INTCSR is 0xFF (which serves as an indication in this sample that our hardware generated the interrupt). The interrupt in this sample is acknowledged by writing back to the INTCSR the value that was read from it.</p>
<div class="fragment"><div class="line">BOOL __cdecl KP_XXX_IntAtIrql(PVOID pIntContext, BOOL *pfIsMyInterrupt)</div>
<div class="line">{</div>
<div class="line">    XXX_HANDLE hXXX = (XXX_HANDLE) pIntContext;</div>
<div class="line">    DWORD data = 0;</div>
<div class="line">    PVOID pData = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    DWORD addrSpace;</div>
<div class="line">    <a class="code hl_struct" href="structWD__ITEMS.html">WD_ITEMS</a> *pItem;</div>
<div class="line"> </div>
<div class="line">    addrSpace = XXX_INTCSR_SPACE;</div>
<div class="line">    pItem = &amp;hXXX-&gt;cardReg.Card.Item[hXXX-&gt;addrDesc[addrSpace].index];</div>
<div class="line">    pData = (DWORD*)pItem-&gt;<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">Mem</a>.dwTransAddr;</div>
<div class="line">    (DWORD)pData += XXX_INTCSR_OFFSET; </div>
<div class="line">    data = dtoh32(*((DWORD*)pData));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (data == 0xFF)</div>
<div class="line">        <span class="comment">/* The interrupt was generated by our hardware */</span></div>
<div class="line">    </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Write 0x0 to INTCSR to acknowledge the interrupt */</span></div>
<div class="line">        *((DWORD*)pData) = dtoh32(data);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">/* Accept control of the interrupt */</span></div>
<div class="line">        *pfIsMyInterrupt = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>; </div>
<div class="line">        </div>
<div class="line">        <span class="comment">/* Schedule deferred interrupt processing (XXX_IntAtDpc) */</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* (Do not acknowledge the interrupt) */</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* Do not accept control of the interrupt */</span>    </div>
<div class="line">        *pfIsMyInterrupt = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">/* Do not schedule deferred interrupt processing */</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="akpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00264">kpstdlib.h:264</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c_html_a3db4e8fac096adebe46f343f4ff4131c"><div class="ttname"><a href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">WD_ITEMS::I</a></div><div class="ttdeci">union WD_ITEMS::@15 I</div></div>
<div class="ttc" id="astructWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900_html_ac808e22b22c02d7f6371fa3ec89e1900"><div class="ttname"><a href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">WD_ITEMS::Mem</a></div><div class="ttdeci">struct WD_ITEMS::@15::@16 Mem</div><div class="ttdoc">ITEM_MEMORY.</div></div>
<div class="ttc" id="astructWD__ITEMS_html"><div class="ttname"><a href="structWD__ITEMS.html">WD_ITEMS</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00691">windrvr.h:692</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="ch13_10_4_what_is_pintcontext_in_the_kernel_plugin_interrupt_functions"></a>
13.10.4. What is pIntContext in the Kernel PlugIn interrupt functions?</h2>
<p ><code>pIntContext</code> is private context data that is passed from <a class="el" href="kp__pci_8c_a58602ae407f1cd41f7012e82590382fa.html#a58602ae407f1cd41f7012e82590382fa">KP_IntEnable</a> to the Kernel PlugIn interrupt handler functions — KP_IntAtIrql() and KP_IntAtDpc().</p>
<h2><a class="anchor" id="ch13_10_5_i_need_to_call_wd_transfer_in_the_kernel_plugin_from_where_do_i_get_hwd_to_pass_to_these_functions"></a>
13.10.5. I need to call WD_Transfer() in the Kernel PlugIn. From where do I get hWD to pass to these functions?</h2>
<p >Jungo strongly recommends using the high-level WDC (PCI) API instead of using the low-level API.</p>
<p >To obtain the handle to WinDriver’s kernel module (hWD) from the Kernel PlugIn, you can call <a class="el" href="wd__log_8h_af5b59012df248f79156d5d154eea6264.html#af5b59012df248f79156d5d154eea6264">WD_Open()</a> directly from the Kernel PlugIn.</p>
<p >For PCI/ISA, you can also use the <code>hWD</code> handle, which is passed from the user mode via <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a>, and received as the second argument of the Kernel PlugIn callback function <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open()</a>. Alternatively, you can also pass the handle from the user mode to the Kernel PlugIn using the pData field of the <a class="el" href="structWD__KERNEL__PLUGIN__CALL.html">WD_KERNEL_PLUGIN_CALL</a> struct, which is used in the call to <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> in the user mode and results in a callback to <a class="el" href="kp__pci_8c_ab5c8485a1ca1b486dada24cefc0c92b9.html#ab5c8485a1ca1b486dada24cefc0c92b9">KP_Call()</a> in the Kernel PlugIn.</p>
<p >After obtaining the handle to WinDriver, the call to <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> (or any other WinDriver API that receives a handle to WinDriver as a parameter) is the same as in the user mode.</p>
<h2><a class="anchor" id="ch13_10_6_a_restriction_in_kp_intatirql_is_to_use_only_non-pageable_memory_what_does_this_mean"></a>
13.10.6. A restriction in KP_IntAtIrql is to use only non-pageable memory. What does this mean?</h2>
<p >Variables defined in the Kernel PlugIn project (such as global and local variables) are non paged. WinDriver also implements <code><a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a></code> to allocate non-paged memory when used from within the kernel.</p>
<p >If you are using a pointer to the memory in the user mode from within the Kernel PlugIn, you need to make a copy of its contents (allocate memory and copy the data to the non-paged memory) in order to access it from your <code>KP_IntAtIrql</code> function, in order to ensure safe access to the data at all times.</p>
<h2><a class="anchor" id="ch13_10_7_how_do_i_call_wd_transfer_in_the_kernel_plugin_interrupt_handler"></a>
13.10.7. How do I call WD_Transfer() in the Kernel PlugIn interrupt handler?</h2>
<p >You can call <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> from within the <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> or <a class="el" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_IntAtDpc</a> functions (replace “KP” in the function names with your Kernel PlugIn driver name — e.g., “KP_PCI”) in order to access the hardware.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;You can also access the memory or I/O directly from within the Kernel PlugIn interrupt functions. For direct memory access, use the kernel mapping of the memory, returned from <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> in <code>cardReg.Card.Item[i].I.Mem.pTransAddr</code>. </p>
</blockquote>
</blockquote>
<p>When calling <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> you will need to pass as the first argument a handle to WinDriver (<code>hWD</code>). You can refer to the FAQ questions in this chapter to find out how to obtain a handle to WinDriver from within the Kernel PlugIn.</p>
<p >As specified in the aforementioned FAQ questions, you can store the handle to WinDriver in a global Kernel PlugIn variable (recommended), or pass it from one function to another. Below is an example of passing a handle to WinDriver from <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open()</a> to <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a>:</p>
<p >Add the following line to <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open()</a> </p><div class="fragment"><div class="line">ppDrvContext = (PVOID) hWD;</div>
</div><!-- fragment --><p> Add the following line to <a class="el" href="kp__pci_8c_a58602ae407f1cd41f7012e82590382fa.html#a58602ae407f1cd41f7012e82590382fa">KP_IntEnable()</a> </p><div class="fragment"><div class="line">ppIntContext = pDrvContext;</div>
</div><!-- fragment --><p> You can now use <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> to access memory/IO from within <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a>. For example (IO access): </p><div class="fragment"><div class="line">HANDLE hWD = (HANDLE) pIntContext;</div>
<div class="line"><a class="code hl_struct" href="structWD__TRANSFER.html">WD_TRANSFER</a> trans;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_define" href="windrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2.html#a76937ecb185a91a54d8ff74a7f9dfaa2">BZERO</a>(trans);</div>
<div class="line">trans.<a class="code hl_variable" href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">cmdTrans</a> = <a class="code hl_enumvalue" href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a9df23c840cbea579c07396664a5adcc1">WP_BYTE</a>;</div>
<div class="line">trans.dwPort = 0x378;</div>
<div class="line">trans.<a class="code hl_variable" href="structWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b.html#a98e4642f5755fb8489bb9a051fa1e84b">Data</a>.<a class="code hl_variable" href="structWD__TRANSFER_a333d1bf07466bd9686f1078856613101.html#a333d1bf07466bd9686f1078856613101">Byte</a> = 0x65;</div>
<div class="line"><a class="code hl_define" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603">WD_Transfer</a>(hWD, &amp;trans);</div>
<div class="ttc" id="astructWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89_html_a31617c76585d5a5ac91fc21fee963b89"><div class="ttname"><a href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">WD_TRANSFER::cmdTrans</a></div><div class="ttdeci">DWORD cmdTrans</div><div class="ttdoc">Transfer command WD_TRANSFER_CMD.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00566">windrvr.h:566</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_a333d1bf07466bd9686f1078856613101_html_a333d1bf07466bd9686f1078856613101"><div class="ttname"><a href="structWD__TRANSFER_a333d1bf07466bd9686f1078856613101.html#a333d1bf07466bd9686f1078856613101">WD_TRANSFER::Byte</a></div><div class="ttdeci">BYTE Byte</div><div class="ttdoc">Use for 8 bit transfer.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00575">windrvr.h:575</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b_html_a98e4642f5755fb8489bb9a051fa1e84b"><div class="ttname"><a href="structWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b.html#a98e4642f5755fb8489bb9a051fa1e84b">WD_TRANSFER::Data</a></div><div class="ttdeci">union WD_TRANSFER::@14 Data</div></div>
<div class="ttc" id="astructWD__TRANSFER_html"><div class="ttname"><a href="structWD__TRANSFER.html">WD_TRANSFER</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00563">windrvr.h:564</a></div></div>
<div class="ttc" id="awindrvr_8h_a5a8ad1609207945d35bbd4624b55cb97_html_a5a8ad1609207945d35bbd4624b55cb97a9df23c840cbea579c07396664a5adcc1"><div class="ttname"><a href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a9df23c840cbea579c07396664a5adcc1">WP_BYTE</a></div><div class="ttdeci">@ WP_BYTE</div><div class="ttdoc">Write port byte.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00376">windrvr.h:376</a></div></div>
<div class="ttc" id="awindrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2_html_a76937ecb185a91a54d8ff74a7f9dfaa2"><div class="ttname"><a href="windrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2.html#a76937ecb185a91a54d8ff74a7f9dfaa2">BZERO</a></div><div class="ttdeci">#define BZERO(buf)</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01528">windrvr.h:1528</a></div></div>
<div class="ttc" id="awindrvr_8h_ac7801059e5aee0b0a5f314f96bd72603_html_ac7801059e5aee0b0a5f314f96bd72603"><div class="ttname"><a href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603">WD_Transfer</a></div><div class="ttdeci">#define WD_Transfer(h, pTransfer)</div><div class="ttdoc">Executes a single read/write instruction to an I/O port or to a memory address.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01881">windrvr.h:1881</a></div></div>
</div><!-- fragment --><p> This will write 0x65 to port 0x378 upon interrupt. The <code>hWD</code> handle is passed from <a class="el" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_Open()</a> to <a class="el" href="kp__pci_8c_a58602ae407f1cd41f7012e82590382fa.html#a58602ae407f1cd41f7012e82590382fa">KP_IntEnable()</a> to <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a> via the context.</p>
<p >You can also view the generated DriverWizard Kernel PlugIn code for an example of calling <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a> from <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql</a>, provided you have used the DriverWizard to define and assign the register/s for the interrupt acknowledgment before generating the code.</p>
<h2><a class="anchor" id="ch13_10_8_how_do_i_share_a_memory_buffer_between_kernel_plugin_and_user-mode_projects_for_dma_or_other_purposes"></a>
13.10.8. How do I share a memory buffer between Kernel PlugIn and user-mode projects for DMA or other purposes?</h2>
<p >From your user application, use the <code><a class="el" href="wds__lib_8h_a350377180f47fe81b8282a61566390fb.html#a350377180f47fe81b8282a61566390fb" title="Allocates a memory buffer that can be shared between the user mode and the kernel mode (&quot;shared buffe...">WDS_SharedBufferAlloc()</a></code> function to allocate a shared memory buffer, which can be used both from a user-mode application and a Kernel PlugIn driver.</p>
<p >Pass the returned <code>ppKerBuf-&gt;pKernelAddr</code> value from the above function to the Kernel PlugIn using the pData paramter of the function <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a>. Note that <code><a class="el" href="wds__lib_8h_a350377180f47fe81b8282a61566390fb.html#a350377180f47fe81b8282a61566390fb" title="Allocates a memory buffer that can be shared between the user mode and the kernel mode (&quot;shared buffe...">WDS_SharedBufferAlloc()</a></code> is part of the Server APIs of WinDriver, these APIs require a special license.</p>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;If you would like to get more information about Server APIs licensing, please send an e-mail to <a href="#" onclick="location.href='mai'+'lto:'+'Win'+'Dr'+'ive'+'r@'+'jun'+'go'+'.co'+'m'; return false;">WinDr<span class="obfuscator">.nosp@m.</span>iver<span class="obfuscator">.nosp@m.</span>@jung<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>m</a>, and our team will assist you. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch13_10_9_if_i_write_a_new_function_in_my_sys_kernel_plugin_driver_must_it_also_be_declared_with___cdecl"></a>
13.10.9. If I write a new function in my SYS Kernel PlugIn driver, must it also be declared with __cdecl?</h2>
<p >No. Only the callbacks used by WinDriver need to be declared as __cdecl. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
