<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 4: PCI Express Overview"/>
<title>Jungo WinDriver: Chapter 4: PCI Express Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch4_pci_express_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 4: PCI Express Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap04"></a> </p>
<h1><a class="anchor" id="ch4_1_overview_pci_express"></a>
4.1. Overview</h1>
<p >The PCI Express (<b>PCIe</b>) bus architecture (formerly 3GIO or 3rd Generation I/O) was introduced by Intel, in partnership with other leading companies, including IBM, Dell, Compaq, HP and Microsoft, with the intention that it will become the prevailing standard for PC I/O in the years to come.</p>
<p >PCI Express allows for larger bandwidth and higher scalability than the standard PCI 2.2 bus.</p>
<p >The standard PCI 2.2 bus is designed as a single parallel data bus through which all data is routed at a set rate. The bus shares the bandwidth between all connected devices, without the ability to prioritize between devices. The maximum bandwidth for this bus is 132MB/s, which has to be shared among all connected devices.</p>
<p >PCI Express consists of serial, point-to-point wired, individually clocked 'lanes', each lane consisting of two pairs of data lines that can carry data upstream and downstream simultaneously (full-duplex). The bus slots are connected to a switch that controls the data flow on the bus. A connection between a PCI Express device and a PCI Express switch is called a 'link'. Each link is composed of one or more lanes. A link composed of a single lane is called an x1 link; a link composed of two lanes is called an x2 link; etc. PCI Express supports x1, x2, x4, x8, x12, x16, and x32 link widths (lanes). The PCI Express architecture allows for a maximum bandwidth of approximately 500MB/s per lane. Therefore, the maximum potential bandwidth of this bus is 500MB/s for x1, 1,000MB/s for x2, 2,000MB/s for x4, 4,000MB/s for x8, 6,000MB/s for x12, and 8,000MB/s for x16. These values provide a significant improvement over the maximum 132MB/s bandwidth of the standard 32-bit PCI bus. The increased bandwidth support makes PCI Express ideal for the growing number of devices that require high bandwidth, such as hard drive controllers, video streaming devices and networking cards.</p>
<p >The usage of a switch to control the data flow in the PCI Express bus, as explained above, provides an improvement over a shared PCI bus, because each device essentially has direct access to the bus, instead of multiple components having to share the bus. This allows each device to use its full bandwidth capabilities without having to compete for the maximum bandwidth offered by a single shared bus. Adding to this the lanes of traffic that each device has access to in the PCI Express bus, PCI Express truly allows for control of much more bandwidth than previous PCI technologies. In addition, this architecture enables devices to communicate with each other directly (peer-to-peer communication).</p>
<p >In addition, the PCI Express bus topology allows for centralized traffic-routing and resource management, as opposed to the shared bus topology. This enables PCI Express to support quality of service (QoS). The PCI Express switch can prioritize packets, so that real-time streaming packets (i.e., a video stream or an audio stream) can take priority over packets that are not as time critical.</p>
<p >Another main advantage of the PCI Express is that it is cost-efficient to manufacture when compared to PCI and AGP slots or other new I/O bus solutions such as PCI-X.</p>
<p >PCI Express was designed to maintain complete hardware and software compatibility with the existing PCI bus and PCI devices, despite the different architecture of these two buses.</p>
<p >As part of the backward compatibility with the PCI 2.2 bus, legacy PCI 2.2 devices can be plugged into a PCI Express system via a PCI Express-to-PCI bridge, which translates PCI Express packets back into standard PCI 2.2 bus signals. This bridging can occur either on the motherboard or on an external card.</p>
<h1><a class="anchor" id="ch4_2_windriver_for_pci_express"></a>
4.2. WinDriver for PCI Express</h1>
<p >WinDriver fully supports backward compatibility with the standard PCI features on PCI Express boards. The wide support provided by WinDriver for the standard PCI bus — including a rich set of APIs, code samples and the graphical DriverWizard for hardware debugging and driver code generation — is also applicable to PCI Express devices, which by design are backward compatible with the legacy PCI bus.</p>
<p >You can also use WinDriver's PCI API to easily communicate with PCI devices connected to the PC via PCI Express-to-PCI bridges and switches.</p>
<p >In addition, WinDriver provides you with a set of APIs for easy access to the PCI Express extended configuration space on target platforms that support such access (e.g., Windows and Linux) — see the description of the <a class="el" href="wdc__lib_8h_a999f185bff32d67ac90cfc40750a49e5.html#a999f185bff32d67ac90cfc40750a49e5" title="Read/write 8/16/32/64 bits from the PCI configuration space.">WDC_PciReadCfg8()</a> / <a class="el" href="wdc__lib_8h_a878507aa6c55c431e89b43270dc59a73.html#a878507aa6c55c431e89b43270dc59a73" title="Reads 2 bytes (16 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg16()</a> / <a class="el" href="wdc__lib_8h_aa919caae0f60258ebae8b298e1a008fb.html#aa919caae0f60258ebae8b298e1a008fb" title="Reads 4 bytes (32 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg32()</a> / <a class="el" href="wdc__lib_8h_a9a360c5b140e8d839f18f4df0751fae4.html#a9a360c5b140e8d839f18f4df0751fae4" title="Reads 8 bytes (64 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg64()</a> and <a class="el" href="wdc__lib_8h_a0ce3a209f04519ddd0bddf00abf62fd9.html#a0ce3a209f04519ddd0bddf00abf62fd9" title="Writes 1 byte (8 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express d...">WDC_PciWriteCfg8()</a> / <a class="el" href="wdc__lib_8h_af8c5ff2678888ca00f61625f6fc93149.html#af8c5ff2678888ca00f61625f6fc93149" title="Writes 2 bytes (16 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express...">WDC_PciWriteCfg16()</a> / WDC_PcWriteCfg32() / WDC_PcWriteCfg64() functions in this manual, or the description of the lower-level <a class="el" href="windrvr_8h_a0293fd097ebcd936cc1a2a0e6bdead47.html#a0293fd097ebcd936cc1a2a0e6bdead47" title="Reads/writes from/to the PCI configuration space of a selected PCI card or the extended configuration...">WD_PciConfigDump()</a> function.</p>
<p >WinDriver interrupt handling APIs also support Message-Signaled Interrupts (MSI) and Extended Message-Signaled Interrupts (MSI-X).</p>
<h1><a class="anchor" id="ch4_3_the_pci_dump_and_pci_scan_utilities"></a>
4.3. The pci_dump and pci_scan Utilities</h1>
<p ><code>pci_dump</code> is a sample utility console-mode program that is provided with the WinDriver tool-kit and enables you to dump the contents of the PCI configuration registers into a readable format. It can be found in the <code>WinDriver/util</code> directory.</p>
<p >The source code of this utility is provided as well and can be found at: <code>WinDriver/samples/c/pci_dump/pci_dump.c</code>.</p>
<p ><code>pci_scan</code> is a sample utility console-mode program that is provided with the WinDriver tool-kit and enables you to scan the PCI device that are connected to your computer in a readable format. It can be found in the <code>WinDriver/util</code>directory.</p>
<p >The source code of this utility is provided as well and can be found at: <code>WinDriver/samples/c/pci_scan/pci_scan.c</code>.</p>
<h2><a class="anchor" id="ch4_3_1_dump_pci_configuration_space_into_a_file"></a>
4.3.1. Dump PCI Configuration Space into a file</h2>
<p >To log the pci_dump output into a file (dump.txt), do the following:</p>
<ul>
<li>Open a command prompt window.</li>
<li>Run <code>pci_dump</code> as <code>pci_dump &gt; dump.txt</code>.</li>
<li>Hit <b>Enter</b> continuously, until the program’s execution is completed.</li>
</ul>
<p >At the end of this process you wil have a dump.txt file in the <code>WinDriver/util</code> directory (from which <code>pci_dump</code> was run).</p>
<p >The same process can similarly be done with <code>pci_scan</code> output as well.</p>
<blockquote class="doxtable">
<p >&zwj;<b>💡 Recommendation</b></p>
<blockquote class="doxtable">
<p >&zwj;If you have any technical question, we firstly recommend searching the manual. If you cannot find an answer to your question, please send us an e-mail to <a href="#" onclick="location.href='mai'+'lto:'+'win'+'dr'+'ive'+'r@'+'jun'+'go'+'.co'+'m'; return false;">windr<span class="obfuscator">.nosp@m.</span>iver<span class="obfuscator">.nosp@m.</span>@jung<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>m</a>, or if you are already in contact with someone from our team, just send an e-mail to that person directly. Please note that in order to ensure a quick and effective support our engineers may request clear detailed description of the steps you performed, specify which step failed and what was the exact nature of the failure or erroneous behavior that you encountered (including complete error messages, screenshots, logs). </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch4_4_faq_pci_express_overview"></a>
4.4. FAQ</h1>
<h2><a class="anchor" id="ch4_4_1_enabling_legacy_pci_configuration_space_read-write_for_identifying_pci_devices_on_windows"></a>
4.4.1. Enabling legacy PCI configuration space read/write for identifying PCI devices on Windows</h2>
<p >In version 6.2.0 of WinDriver, the PCI configuration space read/write method on Windows was upgraded to a more advanced method. On rare occasions, this method fails to identify some PCI devices. To resolve this problem, from WinDriver version 10.3.1 you can revert to the legacy PCI configuration space read/write method by doing the following:</p>
<p >Set the <code>PciCfgRwCompat</code> registry key flag in the WinDriver driver INF file (<code>windrvr&lt;version&gt;.inf</code>(e.g. <code>windrvr1511.inf</code>) / <code>windrvr6.inf</code> in earlier versions)) — to 1:</p>
<div class="fragment"><div class="line">HKR, Parameters, PciCfgRwCompat, 0x00010001, 1</div>
</div><!-- fragment --><p >Beginning with version 11.1.0 of WinDriver, the driver INF file contains a similar line, which sets the <code>PciCfgRwCompat</code> flag to 0 (default), so you only need to modify the value of the flag in the existing line to 1:</p>
<p >Open a command-line prompt and reinstall the driver by running the following commands from the <code>WinDriver\util\wdreg</code>directory (where “WinDriver” is the path to your WinDriver installation directory):</p>
<div class="fragment"><div class="line">$ wdreg -inf &lt;path to your device INF file&gt; uninstall</div>
<div class="line">$ wdreg -inf &lt;path to the driver INF file&gt; uninstall</div>
<div class="line">$ wdreg -inf &lt;path to the driver INF file&gt; install</div>
<div class="line">$ wdreg -inf &lt;path to your device INF file&gt; install</div>
</div><!-- fragment --><h2><a class="anchor" id="ch4_3_2_how_do_i_access_the_memory_on_my_pci_card_using_windriver"></a>
4.3.2. How do I access the memory on my PCI card using WinDriver?</h2>
<p >First, locate the slot to which your card is connected, using <a class="el" href="wdc__lib_8h_a15790844cb433fbaaf8c390a368d0efb.html#a15790844cb433fbaaf8c390a368d0efb" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevices()</a>.</p>
<p >Then get the card’s information by calling <a class="el" href="wdc__lib_8h_a920d348804f4ee3aa118ebf073d33698.html#a920d348804f4ee3aa118ebf073d33698" title="Retrieves a PCI device&#39;s resources information (memory and I/O ranges and interrupt information).">WDC_PciGetDeviceInfo()</a>.</p>
<p >This information includes the memory range chosen for the card by the Plug and Play system.</p>
<p >Now call <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> to install the memory range and map it into both kernel and user mode virtual address spaces.</p>
<p >You can then either access the memory directly from your user mode application (more efficient), by using the user mode mapping of the physical address — returned by <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> in <code>((PWDC_DEVICE)hDev)-&gt;cardReg.Card.Item[i].I.Mem.pUserDirectAddr</code> (where <code>i</code> is the index number of the memory range in the Item array) — or pass the kernel mode mapping of the memory — <code>((PWDC_DEVICE)hDev)-&gt;cardReg.Card.Item[i].I.Mem.pTransAddr</code> — to <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> / <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a>, in order to access the memory in the kernel. Check out the documentation of <code><a class="el" href="structWDC__DEVICE.html" title="Device information struct.">WDC_DEVICE</a></code> for more info.</p>
<p >This is demonstrated, for example, in the sample code found in the <code>WinDriver/samples/c/pci_diag</code> directory, and in the diagnostics DriverWizard code that you can generate for your PCI card.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;To access memory directly in the kernel, from within a Kernel PlugIn project, you must use the kernel mode mapping of the physical memory address — returned by <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> in <code>(PWDC_DEVICE)hDev)-&gt;cardReg.Card.Item[i].I.Mem.pTransAddr</code> — and not the user mode mapping that is used to access the memory directly from your user-mode application. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch4_3_3_how_do_i_use_windriver_for_pci_express_over_thunderbolt"></a>
4.3.3. How do I use WinDriver for PCI Express over Thunderbolt?</h2>
<p >Assuming your computer's Thunderbolt adapter is correctly configured and your device is recognized by the operating system, then a PCI Express device connected over Thunderbolt should be recognized by WinDriver as a regular PCI Express device and this should not require special actions on the WinDriver side. Some motherboard chipsets require changes in their BIOS settings to enable Thunderbolt support, consult your vendor's documentation for more info. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
