<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 14: USB Advanced Features"/>
<title>Jungo WinDriver: Chapter 14: USB Advanced Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch14_usb_advanced_features.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 14: USB Advanced Features </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap14"></a> </p>
<h1><a class="anchor" id="ch14_1_usb_control_transfers"></a>
14.1. USB Control Transfers</h1>
<p >The USB standard supports two kinds of data exchange between the host and the device — control exchange and functional data exchange. The WinDriver APIs enable you to implement both control and functional data transfers.</p>
<p >The figure below demonstrates how a device's pipes are displayed in the DriverWizard utility, which enables you to perform transfers from a GUI environment.</p>
<p ><b>USB Data Exchange</b></p>
<div class="image">
<img src="wiz_usb_data_exchange.png" alt=""/>
</div>
 <h1><a class="anchor" id="ch14_2_usb_control_transfers_overview"></a>
14.2. USB Control Transfers Overview</h1>
<h2><a class="anchor" id="ch14_2_1_control_data_exchange"></a>
14.2.1. Control Data Exchange</h2>
<p >USB control exchange is used to determine device identification and configuration requirements, and to configure a device; it can also be used for other device-specific purposes, including control of other pipes on the device.</p>
<p >Control exchange takes place via a control pipe — the default pipe 0, which always exists. The control transfer consists of a setup stage (in which a setup packet is sent from the host to the device), an optional data stage and a status stage.</p>
<h2><a class="anchor" id="ch14_2_2_more_about_the_control_transfer"></a>
14.2.2. More About the Control Transfer</h2>
<p >The control transaction always begins with a setup stage. The setup stage is followed by zero or more control data transactions (data stage) that carry the specific information for the requested operation, and finally a status transaction completes the control transfer by returning the status to the host.</p>
<p >During the setup stage, an 8-byte setup packet is used to transmit information to the control endpoint of the device (endpoint 0). The setup packet's format is defined by the USB specification.</p>
<p >A control transfer can be a read transaction or a write transaction. In a read transaction the setup packet indicates the characteristics and amount of data to be read from the device. In a write transaction the setup packet contains the command sent (written) to the device and the number of control data bytes that will be sent to the device in the data stage.</p>
<p >Refer to the figure provided below (and taken from the USB specification) for a sequence of read and write transactions:</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;'(in)' indicates data flow from the device to the host. '(out)' indicates data flow from the host to the device. </p>
</blockquote>
</blockquote>
<p><b>USB Read and Write</b></p>
<div class="image">
<img src="usb_read_write.png" alt=""/>
</div>
 <h2><a class="anchor" id="ch14_2_3_the_setup_packet"></a>
14.2.3. The Setup Packet</h2>
<p >The setup packets (combined with the control data stage and the status stage) are used to configure and send commands to the device. USB requests such as these are sent from the host to the device, using setup packets. The USB device is required to respond properly to these requests. In addition, each vendor may define device-specific setup packets to perform device-specific operations. The standard setup packets (standard USB device requests) are detailed below. The vendor's device-specific setup packets are detailed in the vendor's data book for each USB device.</p>
<h2><a class="anchor" id="ch14_2_4_usb_setup_packet_format"></a>
14.2.4. USB Setup Packet Format</h2>
<p >The table below shows the format of the USB setup packet. For more information, please refer to the USB specification at <a href="http://www.usb.org">http://www.usb.org</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Byte   </th><th class="markdownTableHeadLeft">Field   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyLeft">bmRequest Type   </td><td class="markdownTableBodyLeft">Bit 7: Request direction (0=Host to device — Out, 1=Device to host— In).<br  />
Bits 5-6: Request type (0=standard, 1=class, 2=vendor, 3=reserved).<br  />
Bits 0-4: Recipient (0=device, 1=interface, 2=endpoint,3=other).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyLeft">bRequest   </td><td class="markdownTableBodyLeft">The actual request (see the Standard Device Request Codes table below)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyLeft">wValueL   </td><td class="markdownTableBodyLeft">A word-size value that varies according to the request.<br  />
For example,in the CLEAR_FEATURE request the value is used to select the feature.<br  />
In the GET_DESCRIPTOR request the value indicatesthe descriptor type and<br  />
in the SET_ADDRESS request the value contains the device address.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyLeft">wValueH   </td><td class="markdownTableBodyLeft">The upper byte of the Value word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4   </td><td class="markdownTableBodyLeft">wIndexL   </td><td class="markdownTableBodyLeft">A word-size value that varies according to the request.<br  />
The index is generally used to specify an endpoint or an interface.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">5   </td><td class="markdownTableBodyLeft">wIndexH   </td><td class="markdownTableBodyLeft">The upper byte of the Index word.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">6   </td><td class="markdownTableBodyLeft">wLengthL   </td><td class="markdownTableBodyLeft">A word-size value that indicates the number of bytes to be transferred if there is a data stage.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">7   </td><td class="markdownTableBodyLeft">wLengthH   </td><td class="markdownTableBodyLeft">The upper byte of the Length word.   </td></tr>
</table>
<h2><a class="anchor" id="ch14_2_5_standard_device_request_codes"></a>
14.2.5. Standard Device Request Codes</h2>
<p >The table below shows the standard device request codes.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">bRequest   </th><th class="markdownTableHeadCenter">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GET_STATUS   </td><td class="markdownTableBodyCenter">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">CLEAR_FEATURE   </td><td class="markdownTableBodyCenter">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Reserved for future use   </td><td class="markdownTableBodyCenter">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SET_FEATURE   </td><td class="markdownTableBodyCenter">3    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Reserved for future use   </td><td class="markdownTableBodyCenter">4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SET_ADDRESS   </td><td class="markdownTableBodyCenter">5    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GET_DESCRIPTOR   </td><td class="markdownTableBodyCenter">6    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SET_DESCRIPTOR   </td><td class="markdownTableBodyCenter">7    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GET_CONFIGURATION   </td><td class="markdownTableBodyCenter">8    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SET_CONFIGURATION   </td><td class="markdownTableBodyCenter">9    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">GET_INTERFACE   </td><td class="markdownTableBodyCenter">10    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SET_INTERFACE   </td><td class="markdownTableBodyCenter">11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SYNCH_FRAME   </td><td class="markdownTableBodyCenter">12   </td></tr>
</table>
<h2><a class="anchor" id="ch14_2_6_setup_packet_example"></a>
14.2.6. Setup Packet Example</h2>
<p >This example of a standard USB device request illustrates the setup packet format and its fields. The setup packet is in Hex format.</p>
<p >The following setup packet is for a control read transaction that retrieves the device descriptor from the USB device. The device descriptor includes information such as USB standard revision, vendor ID and product ID.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter" colspan="8">GET_DESCRIPTOR (Device) Setup Packet    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">80   </td><td class="markdownTableBodyCenter">06   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyCenter">01   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyCenter">12   </td><td class="markdownTableBodyCenter">00   </td></tr>
</table>
<p >Setup packet meaning:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Byte   </th><th class="markdownTableHeadLeft">Field   </th><th class="markdownTableHeadCenter">Value   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyLeft">bmRequest Type   </td><td class="markdownTableBodyCenter">80   </td><td class="markdownTableBodyLeft">8h=1000b<br  />
bit 7=1 -&gt; direction of data is from device to host.<br  />
0h=0000b<br  />
bits 0..1=00 -&gt; the recipient is the device.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyLeft">bRequest   </td><td class="markdownTableBodyCenter">06   </td><td class="markdownTableBodyLeft">The Request is GET_DESCRIPTOR.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyLeft">wValueL   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyLeft">wValueH   </td><td class="markdownTableBodyCenter">01   </td><td class="markdownTableBodyLeft">The descriptor type is device (values defined in USB spec).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4   </td><td class="markdownTableBodyLeft">wIndexL   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyLeft">The index is not relevant in this setup packet since there is only one device descriptor.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">5   </td><td class="markdownTableBodyLeft">wIndexH   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyLeft"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">6   </td><td class="markdownTableBodyLeft">wLengthL   </td><td class="markdownTableBodyCenter">12   </td><td class="markdownTableBodyLeft">Length of the data to be retrieved: 18(12h) bytes (this is the length of the device descriptor).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">7   </td><td class="markdownTableBodyLeft">wLengthH   </td><td class="markdownTableBodyCenter">00   </td><td class="markdownTableBodyLeft"></td></tr>
</table>
<p >In response, the device sends the device descriptor data. A device descriptor of the Cypress EZ-USB Integrated Circuit is provided as an example:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Byte No.   </th><th class="markdownTableHeadCenter">Content    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0   </td><td class="markdownTableBodyCenter">0x12    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1   </td><td class="markdownTableBodyCenter">0x01    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3   </td><td class="markdownTableBodyCenter">0x01    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4   </td><td class="markdownTableBodyCenter">0xff    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">5   </td><td class="markdownTableBodyCenter">0xff    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">6   </td><td class="markdownTableBodyCenter">0xff    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">7   </td><td class="markdownTableBodyCenter">0x40    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">8   </td><td class="markdownTableBodyCenter">0x47    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">9   </td><td class="markdownTableBodyCenter">0x05    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">0x80    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">11   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">12   </td><td class="markdownTableBodyCenter">0x01    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">13   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">14   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">15   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">16   </td><td class="markdownTableBodyCenter">0x00    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">17   </td><td class="markdownTableBodyCenter">0x01   </td></tr>
</table>
<p >As defined in the USB specification, byte 0 indicates the length of the descriptor, bytes 2-3 contain the USB specification release number, byte 7 is the maximum packet size for the control endpoint (endpoint 0), bytes 8-9 are the vendor ID, bytes 10-11 are the product ID, etc.</p>
<h1><a class="anchor" id="ch14_3_performing_control_transfers_with_windriver"></a>
14.3. Performing Control Transfers with WinDriver</h1>
<p >WinDriver allows you to easily send and receive control transfers on the control pipe (pipe0), while using DriverWizard to test your device. You can either use the API generated by DriverWizard for your hardware, or directly call the WinDriver <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> function from within your application.</p>
<h2><a class="anchor" id="ch14_3_1_control_transfers_with_driverwizard"></a>
14.3.1. Control Transfers with DriverWizard</h2>
<ul>
<li>Choose Pipe 0x0 and click the Read / Write button.</li>
<li>You can either enter a custom setup packet, or use a standard USB request.</li>
</ul>
<p >For a custom request: enter the required setup packet fields. For a write transaction that includes a data stage, enter the data in the Write to pipe data (Hex) field. Click Read From Pipe or Write To Pipe according to the required transaction.</p>
<p ><b>Custom Request</b></p>
<div class="image">
<img src="wiz_usb_rwpipe_ctr_custom_req.png" alt=""/>
</div>
 <p >For a standard USB request: select a USB request from the requests list, which includes requests such as GET_DESCRIPTOR CONFIGURATION, GET_DESCRIPTOR DEVICE, GET_STATUS DEVICE, etc. The description of the selected request will be displayed in the Request Description box on the right hand of the dialogue window.</p>
<p ><b>Request List</b></p>
<div class="image">
<img src="wiz_usb_rwpipe_ctr_req_list.png" alt=""/>
</div>
 <ul>
<li>The results of the transfer, such as the data that was read or a relevant error, are displayed in DriverWizard's Log window. Below you can see the contents of the Log window after a successful GET_DESCRIPTOR DEVICE request.</li>
</ul>
<p ><b>USB Request Log</b></p>
<div class="image">
<img src="wiz_usb_ctr_req_GetDescDev_log.png" alt=""/>
</div>
 <h2><a class="anchor" id="ch14_3_2_control_transfers_with_windriver_api"></a>
14.3.2. Control Transfers with WinDriver API</h2>
<p >To perform a read or write transaction on the control pipe, you can either use the API generated by DriverWizard for your hardware, or directly call the WinDriver [WDU_Transfer] (<a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee">WDU_Transfer</a>) function from within your application. Fill the setup packet in the BYTE SetupPacket[8] array and call these functions to send setup packets on the control pipe (pipe 0) and to retrieve control and status data from the device.</p>
<p >The following sample demonstrates how to fill the SetupPacket[8] variable with a GET_DESCRIPTOR setup packet: </p><div class="fragment"><div class="line">setupPacket[0] = 0x80;   <span class="comment">/* BmRequstType */</span></div>
<div class="line">setupPacket[1] = 0x6;    <span class="comment">/* bRequest [0x6 == GET_DESCRIPTOR] */</span></div>
<div class="line">setupPacket[2] = 0;      <span class="comment">/* wValue */</span></div>
<div class="line">setupPacket[3] = 0x1;    <span class="comment">/* wValue [Descriptor Type: 0x1 == DEVICE] */</span></div>
<div class="line">setupPacket[4] = 0;      <span class="comment">/* wIndex */</span></div>
<div class="line">setupPacket[5] = 0;      <span class="comment">/* wIndex */</span></div>
<div class="line">setupPacket[6] = 0x12;   <span class="comment">/* wLength [Size for the returned buffer] */</span></div>
<div class="line">setupPacket[7] = 0;      <span class="comment">/* wLength */</span></div>
</div><!-- fragment --><p> The following sample demonstrates how to send a setup packet to the control pipe (a GET instruction; the device will return the information requested in the pBuffer variable): </p><div class="fragment"><div class="line"><a class="code hl_function" href="wdu__lib_8h_a08590e9faa6866c6616eff76d06f2874.html#a08590e9faa6866c6616eff76d06f2874">WDU_TransferDefaultPipe</a>(hDev, <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, 0, pBuffer, dwSize, bytes_transferred, &amp;setupPacket[0], 10000);</div>
<div class="ttc" id="akpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00264">kpstdlib.h:264</a></div></div>
<div class="ttc" id="awdu__lib_8h_a08590e9faa6866c6616eff76d06f2874_html_a08590e9faa6866c6616eff76d06f2874"><div class="ttname"><a href="wdu__lib_8h_a08590e9faa6866c6616eff76d06f2874.html#a08590e9faa6866c6616eff76d06f2874">WDU_TransferDefaultPipe</a></div><div class="ttdeci">DWORD DLLCALLCONV WDU_TransferDefaultPipe(_In_ WDU_DEVICE_HANDLE hDevice, _In_ DWORD fRead, _In_ DWORD dwOptions, _In_ PVOID pBuffer, _In_ DWORD dwBufferSize, _Outptr_ PDWORD pdwBytesTransferred, _In_ PBYTE pSetupPacket, _In_ DWORD dwTimeout)</div></div>
</div><!-- fragment --><p> The following sample demonstrates how to send a setup packet to the control pipe (a SET instruction): </p><div class="fragment"><div class="line"><a class="code hl_function" href="wdu__lib_8h_a08590e9faa6866c6616eff76d06f2874.html#a08590e9faa6866c6616eff76d06f2874">WDU_TransferDefaultPipe</a>(hDev, <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, 0, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0, bytes_transferred, &amp;setupPacket[0], 10000);</div>
<div class="ttc" id="akpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00268">kpstdlib.h:268</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
</div><!-- fragment --><p> Refer for further information to <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a>.</p>
<h1><a class="anchor" id="ch14_4_functional_usb_data_transfers"></a>
14.4. Functional USB Data Transfers</h1>
<h2><a class="anchor" id="ch14_4_1_functional_usb_data_transfers_overview"></a>
14.4.1. Functional USB Data Transfers Overview</h2>
<p >Functional USB data exchange is used to move data to and from the device. There are three types of USB data transfers: Bulk, Interrupt and Isochronous. Functional USB data transfers can be implemented using two alternative methods: single-blocking transfers and streaming transfers, both supported by WinDriver, as explained in the following sections. The generated DriverWizard USB code and the generic <code>WinDriver/util/usb_diag.exe</code> utility (source code located under the <code>WinDriver/samples/c/usb_diag</code> directory) enable the user to select which type of transfer to perform.</p>
<h2><a class="anchor" id="ch14_4_2_single-blocking_transfers"></a>
14.4.2. Single-Blocking Transfers</h2>
<h3><a class="anchor" id="ch14_4_2_1_performing_single-blocking_transfers_with_windriver"></a>
14.4.2.1. Performing Single-Blocking Transfers with WinDriver</h3>
<p >WinDriver's <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> function, and the <a class="el" href="wdu__lib_8h_a4c1ed5302cc89aeb71a8d27ea458b484.html#a4c1ed5302cc89aeb71a8d27ea458b484">WDU_TransferBulk()</a>, <a class="el" href="wdu__lib_8h_a3659a73e2a215c0969345af7b2b2b70e.html#a3659a73e2a215c0969345af7b2b2b70e">WDU_TransferIsoch()</a>, <br  />
 and <a class="el" href="wdu__lib_8h_a2f002ad293373f995140048e12cce680.html#a2f002ad293373f995140048e12cce680">WDU_TransferInterrupt()</a> convenience functions enable you to easily impelment single-blocking USB data transfers. You can also perform single-blocking transfers using the DriverWizard utility (which uses the <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> function).</p>
<h2><a class="anchor" id="autotoc_md0"></a>
14.4.3.Streaming Data Transfers {#ch14_4_3.streaming_data_transfers}</h2>
<p >In the streaming USB data transfer scheme, data is continuously streamed between the host and the device, using internal buffers allocated by the host driver — "streams".</p>
<p >Stream transfers allow for a sequential data flow between the host and the device, and can be used to reduce single-blocking transfer overhead, which may occur as a result of multiple function calls and context switches between user and kernel modes. This is especially relevant for devices with small data buffers, which might, for example, overwrite data before the host is able to read it, due to a gap in the data flow between the host and device.</p>
<h3><a class="anchor" id="ch14_4_3_1_performing_streaming_with_windriver"></a>
14.4.3.1. Performing Streaming with WinDriver</h3>
<p >WinDriver's <a class="el" href="wdu__lib_8h_af5e21b285739598b53a3641daaeecae5.html#af5e21b285739598b53a3641daaeecae5" title="Opens a new data stream for the specified pipe.">WDU_StreamOpen()</a> / <a class="el" href="wdu__lib_8h_a7818d038f0116ef5f9bf9858a7207c27.html#a7818d038f0116ef5f9bf9858a7207c27" title="Closes an open stream.">WDU_StreamClose()</a> / <a class="el" href="wdu__lib_8h_ae0b6c7697e65668e540c304ddc304d7f.html#ae0b6c7697e65668e540c304ddc304d7f" title="Starts a stream, i.e starts transfers between the stream and the device.">WDU_StreamStart()</a> / <a class="el" href="wdu__lib_8h_ac39092d8902a4038f453916160ed2f61.html#ac39092d8902a4038f453916160ed2f61" title="Stops a stream, i.e stops transfers between the stream and the device.">WDU_StreamStop()</a> / <a class="el" href="wdu__lib_8h_a12704b043bb5a1f17d4ead97a2c0a071.html#a12704b043bb5a1f17d4ead97a2c0a071" title="Flushes a stream, i.e writes the entire contents of the stream&#39;s data buffer to the device (relevant ...">WDU_StreamFlush()</a> / <a class="el" href="wdu__lib_8h_ac1b39ca79f80977a23901378aa9109d9.html#ac1b39ca79f80977a23901378aa9109d9" title="Reads data from a read stream to the application.">WDU_StreamRead()</a> / <a class="el" href="wdu__lib_8h_a93c0836ce4b74854880af74712c294d3.html#a93c0836ce4b74854880af74712c294d3" title="Writes data from the application to a write stream.">WDU_StreamWrite()</a> / <a class="el" href="wdu__lib_8h_a797a185cc09e1f32b65ec30b892bafd8.html#a797a185cc09e1f32b65ec30b892bafd8" title="Returns a stream&#39;s current status.">WDU_StreamGetStatus()</a> functions enable you to impelment USB streaming data transfers.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;These functions are currently supported on Windows. </p>
</blockquote>
</blockquote>
<p>To begin performing stream transfers, call the <a class="el" href="wdu__lib_8h_af5e21b285739598b53a3641daaeecae5.html#af5e21b285739598b53a3641daaeecae5" title="Opens a new data stream for the specified pipe.">WDU_StreamOpen()</a> function. When this function is called, WinDriver creates a new stream object for the specified data pipe. You can open a stream for any pipe except for the control pipe (pipe 0). The stream's data transfer direction— read/write — is derived from the direction of its pipe.</p>
<p >WinDriver supports both blocking and non-blocking stream transfers. The open function's <code>fBlocking</code> parameter indicates which type of transfer to perform (see explanation below). Streams that perform blocking transfers will henceforth be referred to as "blocking streams", and streams that perform non-blocking transfers will be referred to as "non-blocking streams". The function's <code>dwRxTxTimeout</code> parameter indicates the desired timeout period for transfers between the stream and the device.</p>
<p >After opening a stream, call <a class="el" href="wdu__lib_8h_ae0b6c7697e65668e540c304ddc304d7f.html#ae0b6c7697e65668e540c304ddc304d7f" title="Starts a stream, i.e starts transfers between the stream and the device.">WDU_StreamStart()</a> to begin data transfers between the stream's data buffer and the device.</p>
<p >In the case of a read stream, the driver will constantly read data from the device into the stream's buffer, in blocks of a pre-defined size (as set in the <code>dwRxSize</code> parameter of the <a class="el" href="wdu__lib_8h_af5e21b285739598b53a3641daaeecae5.html#af5e21b285739598b53a3641daaeecae5" title="Opens a new data stream for the specified pipe.">WDU_StreamOpen()</a> function. In the case of a write stream, the driver will constantl ycheck for data in the stream's data buffer and write any data that is found to the device.</p>
<p >To read data from a read stream to the user-mode host application, call <a class="el" href="wdu__lib_8h_ac1b39ca79f80977a23901378aa9109d9.html#ac1b39ca79f80977a23901378aa9109d9" title="Reads data from a read stream to the application.">WDU_StreamRead()</a>.</p>
<p >In case of a blocking stream, the read function blocks until the entire amount of data requested by the application is transferred from the stream to the application, or until the stream's attempt to read data from the device times out. In the case of a non-blocking stream, the function transfers to the application as much of the requested data as possible, subject to the amount of data currently available in the stream's data buffer, and returns immediately.</p>
<p >To write data from the user-mode host application to a write the stream, call <a class="el" href="wdu__lib_8h_a93c0836ce4b74854880af74712c294d3.html#a93c0836ce4b74854880af74712c294d3" title="Writes data from the application to a write stream.">WDU_StreamWrite()</a>.</p>
<p >In case of a blocking stream, the function blocks until the entire data is written to the stream, or until the stream's attempt to write data to the device times out. In the case of a non-blocking stream, the function writes as much of the write data as currently possible to the stream, and returns immediately.</p>
<p >For both blocking and non-blocking transfers, the read/write function returns the amount of bytes actually transferred between the stream and the calling application within an output parameter —<code>pdwBytesRead</code>/<code>pdwBytesWritten</code>.</p>
<p >You can flush an active stream at any time by calling the <a class="el" href="wdu__lib_8h_a12704b043bb5a1f17d4ead97a2c0a071.html#a12704b043bb5a1f17d4ead97a2c0a071" title="Flushes a stream, i.e writes the entire contents of the stream&#39;s data buffer to the device (relevant ...">WDU_StreamFlush()</a> function, which writes the entire contents of the stream's data buffer to the device (for a write stream), and blocks until all pending I/O for the stream is handled. You can flush both blocking and non-blocking streams.</p>
<p >You can call <a class="el" href="wdu__lib_8h_a797a185cc09e1f32b65ec30b892bafd8.html#a797a185cc09e1f32b65ec30b892bafd8" title="Returns a stream&#39;s current status.">WDU_StreamGetStatus()</a> for any open stream in order to get the stream's current status information.</p>
<p >To stop the data streaming between an active stream and the device, call <a class="el" href="wdu__lib_8h_ac39092d8902a4038f453916160ed2f61.html#ac39092d8902a4038f453916160ed2f61" title="Stops a stream, i.e stops transfers between the stream and the device.">WDU_StreamStop()</a>. In the case of a write stream, the function flushes the stream — i.e., writes its contents to the device — before stopping it. An open stream can be stopped and restarted at any time until it is closed.</p>
<p >To close an open stream, call <a class="el" href="wdu__lib_8h_a7818d038f0116ef5f9bf9858a7207c27.html#a7818d038f0116ef5f9bf9858a7207c27" title="Closes an open stream.">WDU_StreamClose()</a>. The function stops the stream, including flushing its data to the device (in the case of a write stream), before closing it.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Each call to <a class="el" href="wdu__lib_8h_af5e21b285739598b53a3641daaeecae5.html#af5e21b285739598b53a3641daaeecae5" title="Opens a new data stream for the specified pipe.">WDU_StreamOpen()</a> must have a matching call to <a class="el" href="wdu__lib_8h_a7818d038f0116ef5f9bf9858a7207c27.html#a7818d038f0116ef5f9bf9858a7207c27" title="Closes an open stream.">WDU_StreamClose()</a> later on in the code in order to perform the necessary cleanup. </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch14_5_faq_usb_advanced_features"></a>
14.5. FAQ</h1>
<h2><a class="anchor" id="ch14_5_1_buffer_overrun_error_wdu_transfer_sometimes_returns_the_0xc000000c_error_code_what_does_this_error_code_mean_how_do_i_solve_this_problem"></a>
14.5.1. Buffer Overrun Error: WDU_Transfer() sometimes returns the 0xC000000C error code. What does this error code mean? How do I solve this problem?</h2>
<p >The 0xC000000C error code, is defined in <a class="el" href="windrvr_8h.html">windrvr.h</a> as <a class="el" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caee382e7328cf62df41262764bae19c2b">WD_USBD_STATUS_BUFFER_OVERRUN</a>.</p>
<p >The WD_USBD_XXX status codes returned by WinDriver (see <a class="el" href="windrvr_8h.html">windrvr.h</a>) comply with the URB status codes returned by the low-level USB stack driver (e.g., URB code 0XC000000CL — WD_USBD_STATUS_BUFFER_OVERRUN). You can refer to the Debug Monitor log to see the URB and IRP values returned from the stack drivers.</p>
<p >For Windows, the URB and IRP codes can be found in the Windows Driver Kit (WDK) under the <code>inc\</code> directory. The URB status codes can be found in the usbdi.h file or the usb.h file (depending on the OS). The IRP status codes can be found in the ntstatus.h file. For Linux, WinDriver translates the error codes returned from the stack driver into equivalent USBD errors.</p>
<p >For information regarding the specific error you received and when it might occur, review the operating system’s documentation.</p>
<p >The USBD_STATUS_BUFFER_OVERRUN error code (0xC000000C) is set by the USB stack drivers when the device transfers more data than requested by the host.</p>
<p >There are two possible solutions for this buffer overrun problem:</p><ul>
<li>Try setting the buffer sizes in the calls to <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> in your code to multiples of the maximum packet size. For example, if the maximum packet size is 64 bytes, use buffer sizes that are multiples of 64 (64 bytes, 128 bytes, etc.).</li>
<li>Define a protocol between the device and device driver, making sure that the device does not transfer more data than requested. When you have access to the device firmware code, this solution is recommended.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>💡 Recommendation</b></p>
<blockquote class="doxtable">
<p >&zwj;Recheck your firmware and the hardware specification to verify that you are implementing the communication with the device correctly. It is also recommended to use a USB bus analyzer to determine what is happening on the bus. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch14_5_2_how_do_i_extract_the_string_descriptors_contained_in_the_device_and_configuration_descriptor_tables"></a>
14.5.2. How do I extract the string descriptors contained in the Device and Configuration descriptor tables?</h2>
<p >You can use WinDriver’s <a class="el" href="wdu__lib_8h_a1e16d82cbf9dc504edd5cf36c1e94f52.html#a1e16d82cbf9dc504edd5cf36c1e94f52" title="Reads a string descriptor from a device by string index.">WDU_GetStringDesc()</a> function to get the desired string descriptors.</p>
<h2><a class="anchor" id="ch14_5_3_how_do_i_detect_that_a_usb_device_has_been_plugged_in_or_disconnected"></a>
14.5.3. How do I detect that a USB device has been plugged in or disconnected?</h2>
<p >Use <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> to register to listen for the notifications you are interested in.</p>
<h2><a class="anchor" id="ch14_5_4_how_do_i_setup_the_transfer_buffer_to_send_a_null_data_packet_through_the_control_pipe"></a>
14.5.4. How do I setup the transfer buffer to send a null data packet through the control pipe?</h2>
<p >You should set the pBuffer parameter of the <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> function to <code>NULL</code> and set the <code>dwBufferSize</code> parameter to 0.</p>
<h2><a class="anchor" id="ch14_5_5_can_i_write_a_driver_for_a_usb_hub_or_a_usb_host_controller_card_using_windriver"></a>
14.5.5. Can I write a driver for a USB hub or a USB Host Controller card using WinDriver?</h2>
<p >No. Windriver USB is designed for writing drivers for USB devices (USB client drivers). It cannot be used to write a USB hub or a USB Host Controller driver.</p>
<h2><a class="anchor" id="ch14_5_6_does_windriver_usb_support_isochronous_streaming_mode"></a>
14.5.6. Does WinDriver USB support isochronous streaming mode?</h2>
<p >Yes. WinDriver provides <a class="el" href="structWDU__STREAM.html">WDU_Stream</a> functions for peforming streaming USB data transfers on Windows. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
