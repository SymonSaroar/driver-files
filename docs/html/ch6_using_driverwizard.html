<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 6: Using DriverWizard"/>
<title>Jungo WinDriver: Chapter 6: Using DriverWizard</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch6_using_driverwizard.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 6: Using DriverWizard </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap06"></a>This chapter describes the WinDriver DriverWizard utility and its hardware diagnostics and driver code generation capabilities.</p>
<h1><a class="anchor" id="ch6_1_an_overview"></a>
6.1. An Overview</h1>
<p >DriverWizard (included in the WinDriver toolkit) is a graphical user interface (GUI) tool that is targeted at two major phases in the hardware and driver development:</p>
<p ><b>Hardware diagnostics</b></p>
<p >DriverWizard enables you to write and read hardware resources before writing a single line of code. After the hardware has been built, insert your device into the appropriate bus slot on your machine, view its resources and configuration — and verify the hardware's functionality.</p>
<p ><b>Code generation</b></p>
<p >Once you have verified that the device is operating to your satisfaction, use DriverWizard generate skeletal driver source code with functions to view and access your hardware's resources.</p>
<p >If you are developing a driver for a device that is based on an enhanced-support PCI chipset (PLX 6466, 9030, 9050, 9052, 9054, 9056, 9080 and 9656; Altera Qsys, Avalon-MM designs; Xilinx BMD, XDMA, QDMA designs), we recommend that you first read <a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">Chapter 9: Enhanced Support for Specific Chipsets</a> to understand your development options.</p>
<p >On Windows, DriverWizard can also be used to generate an INF file for your hardware.</p>
<p >The code generated by DriverWizard is composed of the following elements:</p>
<ul>
<li>Library functions for accessing each element of your device's resources (memory ranges, I/O ranges, registers and interrupts).</li>
<li>A diagnostics program in console mode with which you can diagnose your device. This application utilizes the special library functions described above. Use this diagnostics program as your skeletal device driver.</li>
<li>A project solution/makefile that you can use to automatically load all of the project information and files into your development environment.</li>
</ul>
<h1><a class="anchor" id="ch6_2_driverwizard_walkthrough"></a>
6.2. DriverWizard Walkthrough</h1>
<p >To use DriverWizard, follow these steps.</p>
<h2><a class="anchor" id="ch6_2_1_attach_your_hardware_to_the_computer"></a>
6.2.1. Attach your hardware to the computer</h2>
<p >Attach the card to the appropriate bus slot on your computer.</p>
<p >For a virtual PCI device, you have the option to use DriverWizard to generate code without having the actual device installed, by selecting the <code>PCI Virtual Device</code> DriverWizard option (see information in Step 2). When selecting this option, DriverWizard will generate code for your virtual PCI device.</p>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;Use the virtual PCI device option when you are unable to connect your PCI device to your development computer. This will generate code that is less customized for your device, but you will be able to later add the customizations for your device to the generated code manually. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch6_2_2_run_driverwizard_and_select_your_device"></a>
6.2.2. Run DriverWizard and select your device</h2>
<ul>
<li>Start DriverWizard — <code>&lt;path to WinDriver&gt;/wizard/wdwizard</code>. On Windows you can also run DriverWizard from the <b>Start</b> menu: <b>Start</b> | <b>Programs</b> | <b>WinDriver</b> | <b>DriverWizard</b>. On Windows and Linux you must run DriverWizard as administrator/root.</li>
<li>Click <b>New host driver project</b> to start a new project, or Open an existing project to open a saved session.</li>
</ul>
<p ><b>Create or Open a Driver Project</b></p>
<div class="image">
<img src="wiz_start.png" alt=""/>
</div>
 <ul>
<li>Select your Plug-and-Play card from the list of devices detected by DriverWizard.</li>
</ul>
<p ><b>Select Your Device</b></p>
<div class="image">
<img src="wiz_pci_select_device.png" alt=""/>
</div>
 <div class="image">
<img src="wiz_usb_select_device.png" alt=""/>
</div>
 <p >For non-Plug-and-Play cards, select ISA.</p>
<p >To generate code for a PCI device that is not currently attached to the computer, select PCI Virtual Device. When selecting the PCI Virtual Device option, DriverWizard allows you to define the device's resources. By specifying the I/O and/or memory ranges, you may further define run-time registers (the offsets are relative to BARs). In addition, the IRQ must be specified if you want to generate code that acknowledges interrupts via run-time registers.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;If a PCI device is attached physically to the development computer, The IRQ number and the size of the I/O and memory ranges are irrelevant, since these will be automatically detected by DriverWizard. Until WinDriver 14.40 - the maximum [WD_CARD_ITEMS] (<a class="el" href="structWD__CARD.html">WD_CARD</a>) that were available was 20, from WinDriver 14.50 onwards the maximum is 128. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch6_2_3_generate_and_install_an_inf_file_for_your_device_windows"></a>
6.2.3. Generate and install an INF file for your device (Windows)</h2>
<p ><b>If you don't need to generate and install an INF file (e.g., if you are using DriverWizard on a non-Windows OS), skip this step</b>.</p>
<p >On the supported Windows operating systems, the driver for Plug-and-Play devices is installed by installing an INF file for the device. DriverWizard enables you to generate an INF file that registers your device to work with WinDriver (i.e., with the <code>windrvr1511.sys</code> driver). The INF file generated by DriverWizard should later be distributed to your Windows customers, and installed on their PCs. The INF file that you generate in this step is also designed to enable DriverWizard to diagnose your device on Windows (for example, when no driver is installed for your PCI/USB device). Additional information concerning the need for an INF file is provided in <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_1_1_why_should_i_create_an_inf_file">17.1.1. Why Should I Create an INF File?</a>.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;On Windows 10 or higher you must disable digital signature enforcement or enter test mode in order to install unsigned INF files generated by the DriverWizard. See <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_3_4_temporary_disabling_digital_signature_enforcement_in_windows_10">17.3.4. Temporary disabling digital signature enforcement in Windows 10</a> . <b>Make sure that this was done prior to performing the following steps, otherwise they will not work</b>. </p>
</blockquote>
</blockquote>
<p >To generate and install the INF file with DriverWizard, do the following:</p><ul>
<li>In the Select Your Device screen (see Step 2), click the <b>Generate .INF file</b> button or click <b>Next</b>.</li>
<li>DriverWizard will display information detected for your device — Vendor ID, Device ID, Device Class, manufacturer name and device name — and allow you to modify this information.</li>
</ul>
<p ><b>DriverWizard INF File Information</b></p>
<div class="image">
<img src="wiz_pci_int_info.png" alt=""/>
</div>
 <div class="image">
<img src="wiz_usb_inf_info.png" alt=""/>
</div>
 <blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;For multiple-interface USB devices, you can select to generate an INF file either for the composite device or for a specific interface. When selecting to generate an INF file for a specific interface of a multi-interface USB device the INF information dialogue will indicate for which interface the INF file is generated. When selecting to generate an INF file for a composite device of a multi-interface USB device, the INF information dialogue provides you with the option to either generate an INF file for the root device itself, or generate an INF file for specific interfaces, which you can select from the dialogue. Selecting to generate an INF file for the root device will enable you to handle multiple active interfaces simultaneously. </p>
</blockquote>
</blockquote>
<ul>
<li>When you are done, click <b>Next</b> and choose the directory in which you wish to store the generated INF file.</li>
</ul>
<p >DriverWizard will then automatically generate the INF file for you. You can choose to automatically install the INF file by checking the <b>Automatically Install the INF file</b> option in the DriverWizard's INF generation dialogue. If the automatic INF file installation fails, DriverWizard will notify you and provide manual installation instructions (refer also the manual INF file installation instructions in <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_1_windows_inf_files">17.1. Windows INF Files</a>.</p>
<p >For further information on Preallocating DMA Buffers in Windows, <br  />
 please refer to <a class="el" href="ch11_improving_pci_performance.html#ch11_2_2_4_preallocating_contiguous_dma_buffers_on_windows">11.2.2.4. Preallocating Contiguous DMA Buffers on Windows</a>. <br  />
 Handling of PCI Message-Signaled Interrupts (MSI) and Extended Message- Signaled Interrupts (MSI-X) requires specific configuration in the device's INF file, <br  />
 as explained in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_7_1_windows_msi-msi-x_device_inf_files">10.1.7.1. Windows MSI/MSI-X Device INF Files</a>.</p>
<p >On Windows, if your hardware supports MSI or MSI-X, the Support Message Signaled Interrupts option in the DriverWizard's INF generation dialogue will be enabled and checked by default. When this option is checked, the generated DriverWizard INF file for your device will include support for MSI/ MSI-X handling. However, when this option is not checked, PCI interrupts will be handled using the legacy level-sensitive interrupts method, regardless of whether the hardware and OS support MSI/MSI-X.</p>
<ul>
<li>When the INF file installation completes, select and open your device from the list in the Select Your Device screen.</li>
</ul>
<h2><a class="anchor" id="ch6_2_4_uninstall_the_inf_file_of_your_device_windows"></a>
6.2.4. Uninstall the INF file of your device (Windows)</h2>
<p >On Windows, you can use DriverWizard to uninstall a previously installed device INF file. This will unregister the device from its current driver and delete the copy of the INF file in the Windows INF directory.</p>
<p >In order for WinDriver to correctly identify the resouces of a Plug-and-Play device and communicate with it — including for the purpose of the DriverWizard device diagnostics outlined in the next step — the device must be registered to work with WinDriver via an INF file.</p>
<p ><b>If you do not wish to uninstall an INF file, skip this step</b>.</p>
<p >To uninstall the INF file, do the following:</p>
<ul>
<li>In the Select Your Device screen (see Step 2), click the <b>Uninstall .INF file</b> button.</li>
<li>Select the INF file to be removed.</li>
</ul>
<h2><a class="anchor" id="ch6_2_5_select_the_desired_alternate_setting_usb"></a>
6.2.5. Select the desired alternate setting (USB)</h2>
<p ><b>Skip this step if your device is not a USB device</b></p>
<p >DriverWizard detects all the device's supported alternate settings and displays them. Select the desired alternate setting from the displayed list.</p>
<p ><b>Select Device Interface</b></p>
<div class="image">
<img src="wiz_usb_select_dev_ifc.png" alt=""/>
</div>
 <p >DriverWizard will display the pipes information for the selected alternate setting. For USB devices with only one alternate setting configured, DriverWizard automatically selects the detected alternate setting and therefore the Select Device Interface dialogue will not be displayed.</p>
<h2><a class="anchor" id="ch6_2_6_diagnose_your_device_pci"></a>
6.2.6. Diagnose your device (PCI)</h2>
<p ><b>Skip this step if your device is not a PCI device</b> Before writing your device driver, it is important to make sure your hardware is working as expected. Use DriverWizard to diagnose your hardware. All of your activity will be logged in the DriverWizard log so that you may later analyze your tests.</p>
<p >Define and test your device's I/O and memory ranges, registers and interrupts:</p>
<ul>
<li>DriverWizard will automatically detect your Plug-and-Play hardware resources: I/O ranges, memory ranges, and interrupts.</li>
</ul>
<p ><b>PCI Resources</b></p>
<div class="image">
<img src="wiz_pci_define_n_test_res.png" alt=""/>
</div>
 <p >For non-Plug-and-Play hardware, define your hardware's resources manually.</p>
<p >On Windows, you may need to register an IRQ with WinDriver before you can assign it to your non-Plug-and-Play hardware see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_3_registering_irqs_for_non-plug-and-play_hardware">10.1.3. Registering IRQs for Non-Plug-and-Play Hardware</a>.</p>
<p >You can also manually define hardware registers, as demonstrated below.</p>
<p ><b>Define Registers</b></p>
<div class="image">
<img src="wiz_pci_register_info.png" alt=""/>
</div>
 <p >When defining registers, you may check the <b>Auto Read</b> box in the <b>Register Information</b> window. Registers marked as <b>Auto Read</b> will automatically be read for any register read/write operation performed from DriverWizard. The read results will be displayed in the wizard's Log window.</p>
<ul>
<li>Read and write to the I/O ports, memory space and your defined registers, as demonstrated below.</li>
</ul>
<p ><b>Read/Write Memory and I/O</b></p>
<div class="image">
<img src="wiz_pci_rw_mem_io.png" alt=""/>
</div>
 <ul>
<li>'Listen' to your hardware's interrupts.</li>
</ul>
<p ><b>Listen to Interrupts</b></p>
<div class="image">
<img src="wiz_pci_listen_to_int.png" alt=""/>
</div>
 <p >For level-sensitive interrupts, such as legacy PCI interrupts, you must use DriverWizard to define the interrupt status register and assign the read/write command(s) for acknowledging (clearing) the interrupt, before attempting to listen to the interrupts with the wizard, otherwise the OS may hang!</p>
<p >Figure below demonstrates how to define an interrupt acknowledgment command for a defined INTCSR hardware register. Note, however, that interrupt acknowledgment information is hardware-specific.</p>
<p ><b>Define Transfer Commands for Level-Sensitive Interrupts</b></p>
<div class="image">
<img src="wiz_pci_int_ack_prepare.png" alt=""/>
</div>
 <h2><a class="anchor" id="ch6_2_7_diagnose_your_device_usb"></a>
6.2.7. Diagnose your device (USB)</h2>
<p ><b>Skip this step if your device is not a USB device</b> Before writing your device driver, it is important to make sure your hardware is working as expected. Use DriverWizard to diagnose your hardware. All of your activity will be logged inthe DriverWizard log so that you may later analyze your tests.</p>
<ul>
<li>Test your USB device's pipes DriverWizard shows the pipes detected for the selected alternate setting. To perform USB data transfers on the pipes, follow these steps:<ul>
<li>Select the desired pipe.</li>
<li>For a control pipe (a bidirectional pipe), click Read / Write. A new dialogue willappear, allowing you to select a standard USB request or define a custom request, as demonstrated below.</li>
</ul>
</li>
</ul>
<p ><b>USB Control Transfers</b></p>
<div class="image">
<img src="wiz_usb_rwpipe_ctr_custom_req.png" alt=""/>
</div>
 <p >When you select one of the available standard USB requests, the setup packet information for the selected request is automatically filled and the request description is displayed in the Request Description box. For a custom request, you are required to enter the setup packet information and write data (if exists) yourself. The size of the setup packet should be eight bytes and it should be defined using little endian byte ordering. The setup packet information should conform to the USB specification parameters (bmRequestType, bRequest, wValue, wIndex, wLength).</p>
<p >For an input pipe (moves data from device to host) click <b>Listen to Pipe</b>. To successfully accomplish this operation with devices other than HID, you need to first verify that the device sends data to the host. If no data is sent after listening for a short period of time, DriverWizard will notify you that the Transfer Failed.</p>
<p >To stop reading, click <b>Stop Listen to Pipe</b>.</p>
<p ><b>Listen to Pipe</b></p>
<div class="image">
<img src="wiz_usb_pipe_in.png" alt=""/>
</div>
 <p >For an output pipe (moves data from host to device), click <b>Write to Pipe</b>. A new dialogue box will appear asking you to enter the data to write. The DriverWizard log will contain the result of the operation.</p>
<p ><b>Write to Pipe</b></p>
<div class="image">
<img src="wiz_usb_pipe_out_write.png" alt=""/>
</div>
 <p >You can reset input and output pipes by pressing the <b>Reset Pipe</b> button for the selected pipe.</p>
<h2><a class="anchor" id="ch6_2_8_import_register_information_from_csv_file"></a>
6.2.8. Import Register Information from CSV file</h2>
<p >DriverWizard allows users to import register information from a Comma Separted Values(CSV) file instead of having to type it manually for each register. This register information is used later in order to automatically generate code.</p>
<p >Use a text or spreadsheet editor to create a CSV in the following format:</p>
<ul>
<li>The first line must be: Name,Resource Name,Offset,Access Mode,Size</li>
<li>The next lines must include the following values formatted the following way (the following line is an example of one register): MY_REGISTER,BAR2,200,0,32<ul>
<li>Name: The register's desired name.</li>
<li>Resource Name: The name of the resource as it appears in DriverWizard.</li>
<li>Offset: The register's offset in the resource.</li>
<li>Access Mode: Allowed values are: 0 = Read/Write, 1 = Read, 2 = Write</li>
<li>Size: Size of register.</li>
</ul>
</li>
<li>Choose any resource from the DriverWizard side tab (a BAR, etc...)</li>
<li>Click the "Import registers" on the top left tab, browse and choose your .csv file. Registers should be added to the DriverWizard resource tabs. If the input file was faulty, DriverWizard will alert and still try to add as much registers it was able to.</li>
</ul>
<h2><a class="anchor" id="ch6_2_9_samples_and_automatic_code_generation"></a>
6.2.9. Samples And Automatic Code Generation</h2>
<p >After you have finished diagnosing your device and have ensured that it runs according to your specifications, you are ready to write your driver.</p>
<h3><a class="anchor" id="ch6_2_9_1_samples_or_code_generation"></a>
6.2.9.1. Samples Or Code Generation</h3>
<p >You can generate code by selecting this option either via DriverWizard's Generate Code toolbar icon or from the Wizard's <b>Project</b> | <b>Generate Code</b> menu. After you select a code generation option of your choice, DriverWizard will generate the source code for your driver, and save it together with the Wizard driver-project file (<code>xxx.wdp</code>, where "xxx" is the project name). The files are saved in a directory DriverWizard creates for every development environment and operating system selected in the code generation dialogue.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Close DriverWizard to avoid device overlap errors. </p>
</blockquote>
</blockquote>
<p>Use this code as a starting point for your device driver. Modify where needed to perform your driver's specific functionality.</p>
<p >If you choose to generate code either via the <b>Generate Code</b> toolbar icon or from the <b>Generate Code</b> menu, in the <b>Select Code Generation Options</b> dialogue box that will appear, you may optionally select to generate additional customized code for one of the supported devices. Then you choose the code language and development environment(s) for the generated code and select <b>Next</b> to generate the code.</p>
<p ><b>PCI Code Generation Options</b></p>
<div class="image">
<img src="wiz_pci_gen_code.png" alt=""/>
</div>
 <p >Then click <b>Next</b> and select whether to handle Plug-and-Play and power management events from within your driver code, whether to generate Kernel PlugIn code (see <a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a>) (and what type of related application to create), and whether to build your project's library as a DLL (for MS Visual Studio Windows projects).</p>
<p ><b>PCI Additional Driver Options</b></p>
<div class="image">
<img src="wiz_pci_driver_options.png" alt=""/>
</div>
 <p >Kernel PlugIn Windows Project Notes:</p>
<ul>
<li>To compile the generated Kernel PlugIn code, the Windows Driver Kit (WDK) must be installed.</li>
<li>To successfully build a Kernel PlugIn project using MS Visual Studio, the path to the project directory must not contain any spaces.</li>
<li>Save your project (if required) and click OK to open your development environment with the generated driver.</li>
<li>Close DriverWizard to avoid device overlap errors.</li>
</ul>
<p >After you choose the code, you can compile and run it:</p>
<ul>
<li>Use this code as a starting point for your device driver. Modify where needed to perform your driver's specific functionality.</li>
<li>The source code DriverWizard creates can be compiled with a variety of compilers, and will run on all supported platforms without modification.</li>
</ul>
<p >In addition, WinDriver includes a variety of samples that demonstrate how to use WinDriver's API to communicate with your device and perform various driver tasks:</p>
<ul>
<li>C samples: found under the <code>WinDriver/samples/c</code> directory.</li>
<li>Python samples: found under the <code>WinDriver/samples/python</code> directory.</li>
<li>Java samples: found under the <code>WinDriver/samples/java</code> directory.</li>
<li>C#.NET samples: found under the <code>WinDriver/samples/csharp.net</code> directory.</li>
<li>Visual Basic.NET samples (Windows): found under the <code>WinDriver/samples/vb.net</code> directory.</li>
<li>.NET PowerShell samples: found under the <code>WinDriver/samples/powershell</code> directory.</li>
</ul>
<h3><a class="anchor" id="ch6_2_9_2_the_generated_pci-isa_and_usb_c_code"></a>
6.2.9.2. The Generated PCI/ISA and USB C Code</h3>
<p >In the source code directory you now have a new xxx_lib.h file, which contains type definitions and functions declarations for the API created for you by the DriverWizard, and an xxx_lib.c source file, which contains the implementation of the generated device-specific API.</p>
<p >In addition, you will find an <code>xxx_diag.c</code> source file, which includes a main() function and implements a sample diagnostics application that utilizes the generated DriverWizard API to communicate with your device.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;For USB you will only have a <code>xxx_diag.c</code> source file. This file implements a diagnostic USB application, which demonstrates how to use WinDriver's USB API to locate and communicate with your USB device(s), including detection of Plug-and-Play events (device insertion/removal, etc.),performing read/write transfers on the pipes, resetting the pipes and changing the device's active alternate setting. The generated application supports handling of multiple identical USB devices. </p>
</blockquote>
</blockquote>
<p>The code generated by DriverWizard is composed of the following elements and files, where xxx represents your DriverWizard project name:</p>
<ul>
<li>Library functions for accessing each element of your card's resources (memory ranges and I/O, registers and interrupts):<ul>
<li><code>xxx_lib.c</code> — the implementation of the hardware-specific API (declared in <code>xxx_lib.h</code>), using the WinDriver Card (WDC) API .</li>
<li><code>xxx_lib.h</code> — a header file that contains type definitions and function declarations for the API implemented in the xxx_lib.c source file.</li>
</ul>
</li>
</ul>
<p >You should include this file in your source code to use the API generated by DriverWizard for your device.</p>
<ul>
<li>A diagnostics program that utilizes the generated DriverWizard API (declared in <code>xxx_lib.h</code>) to communicate with your device(s):<ul>
<li><code>xxx_diag.c</code> The source code of the generated diagnostics console application. Use this diagnostics program as your skeletal device driver.</li>
<li>A list of all files created can be found at <code>xxx_files.txt</code>.</li>
</ul>
</li>
</ul>
<p >After creating your code, compile it with your favorite compiler, and see it work!</p>
<p >Change the function main() of the program so that the functionality suits your needs.</p>
<h3><a class="anchor" id="ch6_2_9_3_the_generated_pci-isa_python_code"></a>
6.2.9.3. The Generated PCI/ISA Python Code</h3>
<p >After generating Python code in the DriverWizard, in the source code directory you now have a new xxx_lib.py file, which contains type definitions and function implementations for the API created for you by the DriverWizard. In addition, you will find an <code>xxx_diag.py</code> source file, which includes a <code>main()</code> function and implements a sample diagnostics application that utilizes the generated DriverWizard API to communicate with your device.</p>
<p >The wdlib subdirectory includes shared Python code files that implement the WinDriver API structs, import the WinDriver user API DLL file, define variables, and implement user I/O functions required for the user application to run. The code generated by DriverWizard is composed of the following elements and files, where xxx represents your DriverWizard project name:</p>
<ul>
<li>Library functions for accessing each element of your card's resources (memory ranges and I/O, registers and interrupts): <code>xxx_lib.py</code> — type definitions and the implementation of the hardware-specific API, using the WinDriver Card (WDC) API.</li>
<li>A diagnostics program that utilizes the generated DriverWizard API (declared in <code>xxx_lib.py</code>) to communicate with your device(s): <code>xxx_diag.py</code> - the source code of the generated diagnostics console application. Use this diagnostics program as your skeletal device driver.</li>
<li>A list of all files created can be found at <code>xxx_files.txt</code>.</li>
</ul>
<p >After creating your code, run it with your favorite Python interpreter. Change the function <code>main()</code> of the program so that the functionality suits your needs.</p>
<h3><a class="anchor" id="ch6_2_9_4_the_generated_usb_python_code"></a>
6.2.9.4. The Generated USB Python Code</h3>
<p >After generating Python code in the DriverWizard, in the source code directory you now have a new <code>xxx_diag.py</code> source file (where <code>xxx</code> is the name you selected for your DriverWizard project). This file implements a diagnostic USB application, which demonstrates how to use WinDriver’s USB API to locate and communicate with your USB device(s), including detection of Plug-and-Play events (device insertion/removal, etc.), performing read/write transfers on the pipes, resetting the pipes and changing the device’s active alternate setting. The generated application supports handling of multiple identical USB devices.</p>
<p >The wdlib subdirectory includes shared Python code files that implement the WinDriver API structs, import the WinDriver user API DLL file, define variables, and implement user I/O functions required for the user application to run.</p>
<h3><a class="anchor" id="ch6_2_9_5_the_generated_pci-isa_java_code"></a>
6.2.9.5. The Generated PCI/ISA Java Code</h3>
<p >After generating Java code in the DriverWizard, in the source code directory you now have a new xxxLib.java file, which contains type definitions and function implementations for the API created for you by the DriverWizard. In addition, you will find an xxxDiag.java source file, which includes a <code>main()</code> function and implements a sample diagnostics application that utilizes the generated DriverWizard API to communicate with your device.</p>
<p >The <code>com\jungo\shared</code> subdirectory and the <code>xxx_installation\redist\wdapi_java1511.jar</code> includes shared Java code files that implement the WinDriver API structs, import the WinDriver user API DLL file, define variables, and implement user I/O functions required for the user application to run.</p>
<p >A very important file is the Java Native Interface (JNI) file <code>wdapi_java1511.dll</code> that provides the interface between the Java layer and your native <code>wdapi1511.dll</code> file provided with WinDriver. Make sure that the JNI file corresponds with the architecture and bits of the Java Virtual Machine (JVM) you'll be using to run the application.</p>
<p >The code generated by DriverWizard is composed of the following elements and files, where xxx represents your DriverWizard project name:</p>
<ul>
<li>Library functions for accessing each element of your card's resources (memory ranges and I/O, registers and interrupts): <code>xxxLib.java</code> — type definitions and the implementation of the hardware-specific API, using the WinDriver Card (WDC) API.</li>
<li>A diagnostics program that utilizes the generated DriverWizard API (declared in xxxLib.java) to communicate with your device(s): <code>xxxDiag.java</code> - the source code of the generated diagnostics console application. Use this diagnostics program as your skeletal device driver.</li>
<li>A list of all files created can be found at <code>xxx_files.txt</code>.</li>
</ul>
<p >After creating your code, you can either compile and run it from the command line as described below or open it with the Eclipse IDE. Change the function <code>main()</code> of the program so that the functionality suits your needs.</p>
<h3><a class="anchor" id="ch6_2_9_6_the_generated_usb_java_code"></a>
6.2.9.6. The Generated USB Java Code</h3>
<p >After generating Java code in the DriverWizard, in the source code directory you now have a new xxxDiag.java source file (where xxx is the name you selected for your DriverWizard project). This file implements a diagnostic USB application, which demonstrates how to use WinDriver’s USB API to locate and communicate with your USB device(s), including detection of Plug-and-Play events (device insertion/removal, etc.), performing read/write transfers on the pipes, resetting the pipes and changing the device’s active alternate setting. The generated application supports handling of multiple identical USB devices.</p>
<p >The <code>com\jungo\shared</code> subdirectory and the <code>xxx_installation\redist\wdapi_java1511.jar</code> includes shared Java code files that implement the WinDriver API structs, import the WinDriver user API DLL file, define variables, and implement user I/O functions required for the user application to run.</p>
<p >A very important file is the Java Native Interface (JNI) file <code>wdapi_java1511.dll</code> that provides the interface between the Java layer and your native <code>wdapi1511.dll</code> provided with WinDriver. Make sure that the JNI file corresponds with the architecture and bits of the Java Virtual Machine (JVM) you’ll be using to run the application.</p>
<p >After creating your code, you can either compile and run it from the command line as described below, or open it with the Eclipse IDE.</p>
<h3><a class="anchor" id="ch6_2_9_7_the_generated_pci-isa_and_usb_net_code"></a>
6.2.9.7. The Generated PCI/ISA and USB .NET Code</h3>
<p >You can use WinDriver’s DriverWizard utility to generate C# (USB and PCI) and Visual Basic.NET (USB only). To develop a C# driver with WinDriver, either use DriverWizard to generate a driver application for your device, or use the WinDriver .NET samples, which utilize the WinDriver .NET API DLL, that most matches your design, and then modify the generated/sample code in accordance with your hardware specification and desired driver functionality. Alternatively, you can use the generated/sample code as a reference for writing your own WinDriver C# driver:</p>
<p >PCI:</p><ul>
<li>The <code>WinDriver\samples\csharp.net\pci_sample</code> directory contains a .NET PCI library (<code>pci_lib.dll</code>) and a sample GUI-based PCI diagnostics application (<code>pci_sample.exe</code>), both implemented in C#. This sample is based on the Windows Forms framework, only supported natively on Windows.</li>
<li>The <code>WinDriver\samples\c\plx\dotnet</code> directory contains a C# library (<code>plx_lib_dotnet.dll</code>) and sample diagnostics application (<code>PLX_Sample.exe</code>), designed specifically for handling PLX devices. This sample is based on the Windows Forms framework, only supported natively on Windows.</li>
<li>The <code>WinDriver\samples\csharp\pci_diag</code> directory contains a .NET PCI Console sample similar to the console <code>pci_diag</code> sample Jungo provides in other languages. This sample is supported on Windows, Linux and MacOS.</li>
</ul>
<p >USB:</p><ul>
<li>The <code>WinDriver\samples\csharp.net\usb_sample</code> directory contains a .NET USB library (<code>usb_lib_dotnet.dll</code>) and a sample USB diagnostics application (<code>csharp_usb_sample.exe</code>), both implemented in C#.</li>
<li>The <code>WinDriver\samples\vb.net\usb_sample</code> directory contains a sample .NET USB diagnostics application (<code>vb_usb_sample.exe</code>), implemented in VB.NET. This sample is similar to the sample C# USB diagnostics application and also uses the sample C# USB library (<code>usb_lib_dotnet.dll</code>).</li>
</ul>
<p >If using the DriverWizard in the source code directory you now have a new lib subdirectory, which contains type definitions and function implementations for the API created for you by the DriverWizard. This subdirectory outputs a DLL file that is compiled by the <code>xxx_diag</code> project. In addition, you will find a diag subdirectory, a sample diagnostics application that utilizes the generated DriverWizard API to communicate with your device. The <code>xxx_diag.cs</code> file that includes a <code>Main()</code> function. A list of all files created can be found at <code>xxx_files.txt</code>.</p>
<p >After creating your code, compile it with your favorite C# compiler. Change the function <code>Main()</code> of the program so that the functionality suits your needs.</p>
<h1><a class="anchor" id="ch6_3_compiling_the_generated_code"></a>
6.3. Compiling the Generated Code</h1>
<h2><a class="anchor" id="ch6_3_1_c-c-sharp-vb_windows_compilation"></a>
6.3.1. C/C#/VB Windows Compilation</h2>
<p >As explained above, on Windows you can select to generate project, solution, and make files for the supported compilers and development environments — MS Visual Studio, Windows GCC(MinGW/Cygwin). For integrated development environments (IDEs), such as MS Visual Studio, you can also select to automatically invoke your selected IDE from the wizard. You can then proceed to immediately build and run the code from your selected IDE.</p>
<p >You can also build the generated code using any other compiler or development environment that supports the selected code language and target OS. Simply create a new project or make file for your selected compiler/environment, include the generated source files, and run the code. For Windows, the generated compiler/environment files are located under an x86 directory — for 32-bit projects — or an amd64 directory — for 64-bit projects. To build a Kernel PlugIn project (on Windows), follow the instructions in <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_8_1_windows_kernel_plugin_driver_compilation">13.8.1. Windows Kernel PlugIn Driver Compilation</a>.</p>
<h3><a class="anchor" id="ch6_3_1_1_c_compilation_with_a_linux_makefile"></a>
6.3.1.1. C Compilation with a Linux Makefile</h3>
<p >Use the makefile that was created for you by DriverWizard in order to build the generated code using your favorite compiler, preferably GCC. To build a Kernel PlugIn project, follow the instructions in <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_8_2_linux_kernel_plugin_driver_compilation">13.8.2. Linux Kernel PlugIn Driver Compilation</a>.</p>
<h3><a class="anchor" id="ch6_3_1_2_c_compilation_with_cmake"></a>
6.3.1.2. C Compilation with CMake</h3>
<p >The recommended way is using CMake, which simplifies compilation and portability between IDEs and platforms.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;MacOS Code generation with WinDriver works only with CMake. </p>
</blockquote>
</blockquote>
<p>Open a terminal window: </p><div class="fragment"><div class="line"># Go to directory of the generated code</div>
<div class="line">$ cd &lt;GENERATED_CODE_DIRECTORY&gt;</div>
<div class="line"># Prepare makefile</div>
<div class="line">$ cmake .</div>
<div class="line"># Compile</div>
<div class="line">$ make</div>
</div><!-- fragment --><h3><a class="anchor" id="ch6_3_1_2_1_generating_a_windriver_c_project_for_xcode_macos"></a>
6.3.1.2.1 Generating a WinDriver C project for Xcode (MacOS)</h3>
<p >On MacOS, to create an XCode project instead of a make project, run CMake in the following manner:</p>
<div class="fragment"><div class="line">$ cmake . -G Xcode .</div>
</div><!-- fragment --><h3><a class="anchor" id="ch6_3_1_2_2_generating_a_windriver_c_project_for_mingw_windows"></a>
6.3.1.2.2 Generating a WinDriver C project for MinGW (Windows)</h3>
<p >Although compiling on Windows is preferable with Visual Studio, your project can also be compiled using MinGW.</p>
<p >Compile the <code>wdapi</code> shared library:</p>
<div class="fragment"><div class="line">$ cd WinDriver1511\src\wdapi</div>
<div class="line">$ mkdir build</div>
<div class="line">$ cd build</div>
<div class="line">$ cmake .. -G &quot;MinGW Makefiles&quot; -DCMAKE_C_COMPILER=&quot;gcc&quot; -DCMAKE_MAKE_PROGRAM=&quot;mingw32-make&quot;</div>
<div class="line">$ mingw32-make</div>
</div><!-- fragment --><p >Copy the library to the <code>bin</code> directory of your MinGW installation folder (i.e <code>C:\msys64\mingw64\bin</code>):</p>
<div class="fragment"><div class="line">$ cp WIN32/libwdapi1511* C:\msys64\mingw64\bin</div>
</div><!-- fragment --><p >In <code>PATH_TO_YOUR_PROJECT/CMakeLists.txt</code>, change the line <code>target_link_libraries(your_project ${WDAPI_LIB})</code> to:</p>
<div class="fragment"><div class="line">find_library(WDAPI libwdapi1511.dll.a)</div>
<div class="line">target_link_libraries(xxx_diag ${WDAPI})</div>
</div><!-- fragment --><p >Compile your user application:</p>
<div class="fragment"><div class="line">$ cmake .. -G &quot;MinGW Makefiles&quot; -DCMAKE_C_COMPILER=&quot;gcc&quot; -DCMAKE_MAKE_PROGRAM=&quot;mingw32-make&quot;</div>
<div class="line">$ mingw32-make</div>
</div><!-- fragment --><p >the program should compile and be able to run now.</p>
<h2><a class="anchor" id="ch6_3_2_java_compilation"></a>
6.3.2. Java Compilation</h2>
<h3><a class="anchor" id="ch6_3_2_1_opening_the_driverwizard_generated_java_code_with_eclipse_ide"></a>
6.3.2.1. Opening the DriverWizard generated Java code with Eclipse IDE</h3>
<p >Please follow these steps:</p>
<ul>
<li>Make sure you have a Java Development Kit (JDK) and the Eclipse IDE installed and set up for Java Development. Under Linux make sure to run Eclipse as sudo.</li>
<li>Go to <b>File</b> | <b>New</b> | Java Project.</li>
<li>Uncheck “Use default location”.</li>
<li>Click on “Browse” and select the directory of the generated code. For example <code>WinDriver\my_projects\xxx</code>.</li>
<li>Click on “Next”.</li>
<li>Click on “Finish“. You will now be able to compile, run and edit your code.</li>
</ul>
<h3><a class="anchor" id="ch6_3_2_2_compiling_and_running_the_driverwizard_generated_java_code_from_the_command_line"></a>
6.3.2.2. Compiling and running the DriverWizard generated Java code from the command line</h3>
<p >Please follow the next steps:</p>
<ul>
<li>Make sure you have a Java Development Kit (JDK) installed.</li>
<li>Make sure your $PATH environment variable contains the path to the JDK’s bin subdirectory (for example <code>C:\Program Files \Java\jdkX.X.X_XXX\bin</code>, replace the Xs with your JDK version).</li>
</ul>
<p >In Windows: </p><div class="fragment"><div class="line"># set PATH=%PATH%;&quot;C:\Program Files\Java\jdkX.X.X_XXX\bin\&quot;</div>
</div><!-- fragment --><p ><b>Compile the generated code:</b></p>
<p >In Windows: </p><div class="fragment"><div class="line"># javac -cp &quot;.;xxx_installation/redist/wdapi_java1511.jar&quot; xxxDiag.java </div>
</div><!-- fragment --><p >In Linux/MacOS: </p><div class="fragment"><div class="line"># sudo javac -cp .:xxx_installation/lib/wdapi_java1511.jar xxxDiag.java</div>
</div><!-- fragment --><p ><b>Run the generated code:</b></p>
<p >In Windows: </p><div class="fragment"><div class="line"># java -cp &quot;.;xxx_installation/redist /wdapi_java1511.jar&quot; -Djava.library.path=xxx_installation/redist/ xxxDiag.java </div>
</div><!-- fragment --><p >In Linux/MacOS: </p><div class="fragment"><div class="line"># sudo java -Djava.library.path=xxx_installation/lib/ -cp .:xxx_installation/lib/wdapi_java1511.jar xxxDiag</div>
</div><!-- fragment --><h1><a class="anchor" id="ch6_4_faq_using_driver_wizard"></a>
6.4. FAQ</h1>
<h2><a class="anchor" id="ch6_4_1_if_a_variable_requires_a_pointer_to_be_assigned_to_it_as_in_pbuffer_dwval_how_do_i_do_it_in_c-sharp_dotnet-java-python"></a>
6.4.1. If a variable requires a pointer to be assigned to it, as in pBuffer = &amp;dwVal, how do I do it in C# dotNET/Java/Python?</h2>
<p >The main difference between C#/Java/Python and C is that the former languages have a garbage collector which automatically manages the memory, whereas C is totally "manual" - meaning that it is the user's responsibility to allocate and free memory from the heap (using <a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a> and <a class="el" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free()</a>). Some WinDriver APIs that are written in C require usage of unmanaged memory.</p>
<p >For each "managed" langauge that WinDriver supports, WinDriver provides a sample of this kind of use:</p>
<ul>
<li>C#.NET: <code>WinDriver/samples/csharp.net/pci_sample/lib/dma.cs</code> (Using the <code>System.Runtime.InteropServices.Marshal</code> class)</li>
<li>Python: <code>WinDriver/samples/python/pci_diag.py</code> (Using global variables and the <code>ctypes</code> class)</li>
<li>Java: <code>WinDriver/samples/java/com/jungo/PciDiag.Java</code> (Using the <code>java.nio.ByteBuffer</code> class). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
