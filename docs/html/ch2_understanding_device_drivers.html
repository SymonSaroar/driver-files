<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 2: Understanding Device Drivers"/>
<title>Jungo WinDriver: Chapter 2: Understanding Device Drivers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch2_understanding_device_drivers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 2: Understanding Device Drivers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap02"></a>This chapter provides you with a general introduction to device drivers and takes you through the structural elements of a device driver.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;When using WinDriver you do not need to familiarize yourself with the internal workings of driver development. As explained in <a class="el" href="ch1_overview.html#ch1_1_introduction">1.1. Introduction</a>, WinDriver enables you to communicate with your hardware and develop a driver for your device from the user mode, using only WinDriver's simple APIs, without any need for driver or kernel development knowledge. </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch2_1_device_driver_overview"></a>
2.1. Device Driver Overview</h1>
<p >Device drivers are the software segments that provide an interface between the operating system and the specific hardware devices — such as terminals, disks, tape drives, video cards,and network media. The device driver brings the device into and out of service, sets hardware parameters in the device, transmits data from the kernel to the device, receives data from the device and passes it back to the kernel, and handles device errors.</p>
<p >A driver acts like a translator between the device and programs that use the device. Each device has its own set of specialized commands that only its driver knows. In contrast, most programs access devices by using generic commands. The driver, therefore, accepts generic commands from a program and then translates them into specialized commands for the device.</p>
<h1><a class="anchor" id="ch2_2_classification_of_drivers_according_to_functionality"></a>
2.2. Classification of Drivers According to Functionality</h1>
<p >There are numerous driver types, differing in their functionality. This subsection briefly describes three of the most common driver types.</p>
<h2><a class="anchor" id="ch2_2_1_monolithic_drivers"></a>
2.2.1. Monolithic Drivers</h2>
<p >Monolithic drivers are device drivers that embody all the functionality needed to support a hardware device. A monolithic driver is accessed by one or more user applications, and directly drives a hardware device. The driver communicates with the application through I/O control commands (IOCTLs) and drives the hardware using calls to the different WDK, ETK, DDI/DKI functions.</p>
<div class="image">
<img src="Monolithic.png" alt=""/>
</div>
 <p >Monolithic drivers are supported in all operating systems including all Windows platforms and all Unix platforms.</p>
<h2><a class="anchor" id="ch2_2_2_layered_drivers"></a>
2.2.2. Layered Drivers</h2>
<p >Layered drivers are device drivers that are part of a stack of device drivers that together process an I/O request. An example of a layered driver is a driver that intercepts calls to the disk and encrypts/decrypts all data being transferred to/from the disk. In this example, a driver would be hooked on to the top of the existing driver and would only do the encryption/decryption.</p>
<p >Layered drivers are sometimes also known as filter drivers, and are supported in all operating systems including all Windows platforms and all Unix platforms.</p>
<div class="image">
<img src="Layered.png" alt=""/>
</div>
 <h2><a class="anchor" id="ch2_2_3_miniport_drivers"></a>
2.2.3. Miniport Drivers</h2>
<p >Miniport driver is an add-on to a class driver that supports miniport drivers. It is used so the miniport driver does not have to implement all of the functions required of a driver for that class. The class driver provides the basic class functionality for the miniport driver. A class driver is a driver that supports a group of devices of common functionality, such as all HID devices or all network devices.</p>
<p >Miniport drivers are also called miniclass drivers or minidrivers, and are supported in the Windows 7 and higher operating systems.</p>
<div class="image">
<img src="Miniport.png" alt=""/>
</div>
 <p >Windows 7 and higher operating systems provide several driver classes (called ports) that handle the common functionality of their class. It is then up to the user to add only the functionality that has to do with the inner workings of the specific hardware. The NDIS miniport driver is one example of such a driver. The NDIS miniport framework is used to create network drivers that hook up to Windows's communication stacks, and are therefore accessible to common communication calls used by applications. The Windows kernel provides drivers for the various communication stacks and other code that is common to communication cards. Due to the NDIS framework, the network card developer does not have to write all of this code, only the code that is specific to the network card he is developing.</p>
<h1><a class="anchor" id="ch2_3_classification_of_drivers_according_to_operating_systems"></a>
2.3. Classification of Drivers According to Operating Systems</h1>
<h2><a class="anchor" id="ch2_3_1_wdm_drivers"></a>
2.3.1. WDM Drivers</h2>
<p >Windows Driver Model (WDM) drivers are kernel-mode drivers within the Windows operating systems. WDM works by channeling some of the work of the device driver into portions of the code that are integrated into the operating system. These portions of code handle all of the low-level buffer management, including DMA and Plug-and-Play (Pnp) device enumeration. WDM drivers are PnP drivers that support power management protocols, and include monolithic drivers, layered drivers and miniport drivers.</p>
<h2><a class="anchor" id="ch2_3_2_wdf_drivers"></a>
2.3.2. WDF Drivers</h2>
<p >The Windows Driver Foundation (WDF) is a wrapper around Microsoft Windows Driver Model (WDM) interfaces and is the preferred way to implement Windows drivers today. WDF is a set of Microsoft tools and libraries that aid in the creation of device drivers for Windows. It abstracts away much of the complexity of writing Windows drivers.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;From version 5.2.0 to 14.1.1 WinDriver was a WDM driver. From version 14.1.1 WinDriver is a full WDF driver. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch2_3_3_unix_device_drivers"></a>
2.3.3. Unix Device Drivers</h2>
<p >In the classic Unix driver model, devices belong to one of three categories: character (char) devices, block devices and network devices. Drivers that implement these devices are correspondingly known as char drivers, block drivers or network drivers. Under Unix, drivers are code units linked into the kernel that run in privileged kernel mode. Generally, driver code runs on behalf of a user-mode application. Access to Unix drivers from user-mode applications is provided via the file system. In other words, devices appear to the applications as special device files that can be opened.</p>
<p >Unix device drivers are either layered or monolithic drivers. A monolithic driver can be perceived as a one-layer layered driver.</p>
<h2><a class="anchor" id="ch2_3_4_linux_device_drivers"></a>
2.3.4. Linux Device Drivers</h2>
<p >Linux device drivers are based on the classic Unix device driver model. In addition, Linux introduces some new characteristics.</p>
<p >Under Linux, a block device can be accessed like a character device, as in Unix, but also has a block-oriented interface that is invisible to the user or application.</p>
<p >Traditionally, under Unix, device drivers are linked with the kernel, and the system is brought down and restarted after installing a new driver. Linux introduces the concept of a dynamically loadable driver called a module. Linux modules can be loaded or removed dynamically without requiring the system to be shut down. A Linux driver can be written so that it is statically linked or written in a modular form that allows it to be dynamically loaded. This makes Linux memory usage very efficient because modules can be written to probe for their own hardware and unload themselves if they cannot find the hardware they are looking for.</p>
<p >Like Unix device drivers, Linux device drivers are either layered or monolithic drivers.</p>
<h1><a class="anchor" id="ch2_4_the_entry_point_of_the_driver"></a>
2.4. The Entry Point of the Driver</h1>
<p >Every device driver must have one main entry point, like the <code>main()</code> function in a C console application. This entry point is called <code>DriverEntry()</code> in Windows and <code>init_module()</code> in Linux. When the operating system loads the device driver, this driver entry procedure is called.</p>
<p >There is some global initialization that every driver needs to perform only once when it is loaded for the first time. This global initialization is the responsibility of the <code>DriverEntry()</code>/<code>init_module()</code> routine. The entry function also registers which driver callbacks will be called by the operating system. These driver callbacks are operating system requests for services from the driver. In Windows, these callbacks are called dispatch routines, and in Linux they are called file operations. Each registered callback is called by the operating system as a result of some criteria, such as disconnection of hardware, for example.</p>
<h1><a class="anchor" id="ch2_5_associating_the_hardware_with_the_driver"></a>
2.5. Associating the Hardware with the Driver</h1>
<p >Operating systems differ in the ways they associate a device with a specific driver.</p>
<p >In Windows, the hardware-driver association is performed via an INF file, which registers the device to work with the driver. This association is performed before the <code>DriverEntry()</code> routine is called. The operating system recognizes the device, checks its database to identify which INF file is associated with the device, and according to the INF file, calls the driver's entry point.</p>
<p >In Linux, the hardware-driver association is defined in the driver's <code>init_module()</code> routine. This routine includes a callback that indicates which hardware the driver is designated to handle. The operating system calls the driver's entry point, based on the definition in the code.</p>
<h1><a class="anchor" id="ch2_6_communicating_with_drivers"></a>
2.6. Communicating with Drivers</h1>
<p >Communication between a user-mode application and the driver that drives the hardware, is implemented differently for each operating system, using the custom OS Application Programming Interfaces (APIs).</p>
<p >On Windows, and Linux, the application can use the OS file-access API to open a handle to the driver (e.g., using the Windows <code>CreateFile()</code> function or using the Linux <code>open()</code> function), and then read and write from/to the device by passing the handle to the relevant OS file-access functions (e.g., the Windows <code>ReadFile()</code> and <code>WriteFile()</code> functions, or the Linux <code>read()</code> and <code>write()</code> functions).</p>
<p >The application sends requests to the driver via I/O control (IOCTL) calls, using the custom OS APIs provided for this purpose (e.g., the Windows <code>DeviceIoControl()</code> function, or the Linux <code>ioctl()</code> function).</p>
<p >The data passed between the driver and the application via the IOCTL calls is encapsulated using custom OS mechanisms. For example, on Windows the data is passed via an I/O Request Packet (IRP) structure, and is encapsulated by the I/O Manager. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
