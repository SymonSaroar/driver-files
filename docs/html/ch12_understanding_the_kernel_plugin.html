<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 12: Understanding the Kernel PlugIn"/>
<title>Jungo WinDriver: Chapter 12: Understanding the Kernel PlugIn</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch12_understanding_the_kernel_plugin.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 12: Understanding the Kernel PlugIn </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap12"></a>This chapter provides a description of WinDriver's Kernel PlugIn feature.</p>
<h1><a class="anchor" id="ch12_1_background"></a>
12.1. Background</h1>
<p >The creation of drivers in user mode imposes a fair amount of function call overhead from the kernel to user mode, which may cause performance to drop to an unacceptable level. In such cases, the Kernel PlugIn feature allows critical sections of the driver code to be moved to the kernel while keeping most of the code intact. Using WinDriver's Kernel PlugIn feature, your driver will operate without any degradation in performance. The Kernel PlugIn is available for Windows and Linux, and it is an integral part of the WinDriver PCI/ISA toolkit that does not require additional licensing.</p>
<p >Writing a Kernel PlugIn driver provides the following advantages over a standard OS kernel mode driver:</p>
<ul>
<li>All the driver code is written and debugged in the user mode.</li>
<li>The code segments that are moved to the kernel mode remain essentially the same, and therefore typically no kernel debugging is needed.</li>
<li>The parts of the code that will run in the kernel through the Kernel PlugIn are platform independent, and therefore will run on every platform supported by WinDriver and the Kernel PlugIn. A standard kernel-mode driver will run only on the platform it was written for.</li>
</ul>
<p >Not every performance problem requires you to write a Kernel PlugIn driver. Some performance problems can be solved in the user-mode driver by better utilization of the features that WinDriver provides.</p>
<h1><a class="anchor" id="ch12_2_expected_performance"></a>
12.2. Expected Performance</h1>
<p >Since you can write your own interrupt handler in the kernel with the WinDriver Kernel PlugIn, you can expect to handle about 100,000 interrupts per second without missing any one of them.</p>
<h1><a class="anchor" id="ch12_3_overview_of_the_development_process"></a>
12.3. Overview of the Development Process</h1>
<p >Using the WinDriver Kernel PlugIn, you normally first develop and debug the driver in the user mode, using with standard WinDriver tools. After identifying the performance-critical parts of the code (such as the interrupt handling or access to I/O-mapped memory ranges), you can create a Kernel PlugIn driver, which runs in kernel mode, and drop the performance-critical portions of your code into the Kernel PlugIn driver, thus eliminating the calling overhead and context switches that occur when implementing the same tasks in the user mode.</p>
<p >This unique architecture allows the developer to start with quick and easy development in the user mode, and progress to performance-oriented code only where needed, thus saving development time and providing for virtually zero performance degradation.</p>
<h1><a class="anchor" id="ch12_4_the_kernel_plugin_architecture"></a>
12.4. The Kernel PlugIn Architecture</h1>
<h2><a class="anchor" id="ch12_4_1_architecture_overview"></a>
12.4.1. Architecture Overview</h2>
<p >A driver written in user mode uses WinDriver's API (WDC_xxx and/or WD_xxx ) to access devices. If a certain function that was implemented in the user mode requires kernel performance (the interrupt handler, for example), that function is moved to the WinDriver Kernel PlugIn.</p>
<p >Generally it should be possible to move code that uses WDC_xxx / WD_xxx function calls from the user mode to the kernel without modification, since the same WinDriver API is supported both in the user mode and in the Kernel PlugIn.</p>
<p ><b>Kernel PlugIn Architecture</b></p>
<div class="image">
<img src="KPArch.png" alt=""/>
</div>
 <h2><a class="anchor" id="ch12_4_2_windrivers_kernel_and_kernel_plugin_interaction"></a>
12.4.2. WinDriver's Kernel and Kernel PlugIn Interaction</h2>
<p >There are two types of interaction between the WinDriver kernel and the WinDriver Kernel PlugIn:</p>
<ul>
<li>Interrupt handling: When WinDriver receives an interrupt, by default it will activate the caller's user-mode interrupt handler. However, if the interrupt was set to be handled by a Kernel PlugIn driver, then once WinDriver receives the interrupt, it activates the Kernel PlugIn driver's kernel-mode interrupt handler.</li>
</ul>
<p >Your Kernel PlugIn interrupt handler could essentially consist of the same code that you wrote and debugged in the user-mode interrupt handler, before moving to the Kernel PlugIn, although some of the user-mode code should be modified. We recommend that you rewrite the interrupt acknowledgment and handling code in the Kernel PlugIn to utilize the flexibility offered by the Kernel PlugIn (see <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_5_handling_interrupts_in_the_kernel_plugin">12.5.5. Handling Interrupts in the Kernel PlugIn</a>).</p>
<ul>
<li>Message passing: To execute functions in kernel mode (such as I/O processing functions), the user-mode driver simply passes a message to the WinDriver Kernel PlugIn.</li>
</ul>
<p >The message is mapped to a specific function, which is then executed in the kernel. This function can typically contain the same code as it did when it was written and debugged in user mode. You can also use messages to pass data from the user-mode application to the Kernel PlugIn driver.</p>
<h2><a class="anchor" id="ch12_4_3_kernel_plugin_components"></a>
12.4.3. Kernel PlugIn Components</h2>
<p >At the end of your Kernel PlugIn development cycle, your driver will have the following components:</p>
<ul>
<li>User-mode driver application (<code>&lt;application name&gt;/.exe</code>), written with the WDC_xxx / WD_xxx API.</li>
<li>The WinDriver kernel module â€” <code>windrvr1511.sys/.o/.ko</code>, depending on the operating system.</li>
<li>Kernel PlugIn driver (<code>&lt;Kernel PlugIn driver name&gt;/.sys/.o/.ko/.kext</code>), which was also written with the WDC_xxx / WD_xxx API, and contains the driver functionality that you have selected to bring down to the kernel level.</li>
</ul>
<h2><a class="anchor" id="ch12_4_4_kernel_plugin_event_sequence"></a>
12.4.4. Kernel PlugIn Event Sequence</h2>
<p >The following is a typical event sequence that covers all the functions that you can implement in your Kernel PlugIn.</p>
<h3><a class="anchor" id="ch12_4_4_1_opening_a_handle_from_the_user_mode_to_a_kernel_plugin_driver"></a>
12.4.4.1. Opening a Handle from the User Mode to a Kernel PlugIn Driver</h3>
<p ><b>Event</b></p>
<p >Windows loads your Kernel PlugIn driver.</p>
<p >This takes place at boot time, by dynamic loading, or as instructed by the registry.</p>
<p ><b>Callback</b></p>
<p >Your KP_Init Kernel PlugIn routine is called.</p>
<p >KP_Init informs WinDriver of the name(s) of your KP_Open routine(s). WinDriver calls the relevant open routine when there is a user-mode request to open a handle to your Kernel PlugIn driver.</p>
<p ><b>Event</b></p>
<p >Your user-mode driver application requests a handle to your Kernel PlugIn driver, by calling one of the following functions:</p>
<ul>
<li><a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a></li>
<li><a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a>/WDC_IsaDeviceOpen() (PCI / ISA ) with the name of the Kernel PlugIn driver.</li>
<li><a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> â€” when using the low-level WinDriver API.</li>
</ul>
<p ><b>Callback</b></p>
<p >The relevant KP_Open Kernel PlugIn callback routine is called.</p>
<p >The KP_Open callback is used to inform WinDriver of the names of all the callback functions that you have implemented in your Kernel PlugIn driver, and to initiate the Kernel PlugIn driver, if needed.</p>
<h3><a class="anchor" id="ch12_4_4_2_handling_user-mode_requests_from_the_kernel_plugin"></a>
12.4.4.2. Handling User-Mode Requests from the Kernel PlugIn</h3>
<p ><b>Event</b></p>
<p >Your application calls <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a>, or the low-level <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> function.</p>
<p >Your application calls <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> / <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> to execute code in the kernel mode (in the Kernel PlugIn driver). The application passes a message to the Kernel PlugIn driver. The Kernel PlugIn driver will select the code to execute according to the message sent.</p>
<p ><b>Callback</b></p>
<p >Your KP_Call Kernel PlugIn routine is called. KP_Call executes code according to the message passed to it from the user mode.</p>
<h3><a class="anchor" id="ch12_4_4_3_interrupt_handling_â€”_enable-disable_and_high_interrupt_request_level_processing"></a>
12.4.4.3. Interrupt Handling â€” Enable/Disable and High Interrupt Request Level Processing</h3>
<p ><b>Event</b></p>
<p >Your application calls <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> with the fUseKP parameter set to TRUE (after having opened a handle to the Kernel PlugIn), or calls the low-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> or <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> functions with a handle to a Kernel PlugIn driver (set in the hKernelPlugIn field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure passed to the function).</p>
<p ><b>Callback</b></p>
<p >Your KP_IntEnable Kernel PlugIn routine is called. This function should contain any initialization required for your Kernel PlugIn interrupt handling.</p>
<p ><b>Event</b></p>
<p >Your hardware creates an interrupt.</p>
<p ><b>Callback</b></p>
<p >Your high-IRQL Kernel PlugIn interrupt handler routine â€” KP_IntAtIrql (legacy interrupts) or KP_IntAtIrqlMSI (MSI/MSI-X) â€” is called.</p>
<p >KP_IntAtIrql and KP_IntAtIrqlMSI run at a high priority, and therefore should perform only the basic interrupt handling, such as lowering the HW interrupt signal of level-sensitive interrupts to acknowledge the interrupt. If more interrupt processing is required, KP_IntAtIrql (legacy interrupts) or KP_IntAtIrqlMSI (MSI/MSI-X) can return TRUE in order to defer additional processing to the relevant deferred processing interrupt handler â€” KP_IntAtDpc or KP_IntAtDpcMSI .</p>
<p ><b>Event</b></p>
<p >Your application calls <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> , or the low-level <a class="el" href="windrvr__int__thread_8h_a895b7d55301d1f332fe9aa1c35800d62.html#a895b7d55301d1f332fe9aa1c35800d62">InterruptDisable()</a> or <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> functions, when the interrupts were previously enabled in the Kernel PlugIn (see the description of the interrupt enable event above).</p>
<p ><b>Callback</b></p>
<p >Your KP_IntDisable Kernel PlugIn routine is called. This function should free any memory that was allocated by the KP_IntEnable callback .</p>
<h3><a class="anchor" id="ch12_4_4_4_interrupt_handling_â€”_deferred_procedure_calls_event-callback_notes"></a>
12.4.4.4. Interrupt Handling â€” Deferred Procedure Calls Event/Callback Notes</h3>
<p ><b>Event</b></p>
<p >The Kernel PlugIn high-IRQL interrupt handler â€” KP_IntAtIrql or KP_IntAtIrqlMSI â€” returns TRUE. This informs WinDriver that additional interrupt processing is required as a Deferred Procedure Call (DPC) in the kernel.</p>
<p ><b>Callback</b></p>
<p >Your Kernel PlugIn DPC interrupt handler â€” KP_IntAtDpc (legacy interrupts) or KP_IntAtDpcMSI (MSI/MSI-X) â€” is called. Processes the rest of the interrupt code, but at a lower priority than the high-IRQL interrupt handler.</p>
<p ><b>Event</b></p>
<p >The DPC interrupt handler â€” KP_IntAtDpc or KP_IntAtDpcMSI â€” returns a value greater than 0. This informs WinDriver that additional usermode interrupt processing is required.</p>
<p ><b>Callback</b></p>
<p ><a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> returns. Your user-mode interrupt handler routine is executed.</p>
<h3><a class="anchor" id="ch12_4_4_5_plug-and-play_and_power_management_events"></a>
12.4.4.5. Plug-and-Play and Power Management Events</h3>
<p ><b>Event</b></p>
<p >Your application registers to receive Plug-and-Play and power management notifications using a Kernel PlugIn driver, by calling <a class="el" href="wdc__lib_8h_a761e2c2874342d1e724b1529ee603547.html#a761e2c2874342d1e724b1529ee603547" title="Registers the application to receive Plug-and-Play and power management events notifications for the ...">WDC_EventRegister()</a> with the with the <code>fUseKP</code> parameter set to <code>TRUE</code> (after having opened the device with a Kernel PlugIn), or calls the low-level <a class="el" href="windrvr__events_8h_a5a52cf4efc953dbf565202ea66eadbaf.html#a5a52cf4efc953dbf565202ea66eadbaf">EventRegister()</a> or <a class="el" href="windrvr_8h_aed0d6c7eaff6a8d772a4e09acfd647db.html#aed0d6c7eaff6a8d772a4e09acfd647db">WD_EventRegister()</a> functions with a handle to a Kernel PlugIn driver (set in the hKernelPlugIn field of the <a class="el" href="structWD__EVENT.html">WD_EVENT</a> structure that is passed to the function).</p>
<p ><b>Event</b></p>
<p >A Plug-and-Play or power management event (to which the application registered to listen) occurs.</p>
<p ><b>Callback</b></p>
<p >Your KP_Event Kernel PlugIn routine is called. KP_Event receives information about the event that occurred and can proceed to handle it as needed.</p>
<p ><b>Event</b></p>
<p >KP_Event returns <code>TRUE</code>. This informs WinDriver that the event also requires user-mode handling.</p>
<p ><b>Callback</b></p>
<p ><a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> returns. Your user-mode event handler routine is executed.</p>
<h1><a class="anchor" id="ch12_5_how_does_kernel_plugin_work"></a>
12.5. How Does Kernel PlugIn Work?</h1>
<p >The following sections take you through the development cycle of a Kernel PlugIn driver.</p>
<p >It is recommended that you first write and debug your entire driver code in the user mode. Then, if you encounter performance problems or require greater flexibility, port portions of your code to a Kernel PlugIn driver.</p>
<h2><a class="anchor" id="ch12_5_1_minimal_requirements_for_creating_a_kernel_plugin_driver"></a>
12.5.1. Minimal Requirements for Creating a Kernel PlugIn Driver</h2>
<p >To build a Kernel PlugIn driver you need the following tools:</p>
<ul>
<li>On Windows:</li>
</ul>
<p >The Windows Driver Kit (WDK), including its C build tools. The WDK is available as part of a Microsoft Development Network (MSDN) subscription, or from Microsoft Connect. For more information, refer to Microsoft's Windows Driver Kit (WDK) page.</p>
<ul>
<li>On Linux:</li>
</ul>
<p >GCC, gmake or make.</p>
<p >While this is not a minimal requirement, when developing a Kernel PlugIn driver it is highly recommended that you use two computers: set up one computer as your host platform and the other as your target platform. The host computer is the computer on which you develop your driver and the target computer is the computer on which you run and test the driver you develop.</p>
<h2><a class="anchor" id="ch12_5_2_kernel_plugin_implementation"></a>
12.5.2. Kernel PlugIn Implementation</h2>
<h3><a class="anchor" id="ch12_5_2_1_before_you_begin"></a>
12.5.2.1. Before You Begin</h3>
<p >The functions described in this section are callback functions, implemented in the Kernel PlugIn driver, which are called when their calling event occurs â€” see <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_4_4_kernel_plugin_event_sequence">12.4.4. Kernel PlugIn Event Sequence</a> for details. For example, KP_Init is the callback function that is called when the driver is loaded.</p>
<p >The name of your driver is given in KP_Init. The Kernel PlugIn driver's implementation of this callback must be named KP_Init. The names of the other Kernel PlugIn callback functions (which are passed to KP_Init) are left to the discretion of the driver developer.</p>
<p >It is the convention of this reference guide to refer to these callbacks using the format <code>KP_&lt;Functionality&gt;</code> â€” for example, KP_Open.</p>
<p >When generating Kernel PlugIn code with the DriverWizard, the names of the callback functions (apart from KP_Init) conform to the following format: KP_&lt;Driver Name&gt;_&lt;Functionality&gt;. For example, if you named your project MyDevice, the name of your Kernel PlugIn KP_Call callback will be KP_MyDevice_Call.</p>
<h3><a class="anchor" id="ch12_5_2_2_write_your_kp_init_function"></a>
12.5.2.2. Write Your KP_Init Function</h3>
<p >Your KP_Init function should be of the following prototype: <code>BOOL __cdecl KP_Init (<a class="el" href="structKP__INIT.html">KP_INIT</a> *kpInit)</code>;</p>
<p >This function is called once, when the driver is loaded. The function should fill the received <a class="el" href="structKP__INIT.html">KP_INIT</a> structure with the name of the Kernel PlugIn driver, the name of the WinDriver Kernel PlugIn driver library, and the driver's KP_Open callback(s) (see example in <code>WinDriver/samples/c/pci_diag/kp_pci/kp_pci.c</code>).</p>
<p >The name that you select for your Kernel PlugIn driver â€” by setting it in the cDriverName field of the <a class="el" href="structKP__INIT.html">KP_INIT</a> structure that is passed to KP_Init â€” should be the name of the driver that you wish to create; i.e., if you are creating a driver called <code>XXX.sys</code>, you should set the name "XXX" in the cDriverName field of the <a class="el" href="structKP__INIT.html">KP_INIT</a> structure.</p>
<p >You should verify that the driver name that is used when opening a handle to the Kernel PlugIn driver in the user mode (see <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_5_open_a_handle_to_the_kernel_plugin">13.5. Open a Handle to the Kernel PlugIn</a>) â€” in the pKPOpenData parameter of the <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> or <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a>/WDC_IsaDeviceOpen() (PCI / ISA ) functions, or in the pcDriverName field of the pKernelPlugIn parameter passed to the low-level <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> function â€” is identical to the driver name that was set in the cDriverName field of the <a class="el" href="structKP__INIT.html">KP_INIT</a> structure that is passed to KP_Init.</p>
<p >The best way to implement this is to define the driver name in a header file that is shared by the user-mode application and the Kernel PlugIn driver and use the defined value in all relevant locations.</p>
<p >From the KP_PCI sample (<code>WinDriver/samples/c/pci_diag/kp_pci/kp_pci.c</code>):</p>
<p >/* KP_Init is called when the Kernel PlugIn driver is loaded. This function sets the name of the Kernel PlugIn driver and the driver's open callback function(s). */</p>
<div class="fragment"><div class="line">BOOL __cdecl <a class="code hl_function" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5">KP_Init</a>(<a class="code hl_struct" href="structKP__INIT.html">KP_INIT</a> *kpInit)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Verify that the version of the WinDriver Kernel PlugIn library</span></div>
<div class="line"><span class="comment">    is identical to that of the windrvr.h and wd_kp.h files */</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="wd__ver_8h_ae288a3af41d2074d9c6cc2dc6e320e56.html#ae288a3af41d2074d9c6cc2dc6e320e56">WD_VER</a> != kpInit-&gt;<a class="code hl_variable" href="structKP__INIT_a3f6a461b1e8e053efe84eec4bb7a57a8.html#a3f6a461b1e8e053efe84eec4bb7a57a8">dwVerWD</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Rebuild your Kernel PlugIn driver project with the compatible</span></div>
<div class="line"><span class="comment">        version of the WinDriver Kernel PlugIn library (kp_nt&lt;version&gt;.lib)</span></div>
<div class="line"><span class="comment">        and windrvr.h and wd_kp.h files */</span></div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">    kpInit-&gt;<a class="code hl_variable" href="structKP__INIT_ac2998b0d31491706fcd334892b939759.html#ac2998b0d31491706fcd334892b939759">funcOpen</a> = <a class="code hl_function" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_PCI_Open</a>;</div>
<div class="line">    kpInit-&gt;<a class="code hl_variable" href="structKP__INIT_ad7dcb5b0fd60469a52cad0f31e906ffe.html#ad7dcb5b0fd60469a52cad0f31e906ffe">funcOpen_32_64</a> = KP_PCI_VIRT_Open_32_64;</div>
<div class="line">    <a class="code hl_function" href="kpstdlib_8h_adabd1201e06234be497500940cd85d63.html#adabd1201e06234be497500940cd85d63">strcpy</a> (kpInit-&gt;<a class="code hl_variable" href="structKP__INIT_a29479dce4346da7f3cad01946f6f9d35.html#a29479dce4346da7f3cad01946f6f9d35">cDriverName</a>, KP_PCI_DRIVER_NAME);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">}</div>
<div class="ttc" id="akp__pci_8c_a064eafb6f581af3d277f8410a69d74ec_html_a064eafb6f581af3d277f8410a69d74ec"><div class="ttname"><a href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_PCI_Open</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_Open(KP_OPEN_CALL *kpOpenCall, HANDLE hWD, PVOID pOpenData, PVOID *ppDrvContext)</div><div class="ttdoc">Kernel PlugIn open function.</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00154">kp_pci.c:154</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00264">kpstdlib.h:264</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
<div class="ttc" id="akpstdlib_8h_adabd1201e06234be497500940cd85d63_html_adabd1201e06234be497500940cd85d63"><div class="ttname"><a href="kpstdlib_8h_adabd1201e06234be497500940cd85d63.html#adabd1201e06234be497500940cd85d63">strcpy</a></div><div class="ttdeci">char *__cdecl strcpy(char *s1, const char *s2)</div></div>
<div class="ttc" id="astructKP__INIT_a29479dce4346da7f3cad01946f6f9d35_html_a29479dce4346da7f3cad01946f6f9d35"><div class="ttname"><a href="structKP__INIT_a29479dce4346da7f3cad01946f6f9d35.html#a29479dce4346da7f3cad01946f6f9d35">KP_INIT::cDriverName</a></div><div class="ttdeci">CHAR cDriverName[WD_MAX_KP_NAME_LENGTH]</div><div class="ttdoc">return the device driver name</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00069">wd_kp.h:69</a></div></div>
<div class="ttc" id="astructKP__INIT_a3f6a461b1e8e053efe84eec4bb7a57a8_html_a3f6a461b1e8e053efe84eec4bb7a57a8"><div class="ttname"><a href="structKP__INIT_a3f6a461b1e8e053efe84eec4bb7a57a8.html#a3f6a461b1e8e053efe84eec4bb7a57a8">KP_INIT::dwVerWD</a></div><div class="ttdeci">DWORD dwVerWD</div><div class="ttdoc">version of the WinDriver Kernel PlugIn library</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00068">wd_kp.h:68</a></div></div>
<div class="ttc" id="astructKP__INIT_ac2998b0d31491706fcd334892b939759_html_ac2998b0d31491706fcd334892b939759"><div class="ttname"><a href="structKP__INIT_ac2998b0d31491706fcd334892b939759.html#ac2998b0d31491706fcd334892b939759">KP_INIT::funcOpen</a></div><div class="ttdeci">KP_FUNC_OPEN funcOpen</div><div class="ttdoc">returns the KP_Open function</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00071">wd_kp.h:71</a></div></div>
<div class="ttc" id="astructKP__INIT_ad7dcb5b0fd60469a52cad0f31e906ffe_html_ad7dcb5b0fd60469a52cad0f31e906ffe"><div class="ttname"><a href="structKP__INIT_ad7dcb5b0fd60469a52cad0f31e906ffe.html#ad7dcb5b0fd60469a52cad0f31e906ffe">KP_INIT::funcOpen_32_64</a></div><div class="ttdeci">KP_FUNC_OPEN funcOpen_32_64</div><div class="ttdoc">returns the KP_Open function for 32 bit app with 64 bit KP.</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00072">wd_kp.h:72</a></div></div>
<div class="ttc" id="astructKP__INIT_html"><div class="ttname"><a href="structKP__INIT.html">KP_INIT</a></div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00066">wd_kp.h:67</a></div></div>
<div class="ttc" id="awd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5_html_ad2d90fcb178eba74eb09dd3da8355fe5"><div class="ttname"><a href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5">KP_Init</a></div><div class="ttdeci">BOOL __cdecl KP_Init(KP_INIT *kpInit)</div><div class="ttdoc">You must define a KP_Init() function to link to the device driver.</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00065">kp_pci.c:65</a></div></div>
<div class="ttc" id="awd__ver_8h_ae288a3af41d2074d9c6cc2dc6e320e56_html_ae288a3af41d2074d9c6cc2dc6e320e56"><div class="ttname"><a href="wd__ver_8h_ae288a3af41d2074d9c6cc2dc6e320e56.html#ae288a3af41d2074d9c6cc2dc6e320e56">WD_VER</a></div><div class="ttdeci">#define WD_VER</div><div class="ttdef"><b>Definition:</b> <a href="wd__ver_8h_source.html#l00025">wd_ver.h:25</a></div></div>
</div><!-- fragment --><p >Note that the driver name in the sample is set using a preprocessor definition. This definition is found in the <code>WinDriver/samples/c/pci_diag/pci_lib.h</code> header file, which is shared by the pci_diag user-mode application and the KP_PCI Kernel PlugIn driver:</p>
<div class="fragment"><div class="line">/* Kernel PlugIn driver name (should be no more than 8 characters) */</div>
<div class="line">#define KP_PCI_DRIVER_NAME &quot;KP_PCI&quot;</div>
</div><!-- fragment --><h3><a class="anchor" id="ch12_5_2_3_write_your_kp_open_functions"></a>
12.5.2.3. Write Your KP_Open Function(s)</h3>
<p >You can implement either one or two KP_Open functions, depending on your target configuration. The KP_Open function(s) should be of the following prototype:</p>
<div class="fragment"><div class="line">BOOL __cdecl KP_Open (</div>
<div class="line">    <a class="code hl_struct" href="structKP__OPEN__CALL.html">KP_OPEN_CALL</a> *kpOpenCall,</div>
<div class="line">    HANDLE hWD,</div>
<div class="line">    PVOID pOpenData,</div>
<div class="line">    PVOID *ppDrvContext);</div>
<div class="ttc" id="astructKP__OPEN__CALL_html"><div class="ttname"><a href="structKP__OPEN__CALL.html">KP_OPEN_CALL</a></div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00048">wd_kp.h:49</a></div></div>
</div><!-- fragment --><p >This callback is called when opening a handle to the Kernel PlugIn driver from the user mode â€” i.e., when <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> is called, either directly or via <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> / ISA ), as explained in <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_5_open_a_handle_to_the_kernel_plugin">13.5. Open a Handle to the Kernel PlugIn</a>.</p>
<p >In the KP_Open function, define the callbacks that you wish to implement in the Kernel PlugIn.</p>
<p >The following is a list of the callbacks that can be implemented:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><b>Callback</b>   </th><th class="markdownTableHeadLeft"><b>Description</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>KP_Close</b>   </td><td class="markdownTableBodyLeft">Called when the <a class="el" href="windrvr_8h_a3b108638d5a2bcdbd8fc740e5063effe.html#a3b108638d5a2bcdbd8fc740e5063effe" title="Closes the WinDriver Kernel PlugIn handle obtained from WD_KernelPlugInOpen()">WD_KernelPlugInClose()</a> function is called from the user mode â€” either directly, or via one of the high-level <a class="el" href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188" title="Uninitializes a WDC PCI device structure and frees the memory allocated for it.">WDC_PciDeviceClose()</a> / <a class="el" href="wdc__lib_8h_a2a4b820da9b800812dedf52b775e71e1.html#a2a4b820da9b800812dedf52b775e71e1" title="Uninitializes a WDC ISA device structure and frees the memory allocated for it.">WDC_IsaDeviceClose()</a> functions (PCI / ISA ) when called for a device that contains an open Kernel PlugIn handle (see <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_5_open_a_handle_to_the_kernel_plugin">13.5. Open a Handle to the Kernel PlugIn</a>).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>KP_Call</b>   </td><td class="markdownTableBodyLeft">Called when the user-mode application calls the <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> function or the low-level <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> function, which is called by the wrapper <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> function. This function implements a Kernel PlugIn message handler.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>KP_IntEnable</b>   </td><td class="markdownTableBodyLeft">Called when the user-mode application enables Kernel PlugIn interrupts, by calling <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> with the fUseKP parameter set to TRUE (after having opened a Kernel PlugIn handle), or by calling the low-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> or <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> functions with a handle to a Kernel PlugIn driver (set in the hKernelPlugIn field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure that is passed to the function). This function should contain any initialization required for your Kernel PlugIn interrupt handling.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>KP_IntDisable</b>   </td><td class="markdownTableBodyLeft">Called when the user-mode application calls <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a>, or the low-level <a class="el" href="windrvr__int__thread_8h_a895b7d55301d1f332fe9aa1c35800d62.html#a895b7d55301d1f332fe9aa1c35800d62">InterruptDisable()</a> or <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> functions, if the interrupts were previously enabled with a Kernel PlugIn driver (see the description of KP_IntEnable above). This function should free any memory that was allocated by the KP_IntEnable callback.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>KP_IntAtIrql</b>   </td><td class="markdownTableBodyLeft">Called when WinDriver receives a legacy interrupt, provided the received interrupt was enabled with a handle to the Kernel PlugIn. This is the function that will handle your legacy interrupt in the kernel mode. The function runs at high interrupt request level. Additional deferred processing of the interrupt can be performed in KP_IntAtDpc and also in the user mode (see below).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>KP_IntAtDpc</b>   </td><td class="markdownTableBodyLeft">Called if the KP_IntAtIrql callback has requested deferred handling of a legacy interrupt by returning TRUE. This function should include lower-priority kernel-mode interrupt handler code. The return value of this function determines the amount of times that the application's usermode interrupt handler routine will be invoked (if at all).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>KP_IntAtIrqlMSI</b>   </td><td class="markdownTableBodyLeft">Called when WinDriver receives an MSI or MSI-X, provided MSI/MSI-X was enabled for the received interrupt with a handle to the Kernel PlugIn. This is the function that will handle your MSI/MSI-X in the kernel mode. The function runs at high interrupt request level. Additional deferred processing of the interrupt can be performed in KP_IntAtDpcMSI and also in the user mode (see below).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>KP_IntAtDpcMSI</b>   </td><td class="markdownTableBodyLeft">Called if the KP_IntAtIrqlMSI callback has requested deferred handling of an MSI/MSI-X interrupt by returning TRUE. This function should include lower-priority kernel-mode MSI/MSI-X handler code. The return value of this function determines the amount of times that the application's usermode interrupt handler routine will be invoked (if at all).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>KP_Event</b>   </td><td class="markdownTableBodyLeft">Called when a Plug-and-Play or power management event occurs, provided the user-mode application previously registered to receive notifications for this event in the Kernel PlugIn by calling <a class="el" href="wdc__lib_8h_a761e2c2874342d1e724b1529ee603547.html#a761e2c2874342d1e724b1529ee603547" title="Registers the application to receive Plug-and-Play and power management events notifications for the ...">WDC_EventRegister()</a> with the <code>fUseKP</code> parameter set to <code>TRUE</code> (after having opened a Kernel PlugIn handle), or by calling the low-level <a class="el" href="windrvr__events_8h_a5a52cf4efc953dbf565202ea66eadbaf.html#a5a52cf4efc953dbf565202ea66eadbaf">EventRegister()</a> or <a class="el" href="windrvr_8h_aed0d6c7eaff6a8d772a4e09acfd647db.html#aed0d6c7eaff6a8d772a4e09acfd647db">WD_EventRegister()</a> functions with a handle to a Kernel PlugIn driver (set in the <code>hKernelPlugIn</code> field of the <a class="el" href="structWD__EVENT.html">WD_EVENT</a> structure that is passed to the function).   </td></tr>
</table>
<p >In addition to defining the Kernel PlugIn callback functions, you can implement code to perform any required initialization for the Kernel PlugIn in your KP_Open callback(s). In the sample KP_PCI driver and in the generated DriverWizard Kernel PlugIn driver, for example, the Kernel PlugIn open callbacks also call the shared library's initialization function and allocate memory for the Kernel PlugIn driver context, which is then used to store the device information that was passed to the function from the user mode.</p>
<p >From the KP_PCI sample (<code>WinDriver/samples/c/pci_diag/kp_pci/kp_pci.c</code>):</p>
<p >/* KP_PCI_Open is called when <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> is called from the user mode. pDrvContext will be passed to the rest of the Kernel PlugIn callback functions. */</p>
<div class="fragment"><div class="line">BOOL __cdecl <a class="code hl_function" href="kp__pci_8c_a064eafb6f581af3d277f8410a69d74ec.html#a064eafb6f581af3d277f8410a69d74ec">KP_PCI_Open</a>(<a class="code hl_struct" href="structKP__OPEN__CALL.html">KP_OPEN_CALL</a> *kpOpenCall, HANDLE hWD, PVOID    pOpenData,</div>
<div class="line">PVOID *ppDrvContext)</div>
<div class="line">{</div>
<div class="line">    PCI_DEV_ADDR_DESC *pDevAddrDesc;</div>
<div class="line">    <a class="code hl_struct" href="structWDC__ADDR__DESC.html">WDC_ADDR_DESC</a> *pAddrDesc;</div>
<div class="line">    DWORD dwSize;</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line">    <span class="comment">/* Initialize the PCI library */</span></div>
<div class="line">    dwStatus = PCI_LibInit();</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        KP_PCI_Err(<span class="stringliteral">&quot;KP_PCI_Open: Failed to initialize the PCI library: %s&quot;</span>,</div>
<div class="line">            PCI_GetLastErr());</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">    KP_PCI_Trace(<span class="stringliteral">&quot;KP_PCI_Open entered. PCI library initialized.\n&quot;</span>);</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a2df5615557017c3539d52bb5691e6eea.html#a2df5615557017c3539d52bb5691e6eea">funcClose</a> = <a class="code hl_function" href="kp__pci_8c_a94c55a14dd58912cfdf7f467932d9b1c.html#a94c55a14dd58912cfdf7f467932d9b1c">KP_PCI_Close</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_aa505a9f7a9515638df55a1cf9a635fbf.html#aa505a9f7a9515638df55a1cf9a635fbf">funcCall</a> = <a class="code hl_function" href="kp__pci_8c_ab5c8485a1ca1b486dada24cefc0c92b9.html#ab5c8485a1ca1b486dada24cefc0c92b9">KP_PCI_Call</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a60601602d5d5e219505d9c434d41422d.html#a60601602d5d5e219505d9c434d41422d">funcIntEnable</a> = <a class="code hl_function" href="kp__pci_8c_a58602ae407f1cd41f7012e82590382fa.html#a58602ae407f1cd41f7012e82590382fa">KP_PCI_IntEnable</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_ae4c5bd8c1df0fa1c5cf874ad15313853.html#ae4c5bd8c1df0fa1c5cf874ad15313853">funcIntDisable</a> = <a class="code hl_function" href="kp__pci_8c_abfe30b4c1a4e7906feb7ca890f490787.html#abfe30b4c1a4e7906feb7ca890f490787">KP_PCI_IntDisable</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a337d0e457ba249815c0da824293f3519.html#a337d0e457ba249815c0da824293f3519">funcIntAtIrql</a> = <a class="code hl_function" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_PCI_IntAtIrql</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a8f614d13a7551b0da2650b8ada406e28.html#a8f614d13a7551b0da2650b8ada406e28">funcIntAtDpc</a> = <a class="code hl_function" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_PCI_IntAtDpc</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a88b15e530ffb6ee3ec597dff026971e7.html#a88b15e530ffb6ee3ec597dff026971e7">funcIntAtIrqlMSI</a> = <a class="code hl_function" href="kp__pci_8c_a074bb35466923e0f621da5b61f72d3e1.html#a074bb35466923e0f621da5b61f72d3e1">KP_PCI_IntAtIrqlMSI</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a49e9bc49554ee2b21ae80333f61bd645.html#a49e9bc49554ee2b21ae80333f61bd645">funcIntAtDpcMSI</a> = <a class="code hl_function" href="kp__pci_8c_a4573c90779850a5fb30079ccb7801647.html#a4573c90779850a5fb30079ccb7801647">KP_PCI_IntAtDpcMSI</a>;</div>
<div class="line">    kpOpenCall-&gt;<a class="code hl_variable" href="structKP__OPEN__CALL_a0d119692c6c190a2879bd49f0acd1045.html#a0d119692c6c190a2879bd49f0acd1045">funcEvent</a> = <a class="code hl_function" href="kp__pci_8c_aeb9d505bf483521c2e944b5f06b89c03.html#aeb9d505bf483521c2e944b5f06b89c03">KP_PCI_Event</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Create a copy of device information in the driver context */</span></div>
<div class="line">    dwSize = <span class="keyword">sizeof</span>(PCI_DEV_ADDR_DESC);</div>
<div class="line">    pDevAddrDesc = <a class="code hl_function" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a>(dwSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!pDevAddrDesc)</div>
<div class="line">        <span class="keywordflow">goto</span> malloc_error;</div>
<div class="line">    </div>
<div class="line">    COPY_FROM_USER(pDevAddrDesc, pOpenData, dwSize);</div>
<div class="line">    dwSize = <span class="keyword">sizeof</span>(<a class="code hl_struct" href="structWDC__ADDR__DESC.html">WDC_ADDR_DESC</a>) * pDevAddrDesc-&gt;dwNumAddrSpaces;</div>
<div class="line">    pAddrDesc = <a class="code hl_function" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a>(dwSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!pAddrDesc)</div>
<div class="line">        <span class="keywordflow">goto</span> malloc_error;</div>
<div class="line">        </div>
<div class="line">    COPY_FROM_USER(pAddrDesc, pDevAddrDesc-&gt;pAddrDesc, dwSize);</div>
<div class="line">    pDevAddrDesc-&gt;pAddrDesc = pAddrDesc;</div>
<div class="line">    *ppDrvContext = pDevAddrDesc;</div>
<div class="line">    KP_PCI_Trace(<span class="stringliteral">&quot;KP_PCI_Open: Kernel PlugIn driver opened successfully\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line"> </div>
<div class="line">malloc_error:</div>
<div class="line">    KP_PCI_Err(<span class="stringliteral">&quot;KP_PCI_Open: Failed allocating %ld bytes\n&quot;</span>, dwSize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (pDevAddrDesc)</div>
<div class="line">        <a class="code hl_function" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a>(pDevAddrDesc);</div>
<div class="line">    PCI_LibUninit();</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">}</div>
<div class="ttc" id="akp__pci_8c_a074bb35466923e0f621da5b61f72d3e1_html_a074bb35466923e0f621da5b61f72d3e1"><div class="ttname"><a href="kp__pci_8c_a074bb35466923e0f621da5b61f72d3e1.html#a074bb35466923e0f621da5b61f72d3e1">KP_PCI_IntAtIrqlMSI</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_IntAtIrqlMSI(PVOID pIntContext, ULONG dwLastMessage, DWORD dwReserved)</div><div class="ttdoc">High-priority Message-Signaled Interrupts (MSI) / Extended Message-Signaled Interrupts (MSI-X) handle...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00643">kp_pci.c:643</a></div></div>
<div class="ttc" id="akp__pci_8c_a4573c90779850a5fb30079ccb7801647_html_a4573c90779850a5fb30079ccb7801647"><div class="ttname"><a href="kp__pci_8c_a4573c90779850a5fb30079ccb7801647.html#a4573c90779850a5fb30079ccb7801647">KP_PCI_IntAtDpcMSI</a></div><div class="ttdeci">DWORD __cdecl KP_PCI_IntAtDpcMSI(PVOID pIntContext, DWORD dwCount, ULONG dwLastMessage, DWORD dwReserved)</div><div class="ttdoc">Deferred processing Message-Signaled Interrupts (MSI) / Extended Message-Signaled Interrupts (MSI-X) ...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00688">kp_pci.c:688</a></div></div>
<div class="ttc" id="akp__pci_8c_a49b3648af7f7baf87412d805176d4cd1_html_a49b3648af7f7baf87412d805176d4cd1"><div class="ttname"><a href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_PCI_IntAtDpc</a></div><div class="ttdeci">DWORD __cdecl KP_PCI_IntAtDpc(PVOID pIntContext, DWORD dwCount)</div><div class="ttdoc">Deferred processing legacy interrupt handler routine.</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00602">kp_pci.c:602</a></div></div>
<div class="ttc" id="akp__pci_8c_a58602ae407f1cd41f7012e82590382fa_html_a58602ae407f1cd41f7012e82590382fa"><div class="ttname"><a href="kp__pci_8c_a58602ae407f1cd41f7012e82590382fa.html#a58602ae407f1cd41f7012e82590382fa">KP_PCI_IntEnable</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_IntEnable(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall, PVOID *ppIntContext)</div><div class="ttdoc">Called when WDC_IntEnable() / WD_IntEnable() is called from the user mode with a Kernel PlugIn handle...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00428">kp_pci.c:428</a></div></div>
<div class="ttc" id="akp__pci_8c_a766459ac39112e0692658ec3e3597712_html_a766459ac39112e0692658ec3e3597712"><div class="ttname"><a href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_PCI_IntAtIrql</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_IntAtIrql(PVOID pIntContext, BOOL *pfIsMyInterrupt)</div><div class="ttdoc">High-priority legacy interrupt handler routine, which is run at high interrupt request level.</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00495">kp_pci.c:495</a></div></div>
<div class="ttc" id="akp__pci_8c_a94c55a14dd58912cfdf7f467932d9b1c_html_a94c55a14dd58912cfdf7f467932d9b1c"><div class="ttname"><a href="kp__pci_8c_a94c55a14dd58912cfdf7f467932d9b1c.html#a94c55a14dd58912cfdf7f467932d9b1c">KP_PCI_Close</a></div><div class="ttdeci">void __cdecl KP_PCI_Close(PVOID pDrvContext)</div><div class="ttdoc">Called when WD_KernelPlugInClose() (see the WinDriver PCI Low-Level API Reference) is called from use...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00326">kp_pci.c:326</a></div></div>
<div class="ttc" id="akp__pci_8c_ab5c8485a1ca1b486dada24cefc0c92b9_html_ab5c8485a1ca1b486dada24cefc0c92b9"><div class="ttname"><a href="kp__pci_8c_ab5c8485a1ca1b486dada24cefc0c92b9.html#ab5c8485a1ca1b486dada24cefc0c92b9">KP_PCI_Call</a></div><div class="ttdeci">void __cdecl KP_PCI_Call(PVOID pDrvContext, WD_KERNEL_PLUGIN_CALL *kpCall)</div><div class="ttdoc">Called when the user-mode application calls WDC_CallKerPlug() (or the low-level WD_KernelPlugInCall()...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00377">kp_pci.c:377</a></div></div>
<div class="ttc" id="akp__pci_8c_abfe30b4c1a4e7906feb7ca890f490787_html_abfe30b4c1a4e7906feb7ca890f490787"><div class="ttname"><a href="kp__pci_8c_abfe30b4c1a4e7906feb7ca890f490787.html#abfe30b4c1a4e7906feb7ca890f490787">KP_PCI_IntDisable</a></div><div class="ttdeci">void __cdecl KP_PCI_IntDisable(PVOID pIntContext)</div><div class="ttdoc">Called when WDC_IntDisable() / WD_IntDisable() is called from the user mode for interrupts that were ...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00456">kp_pci.c:456</a></div></div>
<div class="ttc" id="akp__pci_8c_aeb9d505bf483521c2e944b5f06b89c03_html_aeb9d505bf483521c2e944b5f06b89c03"><div class="ttname"><a href="kp__pci_8c_aeb9d505bf483521c2e944b5f06b89c03.html#aeb9d505bf483521c2e944b5f06b89c03">KP_PCI_Event</a></div><div class="ttdeci">BOOL __cdecl KP_PCI_Event(PVOID pDrvContext, WD_EVENT *wd_event)</div><div class="ttdoc">Called when a Plug-and-Play or power management event for the device is received, provided the user-m...</div><div class="ttdef"><b>Definition:</b> <a href="kp__pci_8c_source.html#l00712">kp_pci.c:712</a></div></div>
<div class="ttc" id="akpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9_html_a736d9ab37afc2ba50e25346a3d49a8d9"><div class="ttname"><a href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a></div><div class="ttdeci">void *__cdecl malloc(unsigned long size)</div></div>
<div class="ttc" id="akpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650_html_acc3b4a8c7b4ba9ec1fd2138ca3f6f650"><div class="ttname"><a href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a></div><div class="ttdeci">void __cdecl free(void *buf)</div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a0d119692c6c190a2879bd49f0acd1045_html_a0d119692c6c190a2879bd49f0acd1045"><div class="ttname"><a href="structKP__OPEN__CALL_a0d119692c6c190a2879bd49f0acd1045.html#a0d119692c6c190a2879bd49f0acd1045">KP_OPEN_CALL::funcEvent</a></div><div class="ttdeci">KP_FUNC_EVENT funcEvent</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00058">wd_kp.h:58</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a2df5615557017c3539d52bb5691e6eea_html_a2df5615557017c3539d52bb5691e6eea"><div class="ttname"><a href="structKP__OPEN__CALL_a2df5615557017c3539d52bb5691e6eea.html#a2df5615557017c3539d52bb5691e6eea">KP_OPEN_CALL::funcClose</a></div><div class="ttdeci">KP_FUNC_CLOSE funcClose</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00050">wd_kp.h:50</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a337d0e457ba249815c0da824293f3519_html_a337d0e457ba249815c0da824293f3519"><div class="ttname"><a href="structKP__OPEN__CALL_a337d0e457ba249815c0da824293f3519.html#a337d0e457ba249815c0da824293f3519">KP_OPEN_CALL::funcIntAtIrql</a></div><div class="ttdeci">KP_FUNC_INT_AT_IRQL funcIntAtIrql</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00054">wd_kp.h:54</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a49e9bc49554ee2b21ae80333f61bd645_html_a49e9bc49554ee2b21ae80333f61bd645"><div class="ttname"><a href="structKP__OPEN__CALL_a49e9bc49554ee2b21ae80333f61bd645.html#a49e9bc49554ee2b21ae80333f61bd645">KP_OPEN_CALL::funcIntAtDpcMSI</a></div><div class="ttdeci">KP_FUNC_INT_AT_DPC_MSI funcIntAtDpcMSI</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00057">wd_kp.h:57</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a60601602d5d5e219505d9c434d41422d_html_a60601602d5d5e219505d9c434d41422d"><div class="ttname"><a href="structKP__OPEN__CALL_a60601602d5d5e219505d9c434d41422d.html#a60601602d5d5e219505d9c434d41422d">KP_OPEN_CALL::funcIntEnable</a></div><div class="ttdeci">KP_FUNC_INT_ENABLE funcIntEnable</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00052">wd_kp.h:52</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a88b15e530ffb6ee3ec597dff026971e7_html_a88b15e530ffb6ee3ec597dff026971e7"><div class="ttname"><a href="structKP__OPEN__CALL_a88b15e530ffb6ee3ec597dff026971e7.html#a88b15e530ffb6ee3ec597dff026971e7">KP_OPEN_CALL::funcIntAtIrqlMSI</a></div><div class="ttdeci">KP_FUNC_INT_AT_IRQL_MSI funcIntAtIrqlMSI</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00056">wd_kp.h:56</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_a8f614d13a7551b0da2650b8ada406e28_html_a8f614d13a7551b0da2650b8ada406e28"><div class="ttname"><a href="structKP__OPEN__CALL_a8f614d13a7551b0da2650b8ada406e28.html#a8f614d13a7551b0da2650b8ada406e28">KP_OPEN_CALL::funcIntAtDpc</a></div><div class="ttdeci">KP_FUNC_INT_AT_DPC funcIntAtDpc</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00055">wd_kp.h:55</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_aa505a9f7a9515638df55a1cf9a635fbf_html_aa505a9f7a9515638df55a1cf9a635fbf"><div class="ttname"><a href="structKP__OPEN__CALL_aa505a9f7a9515638df55a1cf9a635fbf.html#aa505a9f7a9515638df55a1cf9a635fbf">KP_OPEN_CALL::funcCall</a></div><div class="ttdeci">KP_FUNC_CALL funcCall</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00051">wd_kp.h:51</a></div></div>
<div class="ttc" id="astructKP__OPEN__CALL_ae4c5bd8c1df0fa1c5cf874ad15313853_html_ae4c5bd8c1df0fa1c5cf874ad15313853"><div class="ttname"><a href="structKP__OPEN__CALL_ae4c5bd8c1df0fa1c5cf874ad15313853.html#ae4c5bd8c1df0fa1c5cf874ad15313853">KP_OPEN_CALL::funcIntDisable</a></div><div class="ttdeci">KP_FUNC_INT_DISABLE funcIntDisable</div><div class="ttdef"><b>Definition:</b> <a href="wd__kp_8h_source.html#l00053">wd_kp.h:53</a></div></div>
<div class="ttc" id="astructWDC__ADDR__DESC_html"><div class="ttname"><a href="structWDC__ADDR__DESC.html">WDC_ADDR_DESC</a></div><div class="ttdoc">Address space information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00027">wdc_defs.h:27</a></div></div>
<div class="ttc" id="awindrvr_8h_a4be61f088cf6870c6ff37ab94aba215c_html_a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41"><div class="ttname"><a href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a></div><div class="ttdeci">@ WD_STATUS_SUCCESS</div><div class="ttdoc">[0] Operation completed successfully</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01041">windrvr.h:1041</a></div></div>
</div><!-- fragment --><p >The KP_PCI sample also defines a similar KP_PCI_Open_32_64 callback, for use when opening a handle to a 64-bit Kernel PlugIn from a 32-bit application.</p>
<h3><a class="anchor" id="ch12_5_2_4_write_the_remaining_plugin_callbacks"></a>
12.5.2.4. Write the Remaining PlugIn Callbacks</h3>
<p >Implement the remaining Kernel PlugIn routines that you wish to use (such as the KP_Intxxx functions â€” for handling interrupts, or KP_Event â€” for handling Plug-and-Play and power management events).</p>
<h2><a class="anchor" id="ch12_5_3_sample-generated_kernel_plugin_driver_code_overview"></a>
12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</h2>
<p >You can use DriverWizard to generate a skeletal Kernel PlugIn driver for your device, and use the generated code as the basis for your Kernel PlugIn driver development (recommended); alternatively, you can use one of the Kernel PlugIn WinDriver samples as the basis for your Kernel PlugIn development.</p>
<p >The Kernel PlugIn documentation in this manual focuses on the generated DriverWizard code, and the generic PCI Kernel PlugIn sample â€” KP_PCI, located in the<code>WinDriver/samples/c/pci_diag/kp_pci</code> directory.</p>
<p >If you are using the a PCI Express card with the Xilinx Bus Master DMA (BMD) design, you can also use the KP_BMD Kernel PlugIn sample as the basis for your development; the <code>WinDriver/samples/c/xilinx/bmd_design</code> directory contains all the relevant sample files â€” see the Xilinx BMD Kernel PlugIn directory structure note at the end of <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_4_1_pci_diag_and_kp_pci_sample_directories">12.5.4.1. pci_diag and kp_pci Sample Directories</a>.</p>
<p >The Kernel PlugIn driver is not a standalone module. It requires a user-mode application that initiates the communication with the driver. A relevant application will be generated for your driver when using DriverWizard to generate Kernel PlugIn code. The pci_diag application (found under the <code>WinDriver/samples/c/pci_diag</code> directory) communicates with the sample KP_PCI driver.</p>
<p >Both the KP_PCI sample and the wizard-generated code demonstrate communication between a user-mode application (<code>pci_diag</code> / <code>xxx_diag</code> â€” where <code>xxx</code> is the name you selected for your generated driver project) and a Kernel PlugIn driver (<code>kp_pci.sys/.o/.ko/.kext</code> / <code>kp_xxx.sys/.o/.ko/.kext</code> â€” depending on the OS).</p>
<p >The sample/generated code demonstrates how to pass data to the Kernel PlugIn's KP_Open function, and how to use this function to allocate and store a global Kernel PlugIn driver context that can be used by other functions in the Kernel PlugIn.</p>
<p >The sample/generated Kernel PlugIn code implements a message for getting the driver's version number, in order to demonstrate how to initiate specific functionality in the Kernel PlugIn from the user mode and how to pass data between the Kernel PlugIn driver and a user-mode WinDriver application via messages.</p>
<p >The sample/generated code also demonstrates how to handle interrupts in the Kernel PlugIn. The Kernel PlugIn implements an interrupt counter and interrupt handlers, including deferred processing interrupt handling, which is used to notify the user-mode application of the arrival of every fifth incoming interrupt.</p>
<p >The KP_PCI sample's KP_IntAtIrql() functions demonstrate legacy level-sensitive PCI interrupt handling. As indicated in the comments of the sample KP_IntAtIrql function, you will need to modify this function in order to implement the correct code for acknowledging the interrupt on your specific device, since interrupt acknowledgment is hardware-specific. The sample KP_IntAtIrqlMSI() and KP_IntAtDpcMSI() functions demonstrate handling of Message-Signaled Interrupts (MSI) and Extended Message-Signaled Interrupts (MSI-X) (see detailed information in <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">10.4. Single Root I/O Virtualization (SR-IOV)</a>).</p>
<p >The generated DriverWizard code will include sample interrupt handler code for the selected device (PCI/ISA). The generated KP_IntAtIrql function will include code to implement any interrupt transfer commands defined in the wizard (by assigning registers read/write commands to the card's interrupt in the Interrupt tab).</p>
<p >For legacy PCI interrupts, which need to be acknowledged in the kernel when the interrupt is received (see <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">10.4. Single Root I/O Virtualization (SR-IOV)</a>), it is recommended that you use the wizard to define the commands for acknowledging (clearing) the interrupt, before generating the Kernel PlugIn code, so that the generated code will already include the required code for executing the commands you defined.</p>
<p >It is also recommended that you prepare such transfer commands when handling interrupts for hardware that supports MSI/MSI-X, in case enabling of MSI/MSI-X fails and the interrupt handling defaults to using level-sensitive interrupts (if supported by the hardware).</p>
<blockquote class="doxtable">
<p >&zwj;<b>âš  Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Memory allocated for the transfer commands must remain available until the interrupts are disabled . </p>
</blockquote>
</blockquote>
<p>In addition, the sample/generated code demonstrates how to receive notifications of Plug-and-Play and power management events in the Kernel PlugIn.</p>
<p >We recommend that you build and run the sample/generated Kernel PlugIn project (and corresponding user-mode application) "as-is" before modifying the code or writing your own Kernel PlugIn driver. Note, however, that you will need to modify or remove the hardware-specific transfer commands in the sample's KP_IntAtIrql function, as explained above.</p>
<h2><a class="anchor" id="ch12_5_4_kernel_plugin_sample-generated_code_directory_structure"></a>
12.5.4. Kernel PlugIn Sample/Generated Code Directory Structure</h2>
<h3><a class="anchor" id="ch12_5_4_1_pci_diag_and_kp_pci_sample_directories"></a>
12.5.4.1. pci_diag and kp_pci Sample Directories</h3>
<p >The KP_PCI Kernel PlugIn sample code is implemented in the <a class="el" href="kp__pci_8c.html">kp_pci.c</a> file. This sample driver is part of the WinDriver PCI diagnostics sample â€” pci_diag â€” which contains, in addition to the KP_PCI driver, a user-mode application that communicates with the driver (<code>pci_diag</code>) and a shared library that includes APIs that can be utilized by both the user-mode application and the Kernel PlugIn driver. The source files for this sample are implemented in C.</p>
<p >Following is an outline of the files found in the <code>WinDriver/samples/c/pci_diag</code> directory:</p>
<ul>
<li><code>kp_pci</code> â€” Contains the KP_PCI Kernel PlugIn driver files:<ul>
<li><code><a class="el" href="kp__pci_8c.html">kp_pci.c</a></code>: The source code of the KP_PCI driver.</li>
<li>Project and/or make files and related files for building the Kernel PlugIn driver.</li>
</ul>
</li>
</ul>
<p >The Windows project/make files are located in subdirectories for the target development environment (<code>msdev_&lt;version&gt;/win_gcc</code>) under <code>x86</code> (32-bit) and <code>amd64</code> (64-bit) directories. The Linux makefile is generated using a configure script, located directly under the kp_pci directory.</p><ul>
<li>A pre-compiled version of the KP_PCI Kernel PlugIn driver for the target OS:</li>
</ul>
<p >Windows x86 32-bit: <code>WINNT.i386\kp_pci.sys</code> â€” a 32-bit version of the driver. Windows x64: <code>WINNT.x86_64\kp_pci.sys</code> â€” a 64-bit version of the driver. Linux: There is no pre-compiled version of the driver for Linux, since Linux kernel modules must be compiled with the header files from the kernel version installed on the target â€” see <a class="el" href="ch15_distributing_your_driver.html#ch15_3_linux_driver_distribution">15.3. Linux Driver Distribution</a>).</p>
<ul>
<li><code>pci_lib.c</code>: Implementation of a library for accessing PCI devices using WinDriver's WDC API. The library's API is used both by the user-mode application (<code>pci_diag.c</code>) and by the Kernel PlugIn driver (<code><a class="el" href="kp__pci_8c.html">kp_pci.c</a></code>).</li>
<li><code>pci_lib.h</code>: Header file, which provides the interface for the pci_lib library.</li>
<li><code>pci_diag.c</code>: Implementation of a sample diagnostics user-mode console (CUI) application, which demonstrates communication with a PCI device using the pci_lib and WDC libraries.</li>
</ul>
<p >The sample also demonstrates how to communicate with a Kernel PlugIn driver from a user mode WinDriver application. By default, the sample attempts to open the selected PCI device with a handle to the KP_PCI Kernel PlugIn driver. If successful, the sample demonstrates how to interact with a Kernel PlugIn driver, as detailed in <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a>. If the application fails to open a handle to the Kernel PlugIn driver, all communication with the device is performed from the user mode.</p><ul>
<li><code>pci.inf</code> (Windows): A sample WinDriver PCI INF file for Windows. NOTE: To use this file, change the vendor and device IDs in the file to comply with those of your specific device.</li>
</ul>
<p >To use Message-Signaled Interrupts (MSI) or Extended Message-Signaled Interrupts (MSI-X) on Windows (for PCI cards that support MSI/MSI-X) you will need to modify or replace the sample INF file so that your INF file includes specific MSI information; otherwise WinDriver will attempt to use legacy level-sensitive interrupt handling for your card, as explained in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_7_1_windows_msi-msi-x_device_inf_files">10.1.7.1. Windows MSI/MSI-X Device INF Files</a>.</p><ul>
<li>Project and/or make files for building the <code>pci_diag</code> user-mode application.</li>
</ul>
<p >The Windows project/make files are located in subdirectories for the target development environment (<code>msdev_&lt;version&gt;/win_gcc</code>) under <code>x86</code> (32-bit) and <code>amd64</code> (64-bit) directories. The <code>msdev_&lt;version&gt;</code> MS Visual Studio directories also include solution files for building both the Kernel PlugIn driver and user-mode application projects. The Linux makefile is located under a LINUX subdirectory.</p><ul>
<li>A pre-compiled version of the user-mode application (pci_diag) for your target operating system:</li>
</ul>
<p >Windows: <code>WIN32\pci_diag.exe</code> Linux: <code>LINUX/pci_diag</code></p><ul>
<li><code>files.txt</code>: A list of the sample <code>pci_diag</code> files.</li>
<li><code>readme.pdf</code>: An overview of the sample Kernel PlugIn driver and user-mode application and instructions for building and testing the code.</li>
</ul>
<h3><a class="anchor" id="ch12_5_4_2_xilinx_bmd_kernel_plugin_directory_structure"></a>
12.5.4.2. Xilinx BMD Kernel PlugIn Directory Structure</h3>
<p >The structure of the sample directory for PCI Express cards with the Xilinx Bus Master DMA (BMD) design â€” <code>WinDriver/samples/c/xilinx/bmd_design</code> â€” is similar to that of the generic PCI sample's pci_diag directory, except for the following issues: the <code>bmd_diag</code> user-mode application files are located under a diag subdirectory, and the kp subdirectory, which contains the Kernel PlugIn driver's (<code>KP_BMD</code>) source files, currently has make files only for Windows.</p>
<h3><a class="anchor" id="ch12_5_4_3_the_generated_driverwizard_kernel_plugin_directory"></a>
12.5.4.3. The Generated DriverWizard Kernel PlugIn Directory</h3>
<p >The generated DriverWizard Kernel PlugIn code for your device will include a kernel-mode Kernel PlugIn project and a user-mode application that communicates with it. As opposed to the generic KP_PCI and pci_diag sample, the wizard-generated code will utilize the resources information detected and/or defined for your specific device, as well as any device-specific information that you define in the wizard before generating the code.</p>
<p >As indicated in <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a>, when using the driver to handle legacy PCI interrupts, it is highly recommended that you define the registers that need to be read/written in order to acknowledge the interrupt, and set up the relevant read/write commands from/to these registers in DriverWizard, before generating the code, thus enabling the generated interrupt handler code to utilize the hardware-specific information that you defined. It is also recommended that you prepare such transfer commands when handling interrupts for hardware that supports MSI/MSI-X, in case enabling of MSI/MSI-X fails and the interrupt handling defaults to using level-sensitive interrupts (if supported by the hardware).</p>
<blockquote class="doxtable">
<p >&zwj;<b>âš  Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Memory allocated for the transfer commands must remain available until the interrupts are disabled . </p>
</blockquote>
</blockquote>
<p>Following is an outline of the generated DriverWizard files when selecting to generate Kernel PlugIn code (where <code>xxx</code> signifies the name that you selected for the driver when generating the code).</p>
<p >The outline below relates to the generated C code, but on Windows you can also generate similar C# code, which includes a C Kernel PlugIn driver (since kernel-mode drivers cannot be implemented in C#), a .NET C# library, and a C# user-mode application that communicates with the Kernel PlugIn driver.</p>
<ul>
<li><code>kermode</code> â€” Contains the KP_XXX Kernel PlugIn driver files:<ul>
<li><code>kp_xxx.c</code>: The source code of the KP_XXX driver.</li>
<li>Project and/or make files and related files for building the Kernel PlugIn driver.</li>
</ul>
</li>
</ul>
<p >The Windows project/make files are located in subdirectories for the target development environment (<code>msdev_&lt;version&gt;/win_gcc</code>) under x86 (32-bit) and amd64 (64-bit) directories. The Linux makefile is generated using a configure script, located in a linux subdirectory.</p><ul>
<li><code>xxx_lib.c</code>: Implementation of a library for accessing your device using WinDriver's WDC API. The library's API is used both by the user-mode application (<code>xxx_diag</code>) and by the Kernel PlugIn driver (KP_XXX).</li>
<li><code>xxx_lib.h</code>: Header file, which provides the interface for the <code>xxx_lib</code> library.</li>
<li><code>xxx_diag.c</code>: Implementation of a sample diagnostics user-mode console (CUI) application, which demonstrates communication your device using the <code>xxx_lib</code> and WDC libraries.</li>
</ul>
<p >The application also demonstrates how to communicate with a Kernel PlugIn driver from a user-mode WinDriver application. By default, the application attempts to open your device with a handle to the KP_XXX Kernel PlugIn driver. If successful, the application demonstrates how to interact with a Kernel PlugIn driver, as detailed in <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_3_sample-generated_kernel_plugin_driver_code_overview">12.5.3. Sample/Generated Kernel PlugIn Driver Code Overview</a>. If the application fails to open a handle to the Kernel PlugIn driver, all communication with the device is performed from the user mode.</p><ul>
<li>Project and/or make files for building the <code>xxx_diag</code> user-mode application.</li>
</ul>
<p >The Windows project/make files are located in subdirectories for the target development environment (<code>msdev_&lt;version&gt;/win_gcc</code>) under x86 (32-bit) and amd64 (64-bit) directories. The <code>msdev_&lt;version&gt;</code> MS Visual Studio directories also include solution files for building both the Kernel PlugIn driver and user-mode application projects. The Linux makefile is located in a linux subdirectory.</p><ul>
<li><code>xxx_files.txt</code>: A list of the generated files and instructions for building the code.</li>
<li><code>xxx.inf</code> (Windows): A WinDriver INF file for your device. This file is required only when creating a Windows driver for a Plug-and-Play device, such as PCI.</li>
</ul>
<h2><a class="anchor" id="ch12_5_5_handling_interrupts_in_the_kernel_plugin"></a>
12.5.5. Handling Interrupts in the Kernel PlugIn</h2>
<p >Interrupts will be handled in the Kernel PlugIn driver, if enabled, using a Kernel PlugIn driver, as explained below (see <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_5_2_interrupt_handling_in_the_kernel_using_the_kernel_plugin">12.5.5.2. Interrupt Handling in the Kernel (Using the Kernel PlugIn)</a>).</p>
<p >If Kernel PlugIn interrupts were enabled, when WinDriver receives a hardware interrupt, it calls the Kernel PlugIn driver's high-IRQL handler â€” KP_IntAtIrql (legacy interrupts) or KP_IntAtIrqlMSI (MSI/MSI-X). If the high-IRQL handler returns TRUE, the relevant deferred Kernel PlugIn interrupt handler â€” KP_IntAtDpc (legacy interrupts) or KP_IntAtDpcMSI (MSI/MSI-X) â€” will be called after the high-IRQL handler completes its processing and returns. The return value of the DPC function determines how many times (if at all) the user-mode interrupt handler routine will be executed.</p>
<p >In the KP_PCI sample, for example, the Kernel PlugIn interrupt handler code counts five interrupts, and notifies the user mode on every fifth interrupt; thus <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> will return on only one out of every five incoming interrupts in the user mode.</p>
<p >The high-IRQL handler â€” KP_IntAtIrql or KP_IntAtIrqlMSI â€” returns TRUE every five interrupts to activate the DPC handler â€” KP_IntAtDpc or KP_IntAtDpcMSI â€” and the DPC function returns the number of accumulated DPC calls from the high-IRQL handler. As a result, the user-mode interrupt handler will be executed once for every 5 interrupts.</p>
<h3><a class="anchor" id="ch12_5_5_1_interrupt_handling_in_the_user_mode_without_the_kernel_plugin"></a>
12.5.5.1. Interrupt Handling in the User Mode (Without the Kernel PlugIn)</h3>
<p >If the Kernel PlugIn interrupt handle is not enabled, then each incoming interrupt will cause <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> to return, and your user-mode interrupt handler routine will be invoked once WinDriver completes the kernel processing of the interrupts (mainly executing the interrupt transfer commands passed in the call to <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> or the low-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> or <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> functions) â€” see Figure below.</p>
<p ><b>Interrupt Handling Without Kernel PlugIn</b></p>
<div class="image">
<img src="int_handling_no_kp.png" alt=""/>
</div>
 <h3><a class="anchor" id="ch12_5_5_2_interrupt_handling_in_the_kernel_using_the_kernel_plugin"></a>
12.5.5.2. Interrupt Handling in the Kernel (Using the Kernel PlugIn)</h3>
<p >To have the interrupts handled by the Kernel PlugIn, the user-mode application shoul open a handle to a Kernel PlugIn driver (as explained in <a class="el" href="ch13_creating_a_kernel_plugin_driver.html#ch13_5_open_a_handle_to_the_kernel_plugin">13.5. Open a Handle to the Kernel PlugIn</a>), and then call <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> with the fUseKP parameter set to <code>TRUE</code>.</p>
<p >If your are not using the WDC_xxx API, your application should pass a handle to the Kernel PlugIn driver to the <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> function or the wrapper <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> function (which calls <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> and <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a>). This enables the Kernel PlugIn interrupt handler. The Kernel PlugIn handle is passed within the hKernelPlugIn field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure that is passed to the functions.</p>
<p ><b>Interrupt Handling With the Kernel PlugIn</b></p>
<div class="image">
<img src="int_handling_with_kp.png" alt=""/>
</div>
 <p >When calling <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> / <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> / <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> to enable interrupts in the Kernel PlugIn, your Kernel PlugIn's KP_IntEnable callback function is activated. In this function you can set the interrupt context that will be passed to the Kernel PlugIn interrupt handlers, as well as write to the device to actually enable the interrupts in the hardware and implement any other code required in order to correctly enable your device's interrupts.</p>
<p >If the Kernel PlugIn interrupt handler is enabled, then the relevant high-IRQL handler, based on the type of interrupt that was enabled â€” KP_IntAtIrql (legacy interrupts) or KP_IntAtIrqlMSI (MSI/MSI-X) â€” will be called for each incoming interrupt. The code in the high-IRQL handler is executed at high interrupt request level. While this code is running, the system is halted, i.e., there will be no context switches and no lower-priority interrupts will be handled.</p>
<p >Code running at high IRQL is limited in the following ways:</p>
<ul>
<li>It may only access non-pageable memory.</li>
<li>It may only call the following functions (or wrapper functions that call these functions):</li>
<li>WDC_xxx() read/write address or configuration space functions.</li>
<li><a class="el" href="wdc__lib_8h_a1c930425141ee9e086419280343b1969.html#a1c930425141ee9e086419280343b1969" title="Performs a group of memory and/or I/O read/write transfers.">WDC_MultiTransfer()</a> , or the low-level <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a>, <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a>, or <a class="el" href="windrvr_8h_a8e65c66178d0a60a95a5c789eca9aac9.html#a8e65c66178d0a60a95a5c789eca9aac9" title="Sends debug messages to the debug log.">WD_DebugAdd()</a> functions.</li>
<li>Specific kernel OS functions (such as WDK functions) that can be called from high interrupt request level. Note that the use of such functions may break the code's portability to other operating systems.</li>
<li>It may not call <a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a>, <a class="el" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free()</a>, or any WDC_xxx or WD_xxx API other than those listed above.</li>
</ul>
<p >Because of the aforementioned limitations, the code in the high-IRQL handler (KP_IntAtIrql or KP_IntAtIrqlMSI ) should be kept to a minimum, such as acknowledgment (clearing) of level-sensitive interrupts. Other code that you want to run in the interrupt handler should be implemented in the DPC function (KP_IntAtDpc or KP_IntAtDpcMSI ), which runs at a deferred interrupt level and does not face the same limitations as the high-IRQL handlers. The DPC function is called after its matching high-IRQL function returns, provided the high-IRQL handler returns TRUE.</p>
<p >You can also leave some additional interrupt handling to the user mode. The return value of your DPC function â€” KP_IntAtDpc() â€” determines the amount of times (if any) that your user-mode interrupt handler routine will be called after the kernel-mode interrupt processing is completed.</p>
<h2><a class="anchor" id="ch12_5_6_message_passing"></a>
12.5.6. Message Passing</h2>
<p >The WinDriver architecture enables a kernel-mode function to be activated from the user mode by passing a message from the user mode to the Kernel PlugIn driver using <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> or the low-level <a class="el" href="windrvr_8h_a17a9b9b4521ecd3867c3d1e1f4699df0.html#a17a9b9b4521ecd3867c3d1e1f4699df0" title="Calls a routine in the Kernel PlugIn to be executed.">WD_KernelPlugInCall()</a> function.</p>
<p >The messages are defined by the developer in a header file that is common to both the user-mode and kernel-mode plugin parts of the driver. In the pci_diag KP_PCI sample and the generated DriverWizard code, the messages are defined in the shared library header file â€” <code>pci_lib.h</code> in the sample or <code>xxx_lib.h</code> in the generated code.</p>
<p >Upon receiving the message from the user mode, WinDriver will execute the KP_Call Kernel PlugIn callback function, which identifies the message that has been received and executes the relevant code for this message (as implemented in the Kernel PlugIn).</p>
<p >The sample/generated Kernel PlugIn code implement a message for getting the driver's version in order to demonstrate Kernel PlugIn data passing. The code that sets the version number in KP_Call is executed in the Kernel PlugIn whenever the Kernel PlugIn receives a relevant message from the user-mode application.</p>
<p >You can see the definition of the message in the shared <code>pci_lib.h</code> / <code>xxx_lib.h</code> shared header file. The user-mode application (<code>pci_diag.exe</code> / <code>xxx_diag.exe</code>) sends the message to the Kernel PlugIn driver via the <a class="el" href="wdc__lib_8h_a5127fd7b9401f15cb473b07f734c8c97.html#a5127fd7b9401f15cb473b07f734c8c97" title="Sends a message from a user-mode application to a Kernel PlugIn driver.">WDC_CallKerPlug()</a> function .</p>
<h1><a class="anchor" id="ch12_6_faq_understanding_the_kernel_plugin"></a>
12.6. FAQ</h1>
<h2><a class="anchor" id="ch12_6_1_why_does_my_wd_kernelpluginopen_call_fail"></a>
12.6.1. Why does my WD_KernelPlugInOpen() call fail?</h2>
<p >There are several reasons why the call to <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> might fail:</p>
<ul>
<li>You did not set up the parameters correctly in the call to <code><a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a></code>. Please check this carefully.</li>
<li>You did not set up the driver name correctly in all locations in the code. Please verify that you are using the correct Kernel PlugIn driver name in all the relevant locations in the code. Look specifically at the <code>Kernel PlugIn <a class="el" href="wd__kp_8h_ad2d90fcb178eba74eb09dd3da8355fe5.html#ad2d90fcb178eba74eb09dd3da8355fe5" title="You must define a KP_Init() function to link to the device driver.">KP_Init()</a></code> implementation and at <code>kernelPlugIn.pcDriverName</code> in the user mode project. Please indicate the driver name in capital letters and without the file extension <code>(*.sys/.ko)</code>.</li>
<li>You did not install the driver properly. Make sure you copied the driver file that was created to the correct location (e.g.,<code>windir%\system32\drivers</code> â€” to install a SYS Kernel PlugIn driver on Windows) and that you installed the Kernel PlugIn kernel module correctly, as explained in the this Manual.</li>
</ul>
<p >For Windows, for example, make sure to use the correct wdreg/wdreg_gui/wdreg_frontend syntax. For SYS drivers:</p>
<div class="fragment"><div class="line">wdreg -name &lt;your KP driver name&gt; install</div>
</div><!-- fragment --><ul>
<li>For registered users. You did not call <a class="el" href="windrvr_8h_a7d44fc6d31627ded58bfd36543909464.html#a7d44fc6d31627ded58bfd36543909464" title="Transfers the license string to the WinDriver kernel module When using the high-level WDC library API...">WD_License()</a> before calling <a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a>. If you are using a registered version of WinDriver, remember to call <a class="el" href="windrvr_8h_a7d44fc6d31627ded58bfd36543909464.html#a7d44fc6d31627ded58bfd36543909464" title="Transfers the license string to the WinDriver kernel module When using the high-level WDC library API...">WD_License()</a> (or a registration function, which calls <a class="el" href="windrvr_8h_a7d44fc6d31627ded58bfd36543909464.html#a7d44fc6d31627ded58bfd36543909464" title="Transfers the license string to the WinDriver kernel module When using the high-level WDC library API...">WD_License()</a> ) before calling <code><a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a></code>.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>âš  Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;<a class="el" href="windrvr_8h_a17e25e9aa7335df67ffde221ff0b5294.html#a17e25e9aa7335df67ffde221ff0b5294" title="Obtain a valid handle to the Kernel PlugIn.">WD_KernelPlugInOpen()</a> is also called from the high-level <a class="el" href="wdc__lib_8h_a8e405829088b75e2980d866a70d55c44.html#a8e405829088b75e2980d866a70d55c44" title="Opens a handle to a Kernel PlugIn driver.">WDC_KernelPlugInOpen()</a> function, and from the <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> functions â€” when they are called with the name of a Kernel PlugIn driver. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch12_6_2_when_handling_my_interrupts_entirely_in_the_kernel_plugin_can_i_erase_the_interrupt_handler_in_the_user_mode"></a>
12.6.2. When handling my interrupts entirely in the Kernel PlugIn, can I erase the interrupt handler in the user mode?</h2>
<p >Yes, you can erase the user mode interrupt handler routine.</p>
<p >You can also implement some of the interrupt handling in the Kernel PlugIn and some of it in the user mode. The return value of <a class="el" href="kp__pci_8c_a49b3648af7f7baf87412d805176d4cd1.html#a49b3648af7f7baf87412d805176d4cd1">KP_IntAtDpc()</a> (which is called when the high-priority KP_IntAtIrql() routine returns TRUE) determines the number of times that the user mode interrupt handler routine will be executed (if at all).</p>
<h2><a class="anchor" id="ch12_6_3_how_can_i_print_debug_statements_from_the_kernel_plugin_that_i_can_view_using_a_kernel_debugger_such_as_windbg"></a>
12.6.3. How can I print debug statements from the Kernel PlugIn that I can view using a kernel debugger, such as WinDbg?</h2>
<p >You can use WinDriverâ€™s <a class="el" href="windrvr_8h_a8e65c66178d0a60a95a5c789eca9aac9.html#a8e65c66178d0a60a95a5c789eca9aac9" title="Sends debug messages to the debug log.">WD_DebugAdd()</a> function to print debug messages from your Kernel PlugIn or user-mode code to the Debug Monitor utility, and then view the messages in the Debug Monitor log. <a class="el" href="windrvr_8h_a8e65c66178d0a60a95a5c789eca9aac9.html#a8e65c66178d0a60a95a5c789eca9aac9" title="Sends debug messages to the debug log.">WD_DebugAdd()</a> can be called from within any user-mode or Kernel PlugIn function, including <a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_IntAtIrql()</a>.</p>
<p >You can also select to send the debug information from WinDriverâ€™s Debug Monitor to a kernel debugger, as explained in <a class="el" href="ch8_debugging_drivers.html">Chapter 8: Debugging Drivers</a>.</p>
<p >In addition, you can add calls in your Kernel PlugIn code to OS kernel functions that print directly to the kernel debugger â€” such as <code>KdPrint()</code> on Windows, or <code>printk()</code> on Linux.</p>
<h2><a class="anchor" id="ch12_6_4_my_pc_hangs_while_closing_my_application_the_code_fails_in_wd_intdisable_why_is_this_happening_i_am_using_the_kernel_plugin_to_handle_interrupts"></a>
12.6.4. My PC hangs while closing my application. The code fails in WD_IntDisable(). Why is this happening? I am using the Kernel PlugIn to handle interrupts.</h2>
<p >This might happen if you are enabling the interrupt from your Kernel PlugIn interrupt routines, and simultaneously disabling it from the user mode (using <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> or <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> / <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> â€” which call <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a>). Since the interrupt is active (having been enabled from the Kernel PlugIn), the interrupt cannot be disabled and the PC hangs waiting for <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> to return.</p>
<p >A possible solution, is to call <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> / <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> / <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> as an atomic operation, so that it will disable the interrupts successfully before the Kernel PlugIn interrupt routine enables the interrupt. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
