<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 7: Developing a Driver"/>
<title>Jungo WinDriver: Chapter 7: Developing a Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch7_developing_a_driver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 7: Developing a Driver </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap07"></a>This chapter takes you through the WinDriver driver development cycle.</p>
<h1><a class="anchor" id="ch7_1_using_driverwizard_to_build_a_device_driver"></a>
7.1. Using DriverWizard to Build a Device Driver</h1>
<p >You can use DriverWizard to diagnose your device and verify that it operates as expected, as well as to generate skeletal code for your device in C, C#, Visual Basic (USB Only), Java and Python. For more information about DriverWizard, refer to <a class="el" href="ch6_using_driverwizard.html">Chapter 6: Using DriverWizard</a>.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;For devices based on the Altera Qsys, Avalon-MM designs, Xilinx BMD, XDMA, QDMA designs, you can use DriverWizard to generate customized device-specific code, which utilizes the enhanced-support sample APIs. For additional information, refer to <a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">Chapter 9: Enhanced Support for Specific Chipsets</a>. This is the most recommended way to develop a driver using WinDriver as it saves you the most time and hassle. </p>
</blockquote>
</blockquote>
<p>Use any C/C#.NET/Python/Java compiler/interpreter or development environment (depending on the code you created) to build the skeletal driver you need. WinDriver provides specific support for the following environments and compilers: MS Visual Studio, CMake, GNU Make/Eclipse (for Java projects).</p>
<p >That is all you need to do in order to create your user-mode driver. If you discover that better performance is needed, refer to <a class="el" href="ch11_improving_pci_performance.html">Chapter 11: Improving PCI Performance</a>.</p>
<p >To learn how to perform operations that DriverWizard cannot automate, refer to <a class="el" href="ch10_pci_advanced_features.html">Chapter 10: PCI Advanced Features</a>.</p>
<h1><a class="anchor" id="ch7_2_using_a_code_sample_to_build_a_device_driver"></a>
7.2. Using a code sample to Build a Device Driver</h1>
<p >If you are using an enhanced-support PCI device (PLX 6466, 9030, 9050, 9052, 9054, 9056, 9080 and 9656; Altera Qsys, Avalon-MM designs; Xilinx BMD, XDMA, QDMA designs), you may want to use the related WinDriver sample as the basis for your development instead of generating code with DriverWizard.</p>
<p >This method is relevant if you are unable to get DriverWizard to work on your platform or if it is not available for your platform and you wish to quickly start developing.</p>
<p >These samples can be found in ´WinDriver/samples/c´. These directories include both the source code and project files to compile them, and also a precompiled version of the sample source code.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Note that after your evaluation period has expired the precompiled binaries of the sample will not work, and you will have to recompile them with your new license key. </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch7_3_writing_the_device_driver_without_driverwizard"></a>
7.3. Writing the Device Driver Without DriverWizard</h1>
<p >There may be times when you choose to write your driver directly, without using DriverWizard.</p>
<p >In such cases, either follow the steps outlined in this section to create a new driver project, or select a WinDriver sample that most closely resembles your target driver and modify it to suit your specific requirements.</p>
<p >This method is recommended only for expert users that are already familiar with the WinDriver API and the required compilation flags needed in order to compile WinDriver.</p>
<h2><a class="anchor" id="ch7_3_1_include_the_required_windriver_files"></a>
7.3.1. Include the Required WinDriver Files</h2>
<p >Firstly, include the relevant WinDriver header files in your driver project. All header files are found under the <code>WinDriver/include</code> or <code>WinDriver/samples/c/shared</code> (for C projects) directory. All WinDriver projects require the <code><a class="el" href="windrvr_8h.html">windrvr.h</a></code> header file.</p>
<p >When using the WDC_xxx API / WDU_xxx API , include the <code><a class="el" href="wdc__lib_8h.html">wdc_lib.h</a></code> / <code><a class="el" href="wdu__lib_8h.html">wdu_lib.h</a></code> and <code><a class="el" href="wdc__defs_8h.html">wdc_defs.h</a></code> header files (these files already include <code><a class="el" href="windrvr_8h.html">windrvr.h</a></code>).</p>
<p >Include any other header file that provides APIs that you wish to use from your code (e.g., files from the <code>WinDriver/samples/c/shared</code> directory, which provide convenient diagnostics functions.)</p>
<p >Then include the relevant header files from your source code. For example, to use API from the <a class="el" href="windrvr_8h.html">windrvr.h</a> header file, add the following line to the code:</p>
<div class="fragment"><div class="line">#include &quot;windrvr.h&quot;</div>
</div><!-- fragment --><p >Afterwards, link your code with the WDAPI library (Windows) / shared object (Linux):</p>
<ul>
<li>For Windows: <code>WinDriver\lib\amd64\wdapi1511.lib</code>, for compiling 64-bit binaries for x64 platforms, or <code>WinDriver\lib\amd64\x86\wdapi1511_32.lib</code> for compiling 32-bit binaries for x64 platforms</li>
<li>For Linux: From the <code>WinDriver/lib</code> directory — <code>libwdapi1511.so</code> (for 64-bit binaries for x64 platforms) or <code>libwdapi1511_32.so</code> (for 32-bit applications targeted at 64-bit platforms).</li>
<li>For MacOS: From the <code>WinDriver/lib</code> directory — <code>libwdapi1511.dylib</code></li>
</ul>
<p >(note that WinDriver for MacOS currently doesn't support 32 bit applications on 64-bit platforms).</p>
<p >You can also include the library's source files in your project instead of linking the project with the library. The C source files are located under the <code>WinDriver/src/wdapi</code> directory.</p>
<p >When linking your project with the WDAPI library/framework/shared object, you will need to distribute this binary with your driver.</p><ul>
<li>For Windows, get <code>wdapi1511.dll</code> / <code>wdapi1511_32.dll</code> (for 32-bit applications targeted at 64-bit platforms) from the <code>WinDriver/redist</code> directory.</li>
<li>For Linux, get <code>libwdapi1511.so</code> / <code>libwdapi1511_32.so</code> (for 32-bit applications targeted at 64-bit platforms) from the <code>WinDriver/lib</code> directory.</li>
<li>For MacOS, get <code>libwdapi1511.dylib</code> from the <code>WinDriver/lib</code> directory.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;WinDriver for MacOS currently doesn't support 32 bit applications on 64-bit platforms. </p>
</blockquote>
</blockquote>
<p>Add any other WinDriver source files that implement API that you which to use in your code (e.g. files from the <code>WinDriver/samples/c/shared</code> directory.)</p>
<h2><a class="anchor" id="ch7_3_2_write_your_code_pci-isa"></a>
7.3.2. Write Your Code (PCI/ISA)</h2>
<p >This section outlines the calling sequence when using the WDC_xxx API:</p>
<ul>
<li>Call <a class="el" href="wdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f.html#afe495f80d709b330bb26a80756cd9f9f" title="Opens and stores a handle to WinDriver&#39;s kernel module and initializes the WDC library according to t...">WDC_DriverOpen()</a> to open a handle to WinDriver and the WDC library, compare the version of the loaded driver with that of your driver source files, and register your WinDriver license (for registered users).<ul>
<li>For PCI/PCI Express devices, call <a class="el" href="wdc__lib_8h_a15790844cb433fbaaf8c390a368d0efb.html#a15790844cb433fbaaf8c390a368d0efb" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevices()</a> to scan the PCI bus and locate your device.</li>
<li>For PCI/PCI Express devices, call <a class="el" href="wdc__lib_8h_a920d348804f4ee3aa118ebf073d33698.html#a920d348804f4ee3aa118ebf073d33698" title="Retrieves a PCI device&#39;s resources information (memory and I/O ranges and interrupt information).">WDC_PciGetDeviceInfo()</a> to retrieve the resources information for your selected device.</li>
<li>For ISA devices, define the resources yourself within a <a class="el" href="structWD__CARD.html">WD_CARD</a> structure.</li>
</ul>
</li>
<li>Call <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> (depending on your device), and pass to the function the device's resources information. These functions return a handle to the device, which you can later use to communicate with the device using the WDC_xxx API.</li>
<li>Communicate with the device using the WDC_xxx API.<ul>
<li>To enable interrupts, call <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a>.</li>
<li>To register to receive notifications for Plug-and-Play and power management events, call <a class="el" href="wdc__lib_8h_a761e2c2874342d1e724b1529ee603547.html#a761e2c2874342d1e724b1529ee603547" title="Registers the application to receive Plug-and-Play and power management events notifications for the ...">WDC_EventRegister()</a>.</li>
</ul>
</li>
<li>When you are done:<ul>
<li>Call <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> to disable interrupt handling (if previously enabled)</li>
<li>Call <a class="el" href="wdc__lib_8h_a761e2c2874342d1e724b1529ee603547.html#a761e2c2874342d1e724b1529ee603547" title="Registers the application to receive Plug-and-Play and power management events notifications for the ...">WDC_EventRegister()</a> to unregister Plug-and-Play and power management event handling (if previously registered)</li>
<li>Call <a class="el" href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188" title="Uninitializes a WDC PCI device structure and frees the memory allocated for it.">WDC_PciDeviceClose()</a> / <a class="el" href="wdc__lib_8h_a2a4b820da9b800812dedf52b775e71e1.html#a2a4b820da9b800812dedf52b775e71e1" title="Uninitializes a WDC ISA device structure and frees the memory allocated for it.">WDC_IsaDeviceClose()</a> (depending on your device) in order to close the handle to the device.</li>
<li>Call <a class="el" href="wdc__lib_8h_a58fa8be948e1a2042746d719983ffd2e.html#a58fa8be948e1a2042746d719983ffd2e" title="Closes the WDC WinDriver handle (acquired and stored by a previous call to WDC_DriverOpen()) and unin...">WDC_DriverClose()</a> to close the handles to WinDriver and the WDC library.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ch7_3_3_write_your_code_usb"></a>
7.3.3. Write Your Code (USB)</h2>
<p >This section outlines the calling sequence when using the WDU_xxx / WDC_xxx API:</p><ul>
<li>Call <a class="el" href="wdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f.html#afe495f80d709b330bb26a80756cd9f9f" title="Opens and stores a handle to WinDriver&#39;s kernel module and initializes the WDC library according to t...">WDC_DriverOpen()</a> to open a handle to WinDriver and the WDC library, compare the version of the loaded driver with that of your driver source files, and register your WinDriver license (for registered users).</li>
<li>Call <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> at the beginning of your program to initialize WinDriver for your USB device, and wait for the device-attach callback. The relevant device information will be provided in the attach callback.</li>
<li>Communicate with the device using the WDU_xxx API.<ul>
<li>Once the attach callback is received, you can start using one of the <a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a> functions family to send and receive data.</li>
</ul>
</li>
<li>When you are done:<ul>
<li>Call <a class="el" href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88" title="Stops listening to devices matching the criteria, and unregisters the notification callbacks for thos...">WDU_Uninit()</a> to unregister from the device.</li>
<li>Call <a class="el" href="wdc__lib_8h_a58fa8be948e1a2042746d719983ffd2e.html#a58fa8be948e1a2042746d719983ffd2e" title="Closes the WDC WinDriver handle (acquired and stored by a previous call to WDC_DriverOpen()) and unin...">WDC_DriverClose()</a> to close the handles to WinDriver and the WDC library.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ch7_3_4_configure_and_build_your_code"></a>
7.3.4. Configure and Build Your Code</h2>
<p >After including the required files and writing your code, make sure that the required build flags and environment variables are set, then build your code.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;When developing a driver for a 64-bit platform, your project or makefile must include the <code>KERNEL_64BIT</code> preprocessor definition. In the makefiles, the definition is added using the -D flag: <code>-DKERNEL_64BIT</code>. The sample and wizard-generated Linux and Windows GCC makefiles and the Windows MS Visual Studio projects, in the 64-bit WinDriver toolkit, already include this definition. </p>
</blockquote>
</blockquote>
<p>Before building your code, verify that the WD_BASEDIR environment variable is set to the location of the of the WinDriver installation directory. On Windows and Linux you can define the WD_BASEDIR environment variable globally: for Windows — refer to the Windows WD_BASEDIR note in <a class="el" href="ch3_installing_windriver.html#ch3_2_1_windows_windriver_installation_instructions">3.2.1. Windows WinDriver Installation Instructions</a>; for Linux - refer to <a class="el" href="ch3_installing_windriver.html#ch3_2_2_linux_windriver_installation_instructions">3.2.2. Linux WinDriver Installation Instructions</a>.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<p >&gt;If you have renamed your driver make sure you've added <code>-DWD_DRIVER_NAME_CHANGE</code> to your makefile (More information on Driver Renaming is available on <a class="el" href="ch17_driver_installation_advanced_issues.html">Chapter 17: Driver Installation — Advanced Issues</a>). </p>
</blockquote>
<h1><a class="anchor" id="ch7_4_upgrading_a_driver"></a>
7.4. Upgrading a Driver</h1>
<p >This section is meant for users that already have code written using previous versions of WinDriver and wish to upgrade it to link against the current version of WinDriver.</p>
<h2><a class="anchor" id="ch7_4_1_regenerating_code_and_gradually_merging"></a>
7.4.1. Regenerating code and gradually merging</h2>
<p >If your code is very old, the <b>most recommended</b> method is to generate a new project for your device using the DriverWizard of the new WinDriver version and gradually merge all device-specific code from your legacy code into the generated skeletal code.</p>
<p >This is the recommeneded method as it allows you to make sure that the driver still works and compiles correctly step by step, and stop and debug at any moment that behavior is not as desired (As opposed to trying to compile an old code against the new WinDriver version, where it may be harder to just get it to compile). Most of the steps in this chapter will happen by themselves/be skipped if you choose to follow the first method.</p>
<h2><a class="anchor" id="ch7_4_2_checklist_for_driver_code_upgrade"></a>
7.4.2. Checklist for Driver Code upgrade</h2>
<p >If you must not regenerate code with the wizard as described in the previous section, the following is a list of action items to verify when upgrading a WinDriver based code.</p>
<h3><a class="anchor" id="ch7_4_2_1_register_your_new_license"></a>
7.4.2.1 Register Your New License</h3>
<p >If you are using a registered version of WinDriver, contact Jungo Connectivity at <a href="#" onclick="location.href='mai'+'lto:'+'wd_'+'li'+'cen'+'se'+'@ju'+'ng'+'o.c'+'om'; return false;">wd_li<span class="obfuscator">.nosp@m.</span>cens<span class="obfuscator">.nosp@m.</span>e@jun<span class="obfuscator">.nosp@m.</span>go.c<span class="obfuscator">.nosp@m.</span>om</a> to acquire a WinDriver license registration string for the new version. Then register the new license from DriverWizard File/Register WinDriver and from your code.</p>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;If you have a valid license subscription you are are entitled to receive a new license free of charge. In case you do not have such a plan, contact <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@ju'+'ng'+'o.c'+'om'; return false;">sales<span class="obfuscator">.nosp@m.</span>@jun<span class="obfuscator">.nosp@m.</span>go.co<span class="obfuscator">.nosp@m.</span>m</a> to request a temporary license that will allow you to evaluate the new version. </p>
</blockquote>
</blockquote>
<ul>
<li>Modify the driver code to register your new license — i.e., replace the license string in the call to <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> (USB) / <a class="el" href="wdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f.html#afe495f80d709b330bb26a80756cd9f9f" title="Opens and stores a handle to WinDriver&#39;s kernel module and initializes the WDC library according to t...">WDC_DriverOpen()</a> (PCI/ISA — WDC API) / <a class="el" href="windrvr_8h_a7d44fc6d31627ded58bfd36543909464.html#a7d44fc6d31627ded58bfd36543909464" title="Transfers the license string to the WinDriver kernel module When using the high-level WDC library API...">WD_License()</a> (low-level API) from your code.</li>
<li>PCI users — if you created a Kernel PlugIn driver, make sure to also update the license string in your Kernel PlugIn code.</li>
</ul>
<h3><a class="anchor" id="ch7_4_2_2_conform_to_api_updates"></a>
7.4.2.2 Conform to API Updates</h3>
<p >Some functions and APIs have changed in the course of the years, make sure your WDAPI function calls are correctly formulated.</p>
<p >Linking your projects with the high-level WinDriver-API DLL / shared object — <code>wdapi&lt;version&gt;</code> (version 8.x+) / <code>wd_utils</code> (version 7.x) — frees you of the need to include the source files from the <code>WinDriver/src/wdapi</code> directory (version 8.x+) / <code>WinDriver/src</code> directory (version 7.x) in your project.</p>
<p >In version 8.0.0 the name of the DLL/shared object module was changed from <code>wd_utils</code> to <code>wdapi(version)</code> (e.g. <code>wdapi1440</code> in version 14.4.0) as part of the addition of versioning support to this module. This enables you to upgrade your driver, including the DLL/shared object, without worrying about the possible effects on other drivers, developed with earlier versions of WinDriver, which may be using the same module.</p>
<p >On Windows, in version 8.x and newer, you can use the WDAPI DLL — <code>wdapi&lt;version&gt;.dll</code> <br  />
 (found in the <code>WinDriver\redist</code> directory) by linking your project with the <br  />
 <code>WinDriver\lib\&lt;CPU&gt;\wdapi&lt;version&gt;.lib</code> library <br  />
 (e.g. <code>WinDriver\lib\x86\wdapi1511.lib</code>) — for MS Visual Studio(Visual C++) projects. Similarly, the name of the WinDriver .NET API DLL changed in version 8.0.0 from <code>wdapi_dotnet.dll</code> to <code>wdapi&lt;version&gt;_dotnet.dll</code> (e.g.<code>wdapi1511_dotnet.dll</code>), and the DLL was moved to the <code>WinDriver\lib\&lt;CPU&gt;\&lt;.NET version&gt;\directory</code> (e.g., <code>WinDriver\lib\x86\4\</code>).</p>
<p >On Unix based OSes, such as Linux, MacOS and Solaris (Solaris was supported until 9.0.1), in version 8.x and newer you can use <code>libwdapi&lt;version&gt;.so</code> by linking your driver project with <code>WinDriver/lib/libwdapi&lt;version&gt;.so</code> (e.g. <code>libwdapi800.so</code> in WinDriver version 8.0.0). To link your Linux project with this shared object, add <code>wdapi&lt;version&gt;</code> to the makefile’s link flag (<code>LFLAGS += -l wdapi&lt;version&gt;</code>; e.g., <code>LFLAGS += -l wdapi800</code>), instead of listing all the source files from the <code>WinDriver/src/wdapi</code> directory (previously <code>WinDriver/src/</code> — see below) in the makefile (under the <code>SRCS</code> flag). On all platforms, the sample and generated DriverWizard projects demonstrate how to correctly link the project with the relevant DLL/shared object for your WinDriver version and target OS.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;If your code uses the high-level WinDriver-API DLL / shared object, you will need to distribute <code>wdapi&lt;version&gt;.dll</code> (version 8.x+) / <code>wd_utils.dll</code> (version 7.x) — for Windows, or <code>wdapi&lt;version&gt;.so</code> (version 8.x+) / <code>libwd_utils.so</code> (version 7.x) — for Linux and Solaris, with your driver. Windows .NET users should also distribute <code>wdapi&lt;version&gt;_dotnet.dll</code>. </p>
</blockquote>
</blockquote>
<p><b>WinDriver source files location changes</b></p>
<p >In version 8.0.0 the WinDriver C source files were moved from the <code>WinDriver/src</code> directory to the <code>WinDriver/src/wdapi/</code> directory. The .NET source files were moved from the <code>WinDriver/wdapi.net/</code> directory to the <code>WinDriver/src/wdapi.net/</code> directory.</p>
<p >If you have selected to upgrade your version 6.2.x project to use the <code>wdapi</code> (version 8.x+) DLL/shared object, this should not normally affect you. However, if your project directly includes WinDriver source files, you may need to modify your project/make file to point to the new source files location.</p>
<p ><b>Update your project’s files search paths</b></p>
<p >Beginning with version 7.0.1, the include path in the WinDriver project/make files contains the path to the <code>WinDriver/</code> and <code>WinDriver/include/</code> directories, and the <code>#include</code> statements in the WinDriver source files and generated DriverWizard code were consequently modified to indicate only the name of the header file to include, instead of the full/relative path to the file (as done in earlier versions). In light of these changes, when rebuilding a driver project from version 7.0.0 or earlier of WinDriver with the source files from version 7.0.1 or newer, you may need to modify your project/make file and add the path to the <code>WinDriver/</code> and <code>WinDriver/include/</code> directories to the project’s include path in order to successfully build the project.</p>
<p >For USB, beginning with version 7.0.0 of WinDriver, if you have created a console driver application/DLL/shared object that calls functions implemented in <code>WinDriver/samples/c/shared/usb_diag_lib.c</code> (as is the case for the sample and generated WinDriver USB diagnostic driver projects), to build your project with the <code>usb_diag_lib.c</code> file from the new version you must add the new <code>WinDriver/samples/c/shared/diag_lib.c</code> file to your project. For PCI/ISA users, beginning with version 7.0.0 WinDriver features the high-level WDC library, which provides convenient wrapper APIs to the standard WinDriver PCI/ISA APIs. (This library is part of the <code>wdapi&lt;version&gt;</code> (v8.x+) / shared object (see above; the source files are found under the <code>WinDriver/src/wdapi</code> directory (v8.x+) . The WDC APIs are documented in this manual. The generated DriverWizard v7.x+ projects use the WDC APIs instead of the low-level WD_xxx APIs. The WDC APIs are also used from the v7.x+ <code>pci_diag</code>, <code>pci_dump</code> and PLX samples. Since WDC mainly provides wrappers to the standard WinDriver APIs, which are still supported, you do not need to modify your old code to use the new WDC library. Should you select to upgrade your code to use the WDC APIs, you can examine the new samples and generated code and compare them to those from your old WinDriver version for a better understanding of how to use the new APIs.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;To use the WDC APIs you will need to either include the relevant <code>wdc_xxx.c</code> source files from the <code>WinDriver/src/wdapi</code> directory in your project/makefile; or link your project with the <code>wdapi&lt;version&gt;</code>WinDriver high-level API DLL/shared object. </p>
</blockquote>
</blockquote>
<h3><a class="anchor" id="ch7_4_2_3-bit_os_upgrade_windows_and_linux"></a>
7.4.2.3 64-bit OS upgrade (Windows and Linux)</h3>
<p >When porting your driver from a 32-bit platform to a 64-bit platform, your project or makefile must include the <code>KERNEL_64BIT</code> preprocessor definition. In the makefiles, the definition is added using the <code>-D</code> flag: <code>-DKERNEL_64BIT</code>. The sample and wizard-generated Linux and Windows GCC makefiles and Windows MS Visual Studio projects in the 64-bit WinDriver toolkit already add this definition.</p>
<h3><a class="anchor" id="ch7_4_2_4_rename_your_driver_windows_and_linux"></a>
7.4.2.4 Rename your driver (Windows and Linux)</h3>
<p >To avoid conflicts with other WinDriver-based drivers on the target platforms, we highly recommend that you rename the default WinDriver driver module — <code>windrvr(VERSION).sys</code>(e.g., <code>windrvr1511.sys</code>) on Windows / <code>windrvr(VERSION).o/.ko</code>(e.g., <code>windrvr1511.o/.ko</code>) on Linux (or <code>windrvr6.sys</code> / <code>windrvr6.o/.ko</code> in versions 11.8.0 and older) — to a unique name, by following the instructions in (<a class="el" href="ch15_distributing_your_driver.html">Chapter 15: Distributing Your Driver</a>). The Linux USB GPL driver — <code>windrvr(VERSION)_usb.o/.ko</code> (or <code>windrvr6_usb.o/.ko</code> in version 11.8.0 and older) is automatically renamed when renaming the main WinDriver Linux driver. When creating a PCI Kernel PlugIn driver, select a unique name as well.</p>
<h3><a class="anchor" id="ch7_4_2_5_ensure_that_your_code_uses_the_correct_driver_module"></a>
7.4.2.5 Ensure that your code uses the correct driver module</h3>
<p >Verify that the call to <a class="el" href="windrvr_8h_aa9bbb693e0e73c7bc1aa910109be8b8c.html#aa9bbb693e0e73c7bc1aa910109be8b8c" title="Sets the name of the WinDriver kernel module, which will be used by the calling application.">WD_DriverName()</a> in your driver code (if exists) uses the new driver-module name — <code>windrvr(VERSION)</code> or your renamed version of this driver. In version 11.9.0 of WinDriver the default WinDriver driver-module name changed from <code>windrvr6</code> to <code>windrvr(VERSION)</code>(e.g., <code>windrvr1511</code>). Consequently, when using the default driver-module name old projects need to be updated to use the default name from the newer version. If you use the generated DriverWizard code or one of the samples from the new WinDriver version, the code will already use the default driver name from the new version. Also, if your code is based on generated/sample code from an earlier version of WinDriver, rebuilding the code with <code><a class="el" href="windrvr_8h.html">windrvr.h</a></code> from the new version is sufficient to update the code to use the new default driver-module name (due to the use of the <code>WD_DEFAULT_DRIVER_NAME_BASE</code> definition). If you elect to rename the WinDriver driver module, ensure that your code calls <a class="el" href="windrvr_8h_aa9bbb693e0e73c7bc1aa910109be8b8c.html#aa9bbb693e0e73c7bc1aa910109be8b8c" title="Sets the name of the WinDriver kernel module, which will be used by the calling application.">WD_DriverName()</a> with your custom driver name. If you rename the driver from the new version to a name already used in your old project, you do not need to modify your code. To apply a driver name change — whether using the default driver name or a custom name — your user-mode driver project must be built with the <code>WD_DRIVER_NAME_CHANGE</code> preprocessor flag (e.g., <code>-DWD_DRIVER_NAME_CHANGE</code>).</p>
<h3><a class="anchor" id="ch7_4_2_6_rebuild_your_updated_driver"></a>
7.4.2.6 Rebuild your updated driver</h3>
<p >Rebuild your updated driver project with the source files <b>from the new version</b>.</p>
<p >PCI users who created a Kernel PlugIn driver <b>must rebuild it with the files from the new version</b> as well.</p>
<h3><a class="anchor" id="ch7_4_2_7_upgrade_your_device_inf_file_windows"></a>
7.4.2.7 Upgrade Your Device INF File (Windows)</h3>
<p >On Windows, you must create and install a new INF file for your device, which registers it with the driver module from the new version <code>windrvr(VERSION).sys</code> (e.g., <code>windrvr1511.sys</code>) / <code>windrvr6.sys</code> in version 11.8.0 and older — or your renamed version of this driver (in version 9.x and newer). You can use DriverWizard from the new version to generate the new INF file, or change the driver version in your old INF file.</p>
<h3><a class="anchor" id="ch7_4_2_8_digitally_sign_your_driver_files_windows"></a>
7.4.2.8 Digitally Sign Your Driver Files (Windows)</h3>
<p >Microsoft requires that kernel drivers to be digitally signed. Therefore, if you use any of the following driver files you must digitally sign them. A renamed version of the WinDriver kernel driver (the default WinDriver driver — <code>windrvr(VERSION).sys</code> / <code>windrvr6.sys</code> in version 11.8.0 and older — is already digitally signed), a Plug-and-Play device INF file, and/or a PCI Kernel PlugIn driver. For more info see <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_3_windows_digital_driver_signing_and_certification">17.3. Windows Digital Driver Signing and Certification</a>.</p>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;If you have any any questions in regard to driver digital signature, please send an e-mail to <a href="#" onclick="location.href='mai'+'lto:'+'Win'+'Dr'+'ive'+'r@'+'jun'+'go'+'.co'+'m'; return false;">WinDr<span class="obfuscator">.nosp@m.</span>iver<span class="obfuscator">.nosp@m.</span>@jung<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>m</a>. Our team will answer any questions you may have and provide full assistance. </p>
</blockquote>
</blockquote>
<h3><a class="anchor" id="ch7_4_2_9_upgrade_your_driver_distribution-installation_package"></a>
7.4.2.9 Upgrade Your Driver Distribution/Installation Package</h3>
<p >Create a new driver installation package that contains the relevant files from the new WinDriver distribution, depending on your hardware and target OS. Hardware and OS-specific driver distribution instructions can be found in <a class="el" href="ch15_distributing_your_driver.html">Chapter 15: Distributing Your Driver</a>. </p><blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Do not try to use WinDriver related files (shared libraries, etc.) from older versions in your new distribution package as they will not work with the newer version. </p>
</blockquote>
</blockquote>
<h3><a class="anchor" id="ch7_4_2_10_check_for_changes_in_variable_and_struct_sizes"></a>
7.4.2.10 Check for changes in variable and struct sizes</h3>
<p >Upon switching platforms, operating systems or environments, the default sizes of basic types such as <code>int</code>, <code>long</code> etc. may change. If you are changing a platform, make sure that these changes do not affect your code by careful debugging. When upgrading code from WinDriver versions older than 14.9, make sure to address the changes made to the <code>DWORD</code> typedef, which is widely used in WinDriver's sample and generated code. For more information, see <a class="el" href="ch7_developing_a_driver.html#ch7_5_2-bit_and_32-bit_data_types">7.5.2 64-Bit and 32-Bit Data Types</a>.</p>
<h1><a class="anchor" id="ch7_5-bit_applications_on_64-bit_windows_and_linux_platforms"></a>
7.5. 32-Bit Applications on 64-Bit Windows and Linux Platforms</h1>
<p >By default, applications created using the 64-bit versions of WinDriver are 64-bit applications, and application created using the 32-bit versions of WinDriver are 32-bit applications. However, you can also use the 64-bit WinDriver versions to create 32-bit applications that will run on the supported Windows and Linux 64-bit platforms.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;WinDriver for MacOS currently supports only 64-bit applications. </p>
</blockquote>
</blockquote>
<p>We recommend avoiding compiling your applications in this manner unless you have to, as this might introduce a performance decrease for your driver.</p>
<p >In the following documentation, (WD64) signifies the path to a 64-bit WinDriver installation directory for your target operating system, and (WD32) signifies the path to a 32-bit WinDriver installation directory for the same operating system.</p>
<p >To create a 32-bit application for 64-bit Windows or Linux platforms, using the 64-bit version of WinDriver, do the following:</p>
<ul>
<li>Create a WinDriver application, as outlined in <a class="el" href="ch6_using_driverwizard.html">Chapter 6: Using DriverWizard</a> (e.g., by generating code with DriverWizard, or using one of the WinDriver samples).</li>
<li>Build the application with an appropriate 32-bit compiler for your target OS, using the following configuration:</li>
<li>Make sure that <code>KERNEL_64BIT</code> preprocessor definition is added to your project or makefile. In the makefiles, the definition is added using the -D flag <code>-DKERNEL_64BIT</code>. The sample and wizard-generated Linux and Windows GCC makefiles and the Windows MS Visual Studio projects, in the 64-bit WinDriver toolkit, already include this definition.</li>
<li>Link the application with the specific version of the WinDriver-API library/shared object for 32-bit applications executed on 64-bit platforms — <code>(WD64)\lib\amd64\x86\wdapi1511_32.lib</code> on Windows / <code>(WD64)/lib/libwdapi1511_32.so</code> on Linux.</li>
</ul>
<p >The sample and wizard-generated project and make files for 32-bit applications in the 64-bit WinDriver toolkit already link to the correct library:</p>
<p >On Windows, the MS Visual Studio project files, CMake or Windows GCC makefiles are defined to link with <code>(WD64)\lib\amd64\x86\wdapi1511.lib</code>. On Linux, the installation of the 64-bit WinDriver toolkit on the development machine creates a <code>libwdapi1511.so</code> symbolic link in the <code>/usr/lib</code> directory — which links to <code>(WD64)/lib/libwdapi1511_32.so</code> — and in the <code>/usr/lib64</code>directory — which links to <code>(WD64)/lib/libwdapi1511.so</code> (the 64-bit version of this shared object).</p>
<p >The sample and wizard-generated WinDriver makefiles rely on these symbolic links to link with the appropriate shared object, depending on whether the code is compiled using a 32-bit or 64-bit compiler.</p>
<p >When distributing your application to target 64-bit platforms, you need to provide with it the WinDriver-API DLL/shared object for 32-bit applications executed on 64-bit platforms — <code>(WD64)\redist\wdapi1511_32.dll</code> on Windows <code>/(WD64)/lib/libwdapi1511_32.so</code> on Linux. The installation on the target should copy the renamed DLL/shared object to the relevant OS directory — <code>\windir%\sysWOW64</code> on Windows or <code>/usr/lib</code> on Linux. All other distribution files are the same as for any other 64-bit WinDriver driver distribution.</p>
<p >An application created using the method described in this section will not work on 32-bit platforms. A WinDriver application for 32-bit platforms needs to be compiled without the <code>KERNEL_64BIT</code> definition; it needs to be linked with the standard 32-bit version of the WinDriver-API library/shared object from the 32-bit WinDriver installation(<code>(WD32)\lib\x86\wdapi1511.lib</code> on Windows / <code>(WD32)/lib/libwdapi1511.so</code> on Linux); and it should be distributed with the standard 32-bit WinDriver-API DLL/shared object (<code>(WD32)\redist\wdapi1511.dll</code> on Windows / <code>(WD32)/lib/libwdapi1511.so</code> on Linux) and any other required 32-bit distribution file.</p>
<h2><a class="anchor" id="ch7_5_1_developing_a_32-bit_application_for_both_32-bit_and_64-bit_platforms"></a>
7.5.1. Developing a 32-Bit Application for Both 32-Bit and 64-Bit Platforms</h2>
<p >If you have both 64-bit and 32-bit WinDriver installations, you can also create a single 32-bit application that can be executed on both 32-bit and64-bit platforms. This can be done using the following method:</p>
<ul>
<li>Create a DLL (on Windows) or a shared object (on Linux) that concentrates the calls to the WinDriver APIs. If you created a WinDriver application using the generated DriverWizard code or one of the WinDriver samples, convert this application to a DLL/shared object.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;When using DriverWizard to generate PCI driver code for Windows MS Visual Studio, you have the option to generate the library code as a DLL (for both 32-bit and 64-bit environments). </p>
</blockquote>
</blockquote>
<ul>
<li>Compile two versions of your DLL/shared object:</li>
</ul>
<p >A version for 32-bit platforms: This version should be compiled using a 32-bit compiler, without the KERNEL_64BIT definition, and linked with the standard 32-bit WinDriver-API library/shared object from the 32-bit WinDriver installation — <code>&lt;WD32&gt;\lib\x86\wdapi&lt;ver&gt;.lib</code> on Windows (e.g.,<code>C:\WinDriver\lib\x86\wdapi1200.lib</code>) /<code>&lt;WD32&gt;/lib/libwdapi&lt;ver&gt;.so</code> on Linux (e.g.,<code>~/WinDriver/lib/libwdapi1200.so</code>). A version for 64-bit platforms: This version should be compiled using a 32-bit compiler, with the KERNEL_64BIT definition, and linked with the standard 32-bit WinDriver-API library/shared object from the 64-bit WinDriver installation — <code>&lt;WD64&gt;\lib\amd64\x86\wdapi&lt;ver&gt;_32.lib</code> on Windows (e.g., <code>C:\WinDriver64\lib\x86\wdapi1200.lib</code>) / <code>&lt;WD64&gt;/lib/libwdapi&lt;ver&gt;_32.so</code> on Linux (e.g., <code>~/WinDriver64/lib/libwdapi1200_32.so</code>) (see details above regarding compilation of 32-bit applications for 64-bit platforms).</p>
<ul>
<li>Write a 32-bit application that communicates with WinDriver via the DLL/shared object that you created: the application should be implemented to load the relevant version of the DLL/shared object — 32-bit or 64-bit — depending on the platform on which it is run.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;This application should be compiled using an appropriate32-bit compiler, without the KERNEL_64BIT definition. </p>
</blockquote>
</blockquote>
<p>When distributing a driver that was developed using this method, be sure to distribute the relevant files for each target platform:</p>
<p >For 32-bit platforms, distribute the application together with the 32-bit version of your WinDriver-wrapper DLL/shared object, and with the standard 32-bit files from the 32-bitWinDriver installation, including the 32-bit WinDriver DLL/shared object <br  />
 (<code>&lt;WD32&gt;\redist\wdapi1511.dll</code> on Windows / <code>&lt;WD32&gt;/lib/libwdapi1511.so</code> on Linux). <br  />
 For 64-bit platforms, distribute the application together with the 64-bit version of your WinDriver-wrapper DLL/shared object, and with the standard 64-bit files from the 64-bitWinDriver installation, including the 64-bit WinDriver DLL/shared object <br  />
 (<code>&lt;WD64&gt;\redist\wdapi1511.dll</code> on Windows / <code>&lt;WD64&gt;/lib/libwdapi1511.so</code> on Linux).</p>
<h2><a class="anchor" id="ch7_5_2-bit_and_32-bit_data_types"></a>
7.5.2 64-Bit and 32-Bit Data Types</h2>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Since WinDriver 15.00 The DWORD typedef is <b>ALWAYS</b> 32 bits wide. </p>
</blockquote>
</blockquote>
<p>On all previous versions the previous table has applied: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><b>Operating System</b>   </th><th class="markdownTableHeadLeft"><b>DWORD width</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Windows (32 and 64 bits)   </td><td class="markdownTableBodyLeft">4 bytes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Linux (32 bits)   </td><td class="markdownTableBodyLeft">4 bytes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Linux (64 bits)   </td><td class="markdownTableBodyLeft">8 bytes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">MacOS (64 bits)   </td><td class="markdownTableBodyLeft">8 bytes   </td></tr>
</table>
<p >When upgrading existing code from a version lower than 15.00, make sure that your code does not use <code>DWORD</code> variables for holding addresses or hardware related data.</p><ul>
<li>If a variable used to be 64 bits wide in older versions and you need to keep it 64 bit wide, define it as <code>UINT64</code> instead.</li>
<li>If a variable is used to hold data which is related to a WinDriver API of size <code>DWORD</code> (i.e. <code>dwOptions</code>), you could keep it defined as <code>DWORD</code>.</li>
</ul>
<h1><a class="anchor" id="ch7_6_windriver_dotnet_apis_in_powershell"></a>
7.6. WinDriver .NET APIs in PowerShell</h1>
<p >Microsoft defines PowerShell as “a task-based command-line shell and scripting language built on .NET. PowerShell helps system administrators and power-users rapidly automate tasks that manage operating systems and processes.”</p>
<p >The advantages of using WinDriver with PowerShell are:</p>
<ul>
<li>PowerShell comes built-in in all modern Windows systems. No need to install any additional software to use it.</li>
<li>No need to compile your code as it is a scripting language.</li>
<li>The ability to easily combine WinDriver with your scripts or with any other .NET based library.</li>
</ul>
<p >WinDriver has been providing its .NET wrapper DLL <code>wdapi_dotnet1511.dll</code> (<code>1511</code> stands for the version number) for many years. Using PowerShell’s built-in .NET support you can easily open this DLL and call API functions by using the following code from PowerShell’s command line:</p>
<ul>
<li>Load the WinDriver .NET DLL using namespace Jungo.wdapi_dotnet:</li>
</ul>
<div class="fragment"><div class="line">$wdapi_dotnet = [Reflection.Assembly]::LoadFile($Env:WD_BASEDIR + &quot;\lib\amd64\wdapi_netcore1511.dll&quot;)</div>
</div><!-- fragment --><ul>
<li>Open WinDriver:</li>
</ul>
<div class="fragment"><div class="line">[windrvr_decl]::WD_DriverName(&quot;YOUR_DRIVER_NAME&quot;)</div>
<div class="line">[wdc_lib_decl]::WDC_DriverOpen([wdc_lib_consts]::WDC_DRV_OPEN_DEFAULT, &quot;YOUR_LICENSE_STRING&quot;)</div>
</div><!-- fragment --><ul>
<li>Open a device - by default the slot will be set to 0,0,0,0:</li>
</ul>
<div class="fragment"><div class="line">$slot = New-Object -TypeName &quot;Jungo.wdapi_dotnet.WD_PCI_SLOT&quot;</div>
<div class="line">$deviceInfo = New-Object -TypeName &quot;Jungo.wdapi_dotnet.WD_PCI_CARD_INFO&quot;</div>
<div class="line">$deviceInfo.pciSlot = $slot</div>
<div class="line">[wdc_lib_decl]::WDC_PciGetDeviceInfo($deviceInfo)</div>
</div><!-- fragment --><ul>
<li>Device context will be set to NULL for simplicity of sample:</li>
</ul>
<div class="fragment"><div class="line">$pDevCtx = $NULL</div>
<div class="line">$dev = New-Object -TypeName &quot;Jungo.wdapi_dotnet.WDC_DEVICE&quot;</div>
<div class="line">[wdc_lib_decl]::WDC_PciDeviceOpen([ref]$dev, $pDeviceInfo, $pDevCtx)</div>
</div><!-- fragment --><ul>
<li>Read from the device (or any other WinDriver API usage):</li>
</ul>
<div class="fragment"><div class="line">[wdc_lib_decl]::WDC_ReadAddr32($dev.hDev, 0, 0x60, 0x1)</div>
</div><!-- fragment --><ul>
<li>Cleanup:</li>
</ul>
<div class="fragment"><div class="line">[wdc_lib_decl]::WDC_PciDeviceClose($dev.hDev)</div>
<div class="line">[wdc_lib_decl]::WDC_DriverClose()</div>
</div><!-- fragment --><p >There is a complete PowerShell Script utilizing WinDriver’s API. Jungo provides a sample for PowerShell based on our pci_diag sample application. It is located in <code>WinDriver\samples\powershell\pci_diag</code>. Make sure you allow Powershell to run scripts, then do as follows:</p>
<ul>
<li>Open PowerShell as an administrator and run:</li>
</ul>
<div class="fragment"><div class="line">Set-ExecutionPolicy RemoteSigned</div>
</div><!-- fragment --><ul>
<li>To run pci_diag for PowerShell type:</li>
</ul>
<div class="fragment"><div class="line">cd $Env:WD_BASEDIR\samples\powershell\pci_diag./pci_diag</div>
</div><!-- fragment --><blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Currently the sample does not yet support the following features: Power events, IPC, Kernel PlugIn, USB, Shared Kernel Buffer. WinDriver’s API and pci_diag work on both the PowerShell command line and the PowerShell ISE IDE. Starting with WinDriver 14.70, WinDriver’s .NET 5 API can be used in on Linux or MacOSX as well, using PowerShell 7 or higher. </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch7_7_windriver_server_api"></a>
7.7. WinDriver Server API</h1>
<p >The following WinDriver Server APIs are not part of the standard WinDriver API set. Also, they are not included in the standard version of WinDriver.</p>
<p >However, they are part of “WinDriver for Server” API and require “WinDriver for Server” separate license. “WinDriver for Server” APIs are included in WinDriver evaluation version for <b>evaluation only</b>.</p>
<p >IPC API (Inter-process communication):</p><ul>
<li><code><a class="el" href="wds__lib_8h_a380d7301f68cdeefd1ee8793a8b374eb.html#a380d7301f68cdeefd1ee8793a8b374eb" title="Registers an application with WinDriver IPC.">WDS_IpcRegister()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_a6a866b8df15e7b0fb02078b05b4e1e69.html#a6a866b8df15e7b0fb02078b05b4e1e69" title="This function enables the user application to unregister with WinDriver IPC.">WDS_IpcUnRegister()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_a0b32ad4bed565b492106fca29272eba4.html#a0b32ad4bed565b492106fca29272eba4" title="Enables the application to check if it is already registered with WinDriver IPC.">WDS_IsIpcRegistered()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_ac800406d9a87d40d91edcb08083e44fe.html#ac800406d9a87d40d91edcb08083e44fe" title="Scans and returns information of all registered processes that share the application process groupID ...">WDS_IpcScanProcs()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_ab972dc5b019f88943a4b42c3a252a967.html#ab972dc5b019f88943a4b42c3a252a967" title="Sends a message to all processes that were registered with the same group ID as the sending process.">WDS_IpcMulticast()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_aee68dceb1d68ba938849039cecdfbb92.html#aee68dceb1d68ba938849039cecdfbb92" title="Sends a message to all processes that registered with the same sub-group ID.">WDS_IpcSubGroupMulticast()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_a414d35a067bd99be0512d9805810f6f6.html#a414d35a067bd99be0512d9805810f6f6" title="Sends a message to a specific process with WinDriver IPC unique ID.">WDS_IpcUidUnicast()</a></code></li>
</ul>
<p >Buffer sharing API:</p><ul>
<li><code><a class="el" href="wdc__lib_8h_a8369d86288b62fe93791febc6e3f55a8.html#a8369d86288b62fe93791febc6e3f55a8" title="Retrieves a contiguous DMA buffer which was allocated by another process.">WDC_DMABufGet()</a></code></li>
<li><code><a class="el" href="wds__lib_8h_a350377180f47fe81b8282a61566390fb.html#a350377180f47fe81b8282a61566390fb" title="Allocates a memory buffer that can be shared between the user mode and the kernel mode (&quot;shared buffe...">WDS_SharedBufferAlloc()</a></code> (when using <code>KER_BUF_ALLOC_NON_CONTIG</code> flag)</li>
<li><code><a class="el" href="wds__lib_8h_a7ba0155bee47774551439957fa42fa6e.html#a7ba0155bee47774551439957fa42fa6e" title="Retrieves a shared buffer which was allocated by another process.">WDS_SharedBufferGet()</a></code> (IPC license)</li>
</ul>
<p >PCI devices scanning:</p><ul>
<li><code><a class="el" href="wdc__lib_8h_a15790844cb433fbaaf8c390a368d0efb.html#a15790844cb433fbaaf8c390a368d0efb" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevices()</a></code> (for more than 100 devices)</li>
<li><code><a class="el" href="wdc__lib_8h_ad98a7717a34c7ed811312ee101a58306.html#ad98a7717a34c7ed811312ee101a58306" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevicesByTopology()</a></code> (for more than 100 devices)</li>
<li><code><a class="el" href="wdc__lib_8h_aa14e06ef5740cec7650a78ecb6f87e03.html#aa14e06ef5740cec7650a78ecb6f87e03" title="Scans the PCI bus for all devices with the specified vendor and device ID combination that have been ...">WDC_PciScanRegisteredDevices()</a></code> (for more than 100 devices)</li>
</ul>
<p >SR-IOV API(Linux Only):</p><ul>
<li><code><a class="el" href="wdc__lib_8h_ad6e718316cb00a7771fcf3b5bd7cb14e.html#ad6e718316cb00a7771fcf3b5bd7cb14e" title="SR-IOV API functions are not part of the standard WinDriver API, and not included in the standard ver...">WDC_PciSriovEnable()</a></code></li>
<li><code><a class="el" href="wdc__lib_8h_a20a87513fc981dc637f15395cd9a5eea.html#a20a87513fc981dc637f15395cd9a5eea" title="Disables SR-IOV for a supported device and removes all the assigned VFs.">WDC_PciSriovDisable()</a></code></li>
<li><code><a class="el" href="wdc__lib_8h_a574895ff192728d02d33e5f039d63a83.html#a574895ff192728d02d33e5f039d63a83" title="Gets the number of virtual functions assigned to a supported device.">WDC_PciSriovGetNumVFs()</a></code></li>
</ul>
<h1><a class="anchor" id="ch7_8_faq_developing_a_driver"></a>
7.8. FAQ</h1>
<h2><a class="anchor" id="ch7_8_1_using_windriver_to_build_a_gui_application"></a>
7.8.1. Using WinDriver to build a GUI Application</h2>
<p >Although most samples provided in the WinDriver package are console-mode applications, it is possible to integrate WinDriver's API into Graphic User Interface (GUI) applications. Some examples of GUI applications that were built with WinDriver are our DriverWizard and Debug Monitor (built with the Qt Framework), and also our .NET GUI samples/generated codes.</p>
<h2><a class="anchor" id="ch7_8_2_can_windriver_handle_multiple_devices_of_different_or_similar_types_at_the_same_time"></a>
7.8.2. Can WinDriver handle multiple devices, of different or similar types, at the same time?</h2>
<p >It is possible. For the sake of simplicity, our C, Java and Python PCI samples only allow opening one device at a time, but it is indeed possible in these languages as well. Our USB samples for C, Java and Python allow opening multiple devices at the same time. Our .NET samples also allow opening multiple devices at the same time.</p>
<p >Generally, each device controlled by WinDriver has its own unique handle, allowing applications to open multiple handles at the same time if needed.</p>
<h2><a class="anchor" id="ch7_8_3_can_i_run_two_different_device_drivers_both_developed_with_windriver_on_the_same_machine"></a>
7.8.3. Can I run two different device drivers, both developed with WinDriver, on the same machine?</h2>
<p >Yes. You can run several WinDriver-based applications simultaneously on the same machine. It is strongly recommended that the WinDriver Kernel Module will be renamed in that case.</p>
<h2><a class="anchor" id="ch7_8_4_can_windriver_group_i-o_and_memory_transfers"></a>
7.8.4. Can WinDriver group I/O and memory transfers?</h2>
<p >Yes. Using WinDriver, you can group I/O and memory transfers by calling <code><a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a></code>, which can perform multiple transfers in one call. However, Jungo generally recommeds using the High-Level API (WDC_xxx) for I/O.</p>
<p >Note that you can also access the memory directly from your user-mode application using the virtual user-mode mapping of the physical address, which is returned by or <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> in <code>(((PWDC_DEVICE)hDev)-&gt;cardReg.Card.Item[i].I.Mem.pUserDirectAddr</code> or <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> in <code>cardReg.Card.Item[i].I.Mem.pUserDirectAddr</code>, where <code>i</code> is the index item of the relevant memory item in the <a class="el" href="structWD__ITEMS.html">WD_ITEMS</a> <code>Item</code> array.</p>
<h2><a class="anchor" id="ch7_8_5_i_need_to_define_more_than_20_hardware_items_i-o_memory_and_interrupts_for_my_isa_card_therefore_i_increased_the_value_of_wd_card_items_in_the_windrvr_h_header_file_due_to_the_definition_of_the_item_member_of_the_wd_card_structure_as_an_array_of_wd_card_items_wd_items_structures_but_now_wd_cardregister_will_not_work_why"></a>
7.8.5. I need to define more than 20 "hardware items" (I/O, memory, and interrupts) for my ISA card. Therefore, I increased the value of WD_CARD_ITEMS in the windrvr.h header file (due to the definition of the Item member of the WD_CARD structure as an array of WD_CARD_ITEMS WD_ITEMS structures). But now WD_CardRegister() will not work. Why?</h2>
<p >If you need to define more than <code>WD_CARD_ITEMS</code> items for your card (currently 128 items, according to the definition of WD_CARD_ITEMS in <code><a class="el" href="windrvr_8h.html">windrvr.h</a></code>), do not modify the value of <code>WD_CARD_ITEMS</code> in the code, but instead, simply call <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> several times from your code, with different items each time. It is not mandatory to lock all the resources on a specific card with a single <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> call. Alternatively, consider grouping several memory/IO address ranges into a single BAR definition, so that the overall resources item count does not exceed the default 20 items limit.</p>
<p >We highly recommend against changing anything in <code><a class="el" href="windrvr_8h.html">windrvr.h</a></code>. The effect will certainly not be what you expect and it could be potentially disastrous.</p>
<h2><a class="anchor" id="ch7_8_6_i_have_a_windriver_based_application_running_on_a_certain_operating_system_how_do_i_port_my_code_to_a_different_operating_system"></a>
7.8.6. I have a WinDriver based application running on a certain operating system, how do I port my code to a different operating system?</h2>
<p >WinDriver generally rids you of the need to do any changes in your program's code. Of course some OS specific functions that you have been using that are not from the WinDriver API might not work anymore (i.e. Win32 functions that are not provided by POSIX, or the other way around), but this is why we recommend trying to stick only to cross-platform standard functions in your C code and to the WinDriver API. There are about 10% of WinDriver's API features that are not cross platform, but usually this could be overcome with different alternatives. If this could not be overcome, contact Jungo Support for assistance.</p>
<p >The recommended and easiest way to shift between platforms is to generate a CMakeLists.txt file for your project using the DriverWizard. This will allow you to port the code over all supported OSes and makes the porting a much easier task, assuming you've installed CMake on your target development machine.</p>
<p >On supported languages other than C, porting should be even easier as these languages support cross-platform use inherently.</p>
<p >Assuming you're using a renamed driver - a step you will have to go through is creating a new project from the DriverWizard in your new operating system. This will create a renamed driver for your target platform (i.e. if you had a .sys file for your driver on a Windows system, then on Linux the wizard would create a .ko file, etc.).</p>
<p >As described in <a class="el" href="ch7_developing_a_driver.html#ch7_4_1_regenerating_code_and_gradually_merging">7.4.1. Regenerating code and gradually merging</a>, the best way for this kind of porting is first to generate new code with the DriverWizard, make sure that it works without any modifications, and then gradually merge your code from the other operating system into your new OS code. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
