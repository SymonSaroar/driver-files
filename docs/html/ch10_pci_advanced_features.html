<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 10: PCI Advanced Features"/>
<title>Jungo WinDriver: Chapter 10: PCI Advanced Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch10_pci_advanced_features.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 10: PCI Advanced Features </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap10"></a>This chapter covers advanced driver development issues and contains guidelines for using WinDriver to perform tasks that cannot be fully automated by the DriverWizard. Note that WinDriver's enhanced support for specific chipsets, which we discuss in [Chapter 9] (<a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">Chapter 9: Enhanced Support for Specific Chipsets</a>), includes custom APIs for performing hardware-specific tasks like DMA and interrupt handling, thus freeing developers of drivers for these chipsets from the need to implement the code for performing these tasks themselves.</p>
<h1><a class="anchor" id="ch10_1_handling_interrupts"></a>
10.1. Handling Interrupts</h1>
<p >WinDriver provides you with API, DriverWizard code generation, and samples, to simplify the task of handling interrupts from your driver.</p>
<p >If you are developing a driver for a device based on one of the <a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">enhanced-support WinDriver chipsets</a>, we recommend that you use the custom WinDriver interrupt APIs for your specific chip in order to handle the interrupts, since these routines are implemented specifically for the target hardware.</p>
<p >For other chips, we recommend that you use DriverWizard to detect/define the relevant information regarding the device interrupt (such as the interrupt request (IRQ) number, its type and its shared state), define commands to be executed in the kernel when an interrupt occurs (if required), and then generate skeletal diagnostics code, which includes interrupt routines that demonstrate how to use WinDriver's API to handle your device's interrupts, based on the information that you defined in the wizard.</p>
<p >The following sections provide a general overview of PCI/ISA interrupt handling and explain how to handle interrupts using WinDriver's API. Use this information to understand the sample and generated DriverWizard interrupt code or to write your own interrupt handler.</p>
<h2><a class="anchor" id="ch10_1_1_interrupt_handling_overview"></a>
10.1.1. Interrupt Handling — Overview</h2>
<p >PCI and ISA hardware uses interrupts to signal the host.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;In order to handle PCI interrupts correctly with WinDriver on Plug-and-Play (PnP) Windows operating systems, you must first install an INF file for the device, which registers it to work with WinDriver’s PnP driver — windrvr&lt;version&gt;.sys (e.g., <code>windrvr1511.sys</code>). </p>
</blockquote>
</blockquote>
<p>There are two main methods of PCI interrupt handling:</p>
<ul>
<li><b>Legacy Interrupts</b>: The traditional interrupt handling, which uses a line-based mechanism. Inthis method, interrupts are signaled by using one or more external pins that are wired "out-of-band", i.e., separately from the main bus lines. Legacy interrupts are divided into two groups:<ul>
<li><b>Level-sensitive interrupts</b>: These interrupts are generated as long as the physical interrupt signal is high. If the interrupt signal is not lowered by the end of the interrupt handling in the kernel, the operating system will call the kernel interrupt handler repeatedly, causing the host platform to hang. To prevent such a situation, the interrupt must be acknowledged (cleared) by the kernel interrupt handler immediately when it is received. Therefore, WinDriver requires you to define an interrupt-status register that will be read/written in order to clear the interrupt. This is a precautionary measurement, because a level sensitive interrupt that is not acknowledged can hang your PC. Legacy PCI interrupts are level sensitive.</li>
<li><b>Edge-triggered interrupts</b>: These are interrupts that are generated once, when the physical interrupt signal goes from low to high. Therefore, exactly one interrupt is generated. No special action is required for acknowledging this type of interrupt. ISA/EISA interrupts are edge triggered.</li>
</ul>
</li>
<li><b>Message-Signaled Interrupts (MSI)</b>: Newer PCI bus technologies, available beginning with v2.2 of the PCI bus and in PCI Express, support Message-Signaled Interrupts (MSI). This method uses "in-band" messages instead of pins, and can target addresses in the host bridge. A PCI function can request up to 32 MSI messages. MSI and MSI-X are edge triggered and do not require acknowledgment in the kernel. Among the advantages of MSIs:<ul>
<li>MSIs can send data along with the interrupt message.</li>
<li>As opposed to legacy PCI interrupts, MSIs are not shared; i.e., an MSI that is assigned to a device is guaranteed to be unique within the system.</li>
</ul>
</li>
<li><b>Extended Message-Signaled Interrupts (MSI-X)</b> are available beginning with version 3.0 of the PCI bus. This method provides an enhanced version of the MSI mechanism, which includes the following advantages:<ul>
<li>Supports 2,048 messages instead of 32 messages supported by the standard MSI.</li>
<li>Supports independent message address and message data for each message.</li>
<li>Supports per-message masking.</li>
<li>Enables more flexibility when software allocates fewer vectors than hardware requests. The software can reuse the same MSI-X address and data in multiple MSI-X slots.</li>
</ul>
</li>
</ul>
<p >The newer PCI buses, which support MSI/MSI-X, maintain software compatibility with the legacy line-based interrupts mechanism by emulating legacy interrupts through in-band mechanisms. These emulated interrupts are treated as legacy interrupts by the host operating system.</p>
<p >WinDriver supports legacy line-based interrupts, both edge triggered and level sensitive, on all supported operating systems.</p>
<p >WinDriver also supports PCI MSI/MSI-X interrupts (when supported by the hardware).</p>
<p >WinDriver provides a single set of APIs for handling both legacy and MSI/MSI-X interrupts, as described in this manual.</p>
<h2><a class="anchor" id="ch10_1_2_windriver_interrupt_handling_sequence"></a>
10.1.2. WinDriver Interrupt Handling Sequence</h2>
<p >This section describes how to use WinDriver to handle interrupts from a user-mode application.</p>
<p >Since interrupt handling is a performance-critical task, it is very likely that you may want to handle the interrupts directly in the kernel. WinDriver's Kernel PlugIn enables you to implement kernel-mode interrupt routines. To find out how to handle interrupts from the Kernel PlugIn, please refer to <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_5_handling_interrupts_in_the_kernel_plugin">12.5.5. Handling Interrupts in the Kernel PlugIn</a>.</p>
<p >To listen to PCI interrupts with the DriverWizard, follow these steps:</p>
<ul>
<li>Define the interrupt-status register: In the DriverWizard’s <code>Registers</code> tab, select New and define a new register. You should specify the register’s name, location (i.e., offset into one of the BARs), size, and access mode (read/write). The interrupt-acknowledgment information is hardware specific. You should therefore review your hardware’s specification for the relevant data to set for your specific device.</li>
<li>Assign the interrupt-status register to your card’s interrupt: After defining the interrupt-status register, go back to the Interrupts tab and assign the interrupt that you have defined to the card’s interrupt. You should select your interrupt and click on the Edit button to display the <code>Interrupt Information</code> dialog box. Select the register you have defined from the drop-down list in the Access Register box and fill-in the additional information required for acknowledging the interrupt — i.e., read/write mode and the data (if any) to be written to the status register in order to acknowledge and clear the interrupt. You can define several commands for execution upon an interrupt, by simply clicking the <code>More</code> button in the Interrupt Information window.</li>
</ul>
<p >You should also verify that the interrupt is defined as Level Sensitive and that the <code>Shared</code> box is checked as PCI interrupts should generally be shared. This issue is also explained when clicking the <code>Help</code> button in the <code>Interrupt Information</code> dialog box.</p>
<p >You can now try to listen to the interrupts on your card with the DriverWizard, by clicking the <code>Listen to Interrupts</code> button in the <code>Interrupts</code> tab, and then generating interrupts in the hardware. The interrupts that will be received will be logged in the <code>Log</code> window. To stop listening to the interrupts, click the <code>Stop Listen to Interrupts</code> button in the Interrupts tab.</p>
<p ><b>The interrupt handling sequence using WinDriver is as follows</b>:</p>
<ul>
<li>The user calls one of WinDriver's interrupt enable functions — <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> or the low-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> or <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> functions, — to enable interrupts on the device. These functions receive an optional array of read/write transfer commands to be executed in the kernel when an interrupt occurs.</li>
</ul>
<p >Please note:</p>
<ul>
<li>When using WinDriver to handle level-sensitive interrupts, you must set up transfer commands for acknowledging the interrupt, as explained in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_6_setting_up_kernel-mode_interrupt_transfer_commands">10.1.6. Setting Up Kernel-Mode Interrupt Transfer Commands</a>.</li>
<li>Memory allocated for the transfer commands must remain available until the interrupts are disabled.</li>
</ul>
<p >When <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> or the lower-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> function is called, WinDriver spawns a thread for handling incoming interrupts. When using the low-level <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> function you need to spawn the thread yourself. WinDriver must be registered with the OS as the driver of the device before enabling interrupts. For Plug-and-Play hardware (PCI/PCI Express) on Windows platforms, this association is made by installing an INF file for the device. If the INF file is not installed, the interrupt enable function() will fail with a [WD_NO_DEVICE_OBJECT] (<a class="el" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215ca7f4acda8b84d713275f6d2cee743ad94">WD_NO_DEVICE_OBJECT</a>) error .</p>
<ul>
<li>The interrupt thread runs an infinite loop that waits for an interrupt to occur.</li>
<li>When an interrupt occurs, WinDriver executes, in the kernel, any transfer commands that were prepared in advance by the user and passed to WinDriver's interrupt-enable functions <br  />
 (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_6_setting_up_kernel-mode_interrupt_transfer_commands">10.1.6. Setting Up Kernel-Mode Interrupt Transfer Commands</a>). <br  />
 When the control returns to the user mode, the driver's user-mode interrupt handler routine (as passed to WinDriver when enabling the interrupts with <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> or <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a>) is called.</li>
<li>When the user-mode interrupt handler returns, the wait loop continues.</li>
<li>When the user no longer needs to handle interrupts, or before the user-mode application exits, the relevant WinDriver interrupt disable function should be called — <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> or the low-level <a class="el" href="windrvr__int__thread_8h_a895b7d55301d1f332fe9aa1c35800d62.html#a895b7d55301d1f332fe9aa1c35800d62">InterruptDisable()</a> or <a class="el" href="windrvr_8h_a3c20d5e5dc87e9dd52aeff38199867d1.html#a3c20d5e5dc87e9dd52aeff38199867d1" title="Disables interrupt processing.">WD_IntDisable()</a> functions, (depending on the function used to enable the interrupts).</li>
</ul>
<p >The low-level <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> WinDriver function, which is used by the high-level interrupt enable functions to wait on interrupts from the device, puts the thread to sleep until an interrupt occurs. There is no CPU consumption while waiting for an interrupt. Once an interrupt occurs, it is first handled by the WinDriver kernel, then <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> wakes up the interrupt handler thread and returns, as explained above.</p>
<p >Since your interrupt handler runs in the user mode, you may call any OS API from this function, including file-handling and GDI functions.</p>
<h2><a class="anchor" id="ch10_1_3_registering_irqs_for_non-plug-and-play_hardware"></a>
10.1.3. Registering IRQs for Non-Plug-and-Play Hardware</h2>
<p >On Windows, you may need to register an interrupt request (IRQ) with WinDriver before you can assign it to your non-Plug-and-Play device (e.g., your ISA card).</p>
<p >To register an IRQ with WinDriver on Windows, follow these steps:</p>
<ul>
<li>Open the Device Manager and select <b>View</b> | <b>Resources</b> by type.</li>
<li>Select a free IRQ from among those listed in the Interrupt request (IRQ) section.</li>
<li>Register the selected IRQ with WinDriver:<ul>
<li>Back up the files in the <code>WinDriver\redist</code> directory.</li>
<li>Edit <code>windrvr1511.inf</code>.</li>
</ul>
</li>
</ul>
<p >Add the following line in the [DriverInstall.NT] section:</p>
<div class="fragment"><div class="line">LogConfig=config_irq</div>
</div><!-- fragment --><p >Add a config_irq section (where <code>&lt;IRQ&gt;</code> signifies your selected IRQ number — e.g., 10):</p>
<div class="fragment"><div class="line">[config_irq]</div>
<div class="line">IRQConfig=&lt;IRQ&gt;</div>
</div><!-- fragment --><ul>
<li>Reinstall WinDriver by running the following from a command-line prompt (where <code>"&lt;path to windrvr1511.inf&gt;"</code> is the path to your modified WinDriver INF file):</li>
</ul>
<div class="fragment"><div class="line">wdreg -inf &lt;path to windrvr1511.inf&gt; install </div>
</div><!-- fragment --><ul>
<li>Verify that that the IRQ was successfully registered with WinDriver: Open the Device Manager and locate the WinDriver device. The device properties should have a Resources tab with the registered IRQ.</li>
</ul>
<p >This procedure registers the IRQ with the virtual WinDriver device. It is recommended that you rename the <code>windrvr1511</code> driver module, to avoid possible conflicts with other instances of WinDriver that may be running on the same machine (see <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_2_renaming_the_windriver_kernel_driver">17.2. Renaming the WinDriver Kernel Driver</a>).</p>
<p >If you rename your driver, replace references to <code>windrvr1511.inf</code> in the IRQ registration instructions above with the name of your renamed WinDriver INF file.</p>
<h2><a class="anchor" id="ch10_1_4_determining_the_interrupt_types_supported_by_the_hardware"></a>
10.1.4. Determining the Interrupt Types Supported by the Hardware</h2>
<p >When retrieving resources information for a Plug-and-Play device using <a class="el" href="wdc__lib_8h_a920d348804f4ee3aa118ebf073d33698.html#a920d348804f4ee3aa118ebf073d33698" title="Retrieves a PCI device&#39;s resources information (memory and I/O ranges and interrupt information).">WDC_PciGetDeviceInfo()</a> or the low-level <a class="el" href="windrvr_8h_a854629f70e655ff1f1592a846b5fc65f.html#a854629f70e655ff1f1592a846b5fc65f" title="Retrieves PCI device&#39;s resource information (i.e., Memory ranges, I/O ranges, Interrupt lines).">WD_PciGetCardInfo()</a> function, the function returns information regarding the interrupt types supported by the hardware. This information is returned within the dwOptions field of the returned interrupt resource (<code>pDeviceInfo-&gt;Card.Item[i].I.Int.dwOptions</code> for the WDC functions <code>pPciCard-&gt;Card.Item[i].I.Int.dwOptions</code> for the low-level functions).</p>
<p >The interrupt options bit-mask can contain a combination of any of the following interrupt type flags:</p>
<ul>
<li>[INTERRUPT_MESSAGE_X] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6d0d372ae83302a6c660d09efccfb010">INTERRUPT_MESSAGE_X</a>): Extended Message-Signaled Interrupts (MSI-X).</li>
<li>[INTERRUPT_MESSAGE] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a1665ed5bb5085d7ef8f599f70ee9e41c">INTERRUPT_MESSAGE</a>): Message-Signaled Interrupts (MSI).</li>
<li>[INTERRUPT_LEVEL_SENSITIVE] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a70e9888291492488bf56d3c328b8cbb6">INTERRUPT_LEVEL_SENSITIVE</a>): Legacy level-sensitive interrupts.</li>
<li>[INTERRUPT_LATCHED] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a2d86cbb1d12414ba0e8f9100d823bf54">INTERRUPT_LATCHED</a>): Legacy edge-triggered interrupts. The value of this flag is zero and it is applicable only when no other interrupt flag is set.</li>
</ul>
<p >The <a class="el" href="wdc__defs_8h_ab81311c2555d63e334aa886301acd73e.html#ab81311c2555d63e334aa886301acd73e" title="Get interrupt options field from device information struct pointer.">WDC_GET_INT_OPTIONS()</a> macro returns a WDC device's interrupt options bitmask. You can pass the returned bit-mask to the <a class="el" href="wdc__defs_8h_a3d9bc08458ef2caf5ac595f00c3482e5.html#a3d9bc08458ef2caf5ac595f00c3482e5" title="Returns whether the MSI/MSI-X interrupt option is set.">WDC_INT_IS_MSI()</a> macro to check whether the bit-mask contains the MSI or MSI-X flags .</p>
<p >The [INTERRUPT_MESSAGE] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a1665ed5bb5085d7ef8f599f70ee9e41c">INTERRUPT_MESSAGE</a>) <br  />
 and [INTERRUPT_MESSAGE_X] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6d0d372ae83302a6c660d09efccfb010">INTERRUPT_MESSAGE_X</a>) flags are applicable only to PCI devices.</p>
<p >The Windows APIs do not distinguish between MSI and MSI-X; therefore, on this OS the WinDriver functions set the [INTERRUPT_MESSAGE] (<a class="el" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a1665ed5bb5085d7ef8f599f70ee9e41c">INTERRUPT_MESSAGE</a>) flag for both MSI and MSI-X.</p>
<h2><a class="anchor" id="ch10_1_5_determining_the_interrupt_type_enabled_for_a_pci_card"></a>
10.1.5. Determining the Interrupt Type Enabled for a PCI Card</h2>
<p >When attempting to enable interrupts for a PCI card, WinDriver first tries to use MSI-X or MSI, if supported by the card. If this fails, WinDriver attempts to enable legacy level-sensitive interrupts.</p>
<p >WinDriver's interrupt-enable functions return information regarding the interrupt type that was enabled for the card. This information is returned within the <code>dwEnabledIntType</code> field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure that was passed to the function. When using the high-level <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> function, the information is stored within the Int field of the WDC device structure referred to by the function's hDev parameter , and can be retrieved using the <a class="el" href="wdc__defs_8h_a9dfa014282863f437e5bc45862c1bebc.html#a9dfa014282863f437e5bc45862c1bebc" title="Get type of enabled interrupt from device information struct pointer.">WDC_GET_ENABLED_INT_TYPE()</a> low-level WDC macro.</p>
<h2><a class="anchor" id="ch10_1_6_setting_up_kernel-mode_interrupt_transfer_commands"></a>
10.1.6. Setting Up Kernel-Mode Interrupt Transfer Commands</h2>
<p >When handling interrupts you may find the need to perform high-priority tasks at the kernel mode level immediately when an interrupt occurs. For example, when handling level-sensitive interrupts, such as legacy PCI interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_handling_interrupts">10.1. Handling Interrupts</a>), the interrupt line must be lowered (i.e., the interrupt must be acknowledged) in the kernel, otherwise the operating system will repeatedly call WinDriver's kernel interrupt handler, causing the host platform to hang. Acknowledgment of the interrupt is hardware-specific and typically involves writing or reading from specific runtime registers on the device.</p>
<p >WinDriver's interrupt enable functions receive an optional pointer to an array of <a class="el" href="structWD__TRANSFER.html">WD_TRANSFER</a> structures , which can be used to set up read/write transfer command from/to memory or I/O addresses on the device. The <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> function accepts this pointer and the number of commands in the array as direct parameters (<code>pTransCmds</code> and <code>dwNumCmds</code>). The low-level <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> and <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> functions receive this information within the Cmd and dwCmds fields of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure that is passed to them.</p>
<p >When you need to execute performance-critical transfers to/from your device upon receiving an interrupt — e.g., when handling level-sensitive interrupts — you should prepare an array of <a class="el" href="structWD__TRANSFER.html">WD_TRANSFER</a> structures that contain the required information regarding the read/write operations to perform in the kernel upon arrival of an interrupt, and pass this array to WinDriver's interrupt enable functions.</p>
<p >As explained in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_2_windriver_interrupt_handling_sequence">10.1.2. WinDriver Interrupt Handling Sequence</a>, WinDriver's kernel-mode interrupt handler will execute the transfer commands passed to it within the interrupt enable function for each interrupt that it handles, before returning the control to the user mode.</p>
<p >Memory allocated for the transfer commands must remain available until the interrupts are disabled .</p>
<h3><a class="anchor" id="ch10_1_6_1_interrupt_mask_commands"></a>
10.1.6.1. Interrupt Mask Commands</h3>
<p >The interrupt transfer commands array that you pass to WinDriver can also contain an interrupt mask structure, which will be used to verify the source of the interrupt. This is done by setting the transfer structure's <code>cmdTrans</code> field, which defines the type of the transfer command, to <code>CMD_MASK</code>, and setting the relevant mask in the transfer structure's <code>Data</code> field . Interrupt mask commands must be set directly after a read transfer command in the transfer commands array.</p>
<p >When WinDriver's kernel interrupt handler encounters a mask interrupt command, it masks the value that was read from the device in the preceding read transfer command in the array, with the mask set in the interrupt mask command. If the mask is successful, WinDriver will claim control of the interrupt, execute the rest of the transfer commands in the array, and invoke your usermode interrupt handler routine when the control returns to the user mode. However, if the mask fails, WinDriver will reject control of the interrupt, the rest of the interrupt transfer commands will not be executed, and your user-mode interrupt handler routine will not be invoked. Acceptance and rejection of the interrupt is relevant only when handling legacy interrupts; since MSI/MSI-X interrupts are not shared, WinDriver will always accept control of such interrupts.</p>
<p >To correctly handle shared PCI interrupts, you must always include a mask command in your interrupt transfer commands array, and set up this mask to check whether the interrupt handler should claim ownership of the interrupt.</p>
<p >Ownership of the interrupt will be determined according to the result of this mask. If the mask fails, no other transfer commands from the transfer commands array will be executed — including commands that preceded the mask command in the array. If the mask succeeds, WinDriver will proceed to perform any commands that precede the first mask command (and its related read command) in the transfer commands array, and then any commands that follow the mask command in the array.</p>
<p >To gain more flexibility and control over the interrupt handling, you can use WinDriver's Kernel PlugIn feature, which enables you to write your own kernel-mode interrupt handler routines, as explained in <a class="el" href="ch12_understanding_the_kernel_plugin.html#ch12_5_5_handling_interrupts_in_the_kernel_plugin">12.5.5. Handling Interrupts in the Kernel PlugIn</a> of the manual.</p>
<h3><a class="anchor" id="ch10_1_6_2_sample_windriver_transfer_commands_code"></a>
10.1.6.2. Sample WinDriver Transfer Commands Code</h3>
<p >This section provides sample code for setting up interrupt transfer commands using the WinDriver Card (WDC) library API .</p>
<p >The sample code is provided for the following scenario: Assume you have a PCI card that generates level-sensitive interrupts. When an interrupt occurs you expect the value of your card's interrupt command-status register (<code>INTCSR</code>), which is mapped to an I/O port address (<code>pAddr</code>), to be intrMask. In order to clear and acknowledge the interrupt you need to write 0 to the <code>INTCSR</code>.</p>
<p >The code below demonstrates how to define an array of transfer commands that instructs WinDriver's kernel-mode interrupt handler to do the following:</p>
<ul>
<li>Read your card's <code>INTCSR</code> register and save its value.</li>
<li>Mask the read <code>INTCSR</code> value against the given mask (<code>intrMask</code>) to verify the source of the interrupt.</li>
<li>If the mask was successful, write 0 to the <code>INTCSR</code> to acknowledge the interrupt.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;All commands in the example are performed in modes of <code>DWORD</code>. </p>
</blockquote>
</blockquote>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structWD__TRANSFER.html">WD_TRANSFER</a> trans[3]; <span class="comment">/* Array of 3 WinDriver transfer command structures */</span></div>
<div class="line"><a class="code hl_define" href="windrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2.html#a76937ecb185a91a54d8ff74a7f9dfaa2">BZERO</a>(trans);</div>
<div class="line"><span class="comment">/* 1st command: Read a DWORD from the INTCSR I/O port */</span></div>
<div class="line">trans[0].<a class="code hl_variable" href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">cmdTrans</a> = <a class="code hl_enumvalue" href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a946e66443803cdc209dd674dcef80af5">RP_DWORD</a>;</div>
<div class="line"><span class="comment">/* Set address of IO port to read from: */</span></div>
<div class="line">trans[0].<a class="code hl_variable" href="structWD__TRANSFER_aa109711c8c84ebfa06bde073c6cd7e17.html#aa109711c8c84ebfa06bde073c6cd7e17">pPort</a> = pAddr; <span class="comment">/* Assume pAddr holds the address of the INTCSR */</span></div>
<div class="line"><span class="comment">/* 2nd command: Mask the interrupt to verify its source */</span></div>
<div class="line">trans[1].<a class="code hl_variable" href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">cmdTrans</a> = <a class="code hl_enumvalue" href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a92e8d5f899b7d7404d4992ee23352efb">CMD_MASK</a>;</div>
<div class="line">trans[1].<a class="code hl_variable" href="structWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b.html#a98e4642f5755fb8489bb9a051fa1e84b">Data</a>.<a class="code hl_variable" href="structWD__TRANSFER_a39c469a758668fb12f9efaf59047ef38.html#a39c469a758668fb12f9efaf59047ef38">Dword</a> = intrMask; <span class="comment">/* Assume intrMask holds your interrupt mask */</span></div>
<div class="line"><span class="comment">/* 3rd command: Write DWORD to the INTCSR I/O port.</span></div>
<div class="line"><span class="comment">This command will only be executed if the value read from INTCSR in the</span></div>
<div class="line"><span class="comment">1st command matches the interrupt mask set in the 2nd command. */</span></div>
<div class="line">trans[2].<a class="code hl_variable" href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">cmdTrans</a> = <a class="code hl_enumvalue" href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a41f193bc4ecfb6a09e538ba901c7fe6f">WP_DWORD</a>;</div>
<div class="line"><span class="comment">/* Set the address of IO port to write to: */</span></div>
<div class="line">trans[2].<a class="code hl_variable" href="structWD__TRANSFER_aa109711c8c84ebfa06bde073c6cd7e17.html#aa109711c8c84ebfa06bde073c6cd7e17">pPort</a> = pAddr; <span class="comment">/* Assume pAddr holds the address of INTCSR */</span></div>
<div class="line"><span class="comment">/* Set the data to write to the INTCSR IO port: */</span></div>
<div class="line">trans[2].<a class="code hl_variable" href="structWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b.html#a98e4642f5755fb8489bb9a051fa1e84b">Data</a>.<a class="code hl_variable" href="structWD__TRANSFER_a39c469a758668fb12f9efaf59047ef38.html#a39c469a758668fb12f9efaf59047ef38">Dword</a> = 0;</div>
<div class="ttc" id="astructWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89_html_a31617c76585d5a5ac91fc21fee963b89"><div class="ttname"><a href="structWD__TRANSFER_a31617c76585d5a5ac91fc21fee963b89.html#a31617c76585d5a5ac91fc21fee963b89">WD_TRANSFER::cmdTrans</a></div><div class="ttdeci">DWORD cmdTrans</div><div class="ttdoc">Transfer command WD_TRANSFER_CMD.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00566">windrvr.h:566</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_a39c469a758668fb12f9efaf59047ef38_html_a39c469a758668fb12f9efaf59047ef38"><div class="ttname"><a href="structWD__TRANSFER_a39c469a758668fb12f9efaf59047ef38.html#a39c469a758668fb12f9efaf59047ef38">WD_TRANSFER::Dword</a></div><div class="ttdeci">UINT32 Dword</div><div class="ttdoc">Use for 32 bit transfer.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00577">windrvr.h:577</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b_html_a98e4642f5755fb8489bb9a051fa1e84b"><div class="ttname"><a href="structWD__TRANSFER_a98e4642f5755fb8489bb9a051fa1e84b.html#a98e4642f5755fb8489bb9a051fa1e84b">WD_TRANSFER::Data</a></div><div class="ttdeci">union WD_TRANSFER::@14 Data</div></div>
<div class="ttc" id="astructWD__TRANSFER_aa109711c8c84ebfa06bde073c6cd7e17_html_aa109711c8c84ebfa06bde073c6cd7e17"><div class="ttname"><a href="structWD__TRANSFER_aa109711c8c84ebfa06bde073c6cd7e17.html#aa109711c8c84ebfa06bde073c6cd7e17">WD_TRANSFER::pPort</a></div><div class="ttdeci">KPTR pPort</div><div class="ttdoc">I/O port for transfer or kernel memory address.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00565">windrvr.h:565</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_html"><div class="ttname"><a href="structWD__TRANSFER.html">WD_TRANSFER</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00563">windrvr.h:564</a></div></div>
<div class="ttc" id="awindrvr_8h_a5a8ad1609207945d35bbd4624b55cb97_html_a5a8ad1609207945d35bbd4624b55cb97a41f193bc4ecfb6a09e538ba901c7fe6f"><div class="ttname"><a href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a41f193bc4ecfb6a09e538ba901c7fe6f">WP_DWORD</a></div><div class="ttdeci">@ WP_DWORD</div><div class="ttdoc">Write port dword.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00378">windrvr.h:378</a></div></div>
<div class="ttc" id="awindrvr_8h_a5a8ad1609207945d35bbd4624b55cb97_html_a5a8ad1609207945d35bbd4624b55cb97a92e8d5f899b7d7404d4992ee23352efb"><div class="ttname"><a href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a92e8d5f899b7d7404d4992ee23352efb">CMD_MASK</a></div><div class="ttdeci">@ CMD_MASK</div><div class="ttdoc">Interrupt Mask.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00371">windrvr.h:371</a></div></div>
<div class="ttc" id="awindrvr_8h_a5a8ad1609207945d35bbd4624b55cb97_html_a5a8ad1609207945d35bbd4624b55cb97a946e66443803cdc209dd674dcef80af5"><div class="ttname"><a href="windrvr_8h_a5a8ad1609207945d35bbd4624b55cb97.html#a5a8ad1609207945d35bbd4624b55cb97a946e66443803cdc209dd674dcef80af5">RP_DWORD</a></div><div class="ttdeci">@ RP_DWORD</div><div class="ttdoc">Read port dword.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00375">windrvr.h:375</a></div></div>
<div class="ttc" id="awindrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2_html_a76937ecb185a91a54d8ff74a7f9dfaa2"><div class="ttname"><a href="windrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2.html#a76937ecb185a91a54d8ff74a7f9dfaa2">BZERO</a></div><div class="ttdeci">#define BZERO(buf)</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01528">windrvr.h:1528</a></div></div>
</div><!-- fragment --><p >After defining the transfer commands, you can proceed to enable the interrupts. Memory allocated for the transfer commands must remain available until the interrupts are disabled , as explained above.</p>
<p >The following code demonstrates how to use the <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> function to enable the interrupts using the transfer commands prepared above:</p>
<div class="fragment"><div class="line"><span class="comment">/* Enable the interrupts:</span></div>
<div class="line"><span class="comment">    hDev: WDC_DEVICE_HANDLE received from a previous call to WDC_PciDeviceOpen().</span></div>
<div class="line"><span class="comment">    INTERRUPT_CMD_COPY: Used to save the read data - see WDC_IntEnable().</span></div>
<div class="line"><span class="comment">    interrupt_handler: Your user-mode interrupt handler routine.</span></div>
<div class="line"><span class="comment">    pData: The data to pass to the interrupt handler routine. */</span></div>
<div class="line"><a class="code hl_function" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c">WDC_IntEnable</a>(hDev, &amp;trans, 3, <a class="code hl_enumvalue" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6">INTERRUPT_CMD_COPY</a>, interrupt_handler,</div>
<div class="line">    pData, <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);</div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
<div class="ttc" id="awdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c_html_a0de3da14960f4ffc8d02350506808c4c"><div class="ttname"><a href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c">WDC_IntEnable</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_IntEnable(_In_ WDC_DEVICE_HANDLE hDev, _In_ WD_TRANSFER *pTransCmds, _In_ DWORD dwNumCmds, _In_ DWORD dwOptions, _In_ INT_HANDLER funcIntHandler, _In_ PVOID pData, _In_ BOOL fUseKP)</div><div class="ttdoc">Enables interrupt handling for the device.</div></div>
<div class="ttc" id="awindrvr_8h_a99fb83031ce9923c84392b4e92f956b5_html_a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6"><div class="ttname"><a href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6">INTERRUPT_CMD_COPY</a></div><div class="ttdeci">@ INTERRUPT_CMD_COPY</div><div class="ttdoc">Copy any data read in the kernel as a result of a read transfer command, and return it to the user wi...</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00591">windrvr.h:587</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="ch10_1_7_windriver_msi-msi-x_interrupt_handling"></a>
10.1.7. WinDriver MSI/MSI-X Interrupt Handling</h2>
<p >WinDriver supports PCI Message-Signaled Interrupts (MSI) and Extended Message-Signaled Interrupts (MSI-X).</p>
<p >The same APIs are used for handling both legacy and MSI/MSI-X interrupts, including APIs for retrieving the interrupt types supported by your hardware (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_4_determining_the_interrupt_types_supported_by_the_hardware">10.1.4. Determining the Interrupt Types Supported by the Hardware</a>) and the interrupt type that was enabled for it (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_5_determining_the_interrupt_type_enabled_for_a_pci_card">10.1.5. Determining the Interrupt Type Enabled for a PCI Card</a>).</p>
<p >When enabling interrupts for a PCI device on an OS that supports MSI/MSIx, WinDriver first tries to enable MSI-X or MSI — if supported by the device — and if this fails, it attempts to enable legacy level-sensitive interrupts.</p>
<p >On Windows, enabling MSI or MSIx interrupts requires that a relevant INF file first be installed for the device, as explained in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_7_1_windows_msi-msi-x_device_inf_files">10.1.7.1. Windows MSI/MSI-X Device INF Files</a>.</p>
<p >On Linux, you can specify the types of PCI interrupts that may be enabled for your device, via the dwOptions parameter of the <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> function or of the lowlevel <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> function — in which case WinDriver will only attempt to enable interrupts of the specified types (provided they are supported by the device).</p>
<p >WinDriver's kernel-mode interrupt handler sets the interrupt message data in the <code>dwLastMessage</code> field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure that was passed to the interrupt enable/wait function. If you pass the same interrupt structure as part of the data to your user mode interrupt handler routine, as demonstrated in the sample and generated DriverWizard interrupt code, you will be able to access this information from your interrupt handler. When using a Kernel PlugIn driver (see <a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a>), the last message data is passed to your kernel mode <a class="el" href="kp__pci_8c_a4573c90779850a5fb30079ccb7801647.html#a4573c90779850a5fb30079ccb7801647">KP_IntAtDpcMSI</a> handler; it is also passed to <a class="el" href="kp__pci_8c_a074bb35466923e0f621da5b61f72d3e1.html#a074bb35466923e0f621da5b61f72d3e1">KP_IntAtIrqlMSI</a> if you have enabled MSI interrupts. You can use the low-level <a class="el" href="wdc__defs_8h_af2ce67c05ba97ee0229a50f720c6d803.html#af2ce67c05ba97ee0229a50f720c6d803" title="Get the message data of the last received MSI/MSI-X interrupt.">WDC_GET_ENABLED_INT_LAST_MSG()</a> macro to retrieve the last message data for a given WDC device.</p>
<h3><a class="anchor" id="ch10_1_7_1_windows_msi-msi-x_device_inf_files"></a>
10.1.7.1. Windows MSI/MSI-X Device INF Files</h3>
<p >The information in this section is relevant only when working on Windows.</p>
<p >To successfully handle PCI interrupts with WinDriver on Windows, you must first install an INF file that registers your PCI card to work with WinDriver's kernel driver, as explained in <a class="el" href="ch17_driver_installation_advanced_issues.html#ch17_1_windows_inf_files">17.1. Windows INF Files</a>. To use MSI/MSI-X on Windows, the card's INF file must contain specific [Install.NT.HW] MSI information, as demonstrated below:</p>
<div class="fragment"><div class="line">[Install.NT.HW]</div>
<div class="line">AddReg = Install.NT.HW.AddReg</div>
<div class="line">[Install.NT.HW.AddReg]</div>
<div class="line">HKR, &quot;Interrupt Management&quot;, 0x00000010</div>
<div class="line">HKR, &quot;Interrupt Management\MessageSignaledInterruptProperties&quot;, 0x00000010</div>
<div class="line">HKR, &quot;Interrupt Management\MessageSignaledInterruptProperties&quot;, MSISupported, 0x10001, 1</div>
</div><!-- fragment --><p >Therefore, to use MSI/MSI-X on Windows with WinDriver — provided your hardware supports MSI/MSI-X — you need to install an appropriate INF file. When using DriverWizard on Windows to generate an INF file for a PCI device that supports MSI/MSI-X, the INF generation dialogue allows you to select to generate an INF file that supports MSI/MSI-X (see <a class="el" href="ch6_using_driverwizard.html#ch6_2_driverwizard_walkthrough">6.2. DriverWizard Walkthrough</a>).</p>
<p >In addition, the WinDriver sample code for the Xilinx Bus Master DMA (BMD) design, which demonstrates MSI handling, includes a sample MSI INF file for this design — <code>WinDriver/samples/c/xilinx/bmd_design/xilinx_bmd.inf</code>.</p>
<p >If your card's INF file does not include MSI/MSI-X information, as detailed above, WinDriver will attempt to handle your card's interrupts using the legacy level-sensitive interrupt handling method, even if your hardware supports MSI/MSI-X.</p>
<h2><a class="anchor" id="ch10_1_8_sample_user-mode_windriver_interrupt_handling_code"></a>
10.1.8. Sample User-Mode WinDriver Interrupt Handling Code</h2>
<p >The sample code below demonstrates how you can use the WDC library's interrupt APIs to implement a simple user-mode interrupt handler.</p>
<p >For a complete interrupt handler source code that uses the WDC interrupt functions, refer, for example, to the WinDriver pci_diag (<code>WinDriver/samples/c/pci_diag</code>) and PLX (<code>WinDriver/samples/c/plx</code>) samples, and to the generated DriverWizard PCI/ISA code. For a sample of MSI interrupt handling, using the same APIs, refer to the Xilinx Bus Master DMA (BMD) design sample (<code>WinDriver/samples/c/xilinx/bmd_design</code>), or to the code generated by DriverWizard for PCI hardware that supports MSI/MSI-X.</p>
<p >The following sample code demonstrates interrupt handling for an edge-triggered ISA card. The code does not set up any kernel-mode interrupt transfer commands (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_6_setting_up_kernel-mode_interrupt_transfer_commands">10.1.6. Setting Up Kernel-Mode Interrupt Transfer Commands</a>), which is acceptable in the case of edge-triggered or MSI/MSI-X interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_1_1_interrupt_handling_overview">10.1.1. Interrupt Handling — Overview</a>). Note that when using WinDriver to handle level-sensitive interrupts from the user mode, you must set up transfer commands for acknowledging the interrupt in the kernel, as explained above and as demonstrated in <a class="el" href="ch10_pci_advanced_features.html#ch10_1_6_setting_up_kernel-mode_interrupt_transfer_commands">10.1.6. Setting Up Kernel-Mode Interrupt Transfer Commands</a>.</p>
<p >As mentioned in this Chapter, WinDriver provides a single set of APIs for handling both legacy and MSI/MSI-X interrupts. You can therefore also use the following code to handle MSI/MSI-X PCI interrupts (if supported by your hardware), by simply replacing the use of <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> in the sample with <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a>.</p>
<div class="fragment"><div class="line">VOID <a class="code hl_define" href="windrvr_8h_abd951991ce3a6320fb0d1eee9350d35d.html#abd951991ce3a6320fb0d1eee9350d35d">DLLCALLCONV</a> interrupt_handler (PVOID pData)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structWDC__DEVICE.html">PWDC_DEVICE</a> pDev = (<a class="code hl_typedef" href="wdc__defs_8h_aaac32abbc4ddb8aeab9d9d8ffc806b42.html#aaac32abbc4ddb8aeab9d9d8ffc806b42">PWDC_DEVICE</a>)pData;</div>
<div class="line">    <span class="comment">/* Implement your interrupt handler routine here */</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Got interrupt %d\n&quot;</span>, pDev-&gt;<a class="code hl_variable" href="structWDC__DEVICE_adb817f641e39db812310b72968469c51.html#adb817f641e39db812310b72968469c51">Int</a>.<a class="code hl_variable" href="structWD__INTERRUPT_a2fd12a31b0222aeb2ff543c140971822.html#a2fd12a31b0222aeb2ff543c140971822">dwCounter</a>);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">int main()</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line">    <a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev;</div>
<div class="line">    ...</div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f.html#afe495f80d709b330bb26a80756cd9f9f">WDC_DriverOpen</a>(<a class="code hl_define" href="wdc__lib_8h_a5877c56a205ce3c0b671852558d3238b.html#a5877c56a205ce3c0b671852558d3238b">WDC_DRV_OPEN_DEFAULT</a>, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div>
<div class="line">    ...</div>
<div class="line">    hDev = <a class="code hl_function" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee">WDC_PciDeviceOpen</a>(...);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">/* Enable interrupts. This sample passes the WDC device handle as the data</span></div>
<div class="line"><span class="comment">    for the interrupt handler routine */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c">WDC_IntEnable</a>(hDev, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, 0, 0, interrupt_handler, (PVOID)hDev, <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);</div>
<div class="line">    <span class="comment">/* WDC_IntEnable() allocates and initializes the required WD_INTERRUPT</span></div>
<div class="line"><span class="comment">        structure, stores it in the WDC_DEVICE structure, then calls</span></div>
<div class="line"><span class="comment">        InterruptEnable(), which calls WD_IntEnable() and creates an interrupt</span></div>
<div class="line"><span class="comment">        handler thread. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf (<span class="stringliteral">&quot;Failed enabling interrupt. Error: 0x%x - %s\n&quot;</span>,</div>
<div class="line">            dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Press Enter to uninstall interrupt\n&quot;</span>);</div>
<div class="line">        fgets(line, <span class="keyword">sizeof</span>(line), stdin);</div>
<div class="line">        <a class="code hl_function" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37">WDC_IntDisable</a>(hDev);</div>
<div class="line">        <span class="comment">/* WDC_IntDisable() calls InterruptDisable();</span></div>
<div class="line"><span class="comment">        InterruptDisable() calls WD_IntDisable(). */</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188">WDC_PciDeviceClose</a>(hDev);</div>
<div class="line">    ...</div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a58fa8be948e1a2042746d719983ffd2e.html#a58fa8be948e1a2042746d719983ffd2e">WDC_DriverClose</a>();</div>
<div class="line">}</div>
<div class="ttc" id="akpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00268">kpstdlib.h:268</a></div></div>
<div class="ttc" id="astatus__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288_html_a8bc5849b8718e5f3a60bd8b1ef001288"><div class="ttname"><a href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a></div><div class="ttdeci">const char *DLLCALLCONV Stat2Str(_In_ DWORD dwStatus)</div><div class="ttdoc">Retrieves the status string that corresponds to a status code.</div></div>
<div class="ttc" id="astructWDC__DEVICE_adb817f641e39db812310b72968469c51_html_adb817f641e39db812310b72968469c51"><div class="ttname"><a href="structWDC__DEVICE_adb817f641e39db812310b72968469c51.html#adb817f641e39db812310b72968469c51">WDC_DEVICE::Int</a></div><div class="ttdeci">WD_INTERRUPT Int</div><div class="ttdoc">Kernel PlugIn information.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00060">wdc_defs.h:60</a></div></div>
<div class="ttc" id="astructWDC__DEVICE_html"><div class="ttname"><a href="structWDC__DEVICE.html">WDC_DEVICE</a></div><div class="ttdoc">Device information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__defs_8h_source.html#l00046">wdc_defs.h:46</a></div></div>
<div class="ttc" id="astructWD__INTERRUPT_a2fd12a31b0222aeb2ff543c140971822_html_a2fd12a31b0222aeb2ff543c140971822"><div class="ttname"><a href="structWD__INTERRUPT_a2fd12a31b0222aeb2ff543c140971822.html#a2fd12a31b0222aeb2ff543c140971822">WD_INTERRUPT::dwCounter</a></div><div class="ttdeci">DWORD dwCounter</div><div class="ttdoc">Number of interrupts received.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00634">windrvr.h:634</a></div></div>
<div class="ttc" id="awdc__defs_8h_aaac32abbc4ddb8aeab9d9d8ffc806b42_html_aaac32abbc4ddb8aeab9d9d8ffc806b42"><div class="ttname"><a href="wdc__defs_8h_aaac32abbc4ddb8aeab9d9d8ffc806b42.html#aaac32abbc4ddb8aeab9d9d8ffc806b42">PWDC_DEVICE</a></div><div class="ttdeci">struct WDC_DEVICE * PWDC_DEVICE</div></div>
<div class="ttc" id="awdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee_html_a458f2b87b43dac172f259ce78d5380ee"><div class="ttname"><a href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee">WDC_PciDeviceOpen</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_PciDeviceOpen(_Outptr_ WDC_DEVICE_HANDLE *phDev, _In_ const WD_PCI_CARD_INFO *pDeviceInfo, _In_ const PVOID pDevCtx)</div><div class="ttdoc">Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...</div></div>
<div class="ttc" id="awdc__lib_8h_a5877c56a205ce3c0b671852558d3238b_html_a5877c56a205ce3c0b671852558d3238b"><div class="ttname"><a href="wdc__lib_8h_a5877c56a205ce3c0b671852558d3238b.html#a5877c56a205ce3c0b671852558d3238b">WDC_DRV_OPEN_DEFAULT</a></div><div class="ttdeci">#define WDC_DRV_OPEN_DEFAULT</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l00069">wdc_lib.h:69</a></div></div>
<div class="ttc" id="awdc__lib_8h_a58fa8be948e1a2042746d719983ffd2e_html_a58fa8be948e1a2042746d719983ffd2e"><div class="ttname"><a href="wdc__lib_8h_a58fa8be948e1a2042746d719983ffd2e.html#a58fa8be948e1a2042746d719983ffd2e">WDC_DriverClose</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DriverClose(void)</div><div class="ttdoc">Closes the WDC WinDriver handle (acquired and stored by a previous call to WDC_DriverOpen()) and unin...</div></div>
<div class="ttc" id="awdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188_html_a665bdde3465a88ceaac2d8dc7d21e188"><div class="ttname"><a href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188">WDC_PciDeviceClose</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_PciDeviceClose(_In_ WDC_DEVICE_HANDLE hDev)</div><div class="ttdoc">Uninitializes a WDC PCI device structure and frees the memory allocated for it.</div></div>
<div class="ttc" id="awdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37_html_a84e9d397d15f94a887c7eabf72aabc37"><div class="ttname"><a href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37">WDC_IntDisable</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_IntDisable(_In_ WDC_DEVICE_HANDLE hDev)</div><div class="ttdoc">Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()</div></div>
<div class="ttc" id="awdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f_html_afe495f80d709b330bb26a80756cd9f9f"><div class="ttname"><a href="wdc__lib_8h_afe495f80d709b330bb26a80756cd9f9f.html#afe495f80d709b330bb26a80756cd9f9f">WDC_DriverOpen</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DriverOpen(_In_ WDC_DRV_OPEN_OPTIONS openOptions, _In_ const CHAR *pcLicense)</div><div class="ttdoc">Opens and stores a handle to WinDriver's kernel module and initializes the WDC library according to t...</div></div>
<div class="ttc" id="awdc__lib_8h_afe93a4914e351fedf921e137fa525e7f_html_afe93a4914e351fedf921e137fa525e7f"><div class="ttname"><a href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a></div><div class="ttdeci">void * WDC_DEVICE_HANDLE</div><div class="ttdoc">Handle to device information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l00033">wdc_lib.h:33</a></div></div>
<div class="ttc" id="awindrvr_8h_a4be61f088cf6870c6ff37ab94aba215c_html_a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41"><div class="ttname"><a href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a></div><div class="ttdeci">@ WD_STATUS_SUCCESS</div><div class="ttdoc">[0] Operation completed successfully</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01041">windrvr.h:1041</a></div></div>
<div class="ttc" id="awindrvr_8h_abd951991ce3a6320fb0d1eee9350d35d_html_abd951991ce3a6320fb0d1eee9350d35d"><div class="ttname"><a href="windrvr_8h_abd951991ce3a6320fb0d1eee9350d35d.html#abd951991ce3a6320fb0d1eee9350d35d">DLLCALLCONV</a></div><div class="ttdeci">#define DLLCALLCONV</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00032">windrvr.h:32</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="ch10_2_reserving_and_locking_physical_memory_on_windows_and_linux"></a>
10.2. Reserving and locking physical memory on Windows and Linux</h1>
<p >This chapter explains how to reserve a segment of the physical memory (RAM) for exclusive use, and then access it using WinDriver, on Windows or Linux.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;In most cases, there is no need to resort to this method in order to reserve segments of memory for exclusive use. Normally, you can lock a safe Direct Memory Access (DMA) buffer (e.g., using WinDriver’s DMA APIs) and then access the buffer from your driver. For more info, see <a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a> or <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a>. </p>
</blockquote>
</blockquote>
<p>The method described in this document should be used only in rare cases of “memory-intensive” driver projects and only when the required memory block cannot be locked using standard methods, such as allocation of a contiguous DMA buffer. When using this method, take special care not to write to the wrong memory addresses, so as to avoid system crashes, etc. The relevant device must have an INF file installed.</p>
<p >This chapter is organized as follows:</p>
<ul>
<li>Reserving the desired amount of RAM: Windows and Linux</li>
<li>On Windows – Calculating the base address of the reserved memory</li>
<li>Using WinDriver to access reserved memory</li>
</ul>
<p ><b>Reserving the desired amount of RAM</b></p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Reserving too much space may result in degraded OS performance. </p>
</blockquote>
</blockquote>
<ul>
<li>Windows</li>
</ul>
<p >Run the command line as an administrator, and use the BCDEdit utility to set the value of <code>removememory</code> to the number of MB you wish to reserve. Upon successful completion, BCDEdit will display a success message. To complete reservation, reboot the PC.</p>
<div class="fragment"><div class="line">bcdedit /set removememory specify_size_in_MB</div>
</div><!-- fragment --><p >For Example:</p>
<div class="fragment"><div class="line">bcdedit /set removememory 10</div>
</div><!-- fragment --><ul>
<li>Linux</li>
</ul>
<p >Run the following command to view a list of the physical memory ranges on your machine</p>
<div class="fragment"><div class="line">dmesg | grep BIOS</div>
</div><!-- fragment --><p >This produces entries as in the following sample output usable identifies memory sections that are used by Linux:</p>
<div class="fragment"><div class="line">[ 0.000000] BIOS-e820: 0000000000000000 - 000000000009f800 (usable)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000000f0000 - 0000000000100000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 0000000000100000 - 000000007dce0000 (usable)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dce0000 - 000000007dce3000 (ACPI NVS)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dce3000 - 000000007dcf0000 (ACPI data)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dcf0000 - 000000007dd00000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000c0000000 - 00000000d0000000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000fec00000 - 0000000100000000 (reserved)</div>
</div><!-- fragment --><p >Edit the boot-loader command line to instruct the Linux kernel to boot with less memory in the desired address range. For example, the following line from the sample dmesg output shown above:</p>
<div class="fragment"><div class="line">[ 0.000000] BIOS-e820: 0000000000100000 - 000000007dce0000 (usable)</div>
</div><!-- fragment --><p >indicates that there is a ~1.95GB address range, starting at address 0x100000, that is used by Linux. To reserve ~150MB of memory at the end of this range for DMA, on a machine with a GRUB boot loader, add the following to the grub file:</p>
<div class="fragment"><div class="line">GRUB_CMDLINE_LINUX=&quot;${GRUB_CMDLINE_LINUX} mem=1800M memmap=1800M@1M&quot;</div>
</div><!-- fragment --><p >This instructs Linux to boot with ~1,800MB (“mem=1800M“) starting at address 0x100000 (“@1M“). Reconfigure GRUB to apply the changes:</p>
<div class="fragment"><div class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</div>
</div><!-- fragment --><ul>
<li>Reboot Linux</li>
<li>Run the command</li>
</ul>
<div class="fragment"><div class="line">dmesg | grep BIOS\|user</div>
</div><!-- fragment --><p >to see the available physical memory ranges. The output should include a BIOS-provided physical RAM mappings section with the BIOS-.... lines from the original dmesg output, and a new user-defined RAM mappings section with user: ... lines indicating the actual available physical memory ranges (based on user definitions). The user entry for the memory range you modified in the previous steps should be missing the portion you reserved. For example, for the original BIOS mappings and boot-loader changes examples provided in the previous steps, the new output should look like similar to this:</p>
<div class="fragment"><div class="line">[ 0.000000] BIOS-provided physical RAM map:</div>
<div class="line">[ 0.000000] BIOS-e820: 0000000000000000 - 000000000009f800 (usable)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000000009f800 - 00000000000a0000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000000f0000 - 0000000000100000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 0000000000100000 - 000000007dce0000 (usable)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dce0000 - 000000007dce3000 (ACPI NVS)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dce3000 - 000000007dcf0000 (ACPI data)</div>
<div class="line">[ 0.000000] BIOS-e820: 000000007dcf0000 - 000000007dd00000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000c0000000 - 00000000d0000000 (reserved)</div>
<div class="line">[ 0.000000] BIOS-e820: 00000000fec00000 - 0000000100000000 (reserved) [ 0.000000] user-defined physical RAM map:</div>
<div class="line">[ 0.000000] user: 0000000000000000 - 000000000009f800 (usable)</div>
<div class="line">[ 0.000000] user: 000000000009f800 - 00000000000a0000 (reserved)</div>
<div class="line">[ 0.000000] user: 00000000000f0000 - 0000000000100000 (reserved)</div>
<div class="line">[ 0.000000] user: 0000000000100000 - 0000000070900000 (usable)</div>
<div class="line">[ 0.000000] user: 000000007dce0000 - 000000007dce3000 (ACPI NVS)</div>
<div class="line">[ 0.000000] user: 000000007dce3000 - 000000007dcf0000 (ACPI data)</div>
<div class="line">[ 0.000000] user: 000000007dcf0000 - 000000007dd00000 (reserved)</div>
<div class="line">[ 0.000000] user: 00000000c0000000 - 00000000d0000000 (reserved)</div>
</div><!-- fragment --><p >Comparing the following line from the BIOS-provided mapping section:</p>
<div class="fragment"><div class="line">[ 0.000000] BIOS-e820: 0000000000100000 - 000000007dce0000 (usable)</div>
</div><!-- fragment --><p >with the following line from the user-defined mapping section:</p>
<div class="fragment"><div class="line">[ 0.000000] user: 0000000000100000 - 0000000070900000 (usable)</div>
</div><!-- fragment --><p >shows that the original ~1.95GB memory range — 0x100000 – 0x7dce0000 was reduced to a ~1.75GB range — 0x100000–0x70900000. The memory in address range 0x70900000 – 0x7dce0000 is no longer available because it has been reserved in the previous steps, allowing you to use this range for DMA.</p>
<p ><b>Calculating the base address</b></p>
<p >To acquire the base address of the reserved memory segment on Windows, you must first determine the physical memory mapping on your PC and retrieve the base address and length (in bytes) of the highest address space used by the operating system. Then add the length of this address space to its base address to receive the base address of your reserved memory segment:</p>
<p >Reserved memory base address = Highest OS physical memory base address + length of the highest OS memory base address</p>
<p >To verify the size of your reserved memory block, compare the length of the highest OS address space, before and after modifying boot configuration to reserve the memory. This can be done as follows:</p>
<ul>
<li>Open the registry (Start –&gt; Run –&gt; regedit.exe)</li>
<li>Navigate to the registry key: <code>HKEY_LOCAL_MACHINE\HARDWARE\RESOURCEMAP\System Resources\Physical Memory\.Translated</code></li>
</ul>
<p >This key is of type REG_RESOURCE_LIST and holds information regarding the physical memory mapping on your PC. To view a parsed version of the mapped addresses, double-click on the Translated key, select the relevant resource from the Resource Lists dialog, and double-click on the resource (or select Display…) in order to display the resources dialog, which contains a list of all memory address ranges for the selected resource. The base address for your reserved physical memory block is calculated by locating the highest base address in the list and adding to it the length of the relevant address space.</p>
<p >For example, for the following Resources dialog, the highest base address is 0x1000000 and the length of the address space that begins at this address is 0x1eff0000, so the base address of the reserved memory is 0x1fff0000.</p>
<div class="fragment"><div class="line">reserved memory base address = 0x1000000 + 0x1eff0000 = 0x1fff0000</div>
</div><!-- fragment --><p ><b>RAM Reserved</b></p>
<div class="image">
<img src="RAMReserved.jpg" alt=""/>
</div>
 <p ><b>Using WinDriver with reserved memory</b></p>
<p >Once you acquire the physical base address of the memory segment that you reserved, you can easily access it using WinDriver, as you would any memory on an ISA card. You can use WinDriver’s DriverWizard to test the access to the memory you reserved: use the wizard to create a new ISA project, define the new memory item according to the information you acquired in the previous step(s), then proceed to access the memory with the wizard. You can also use DriverWizard to generate a sample diagnostics application that demonstrates how to lock and access the reserved memory region using WinDriver’s API. The following code segment demonstrates how you can define and lock the physical memory using WinDriver’s WDC API. The handle returned by the sample LockReservedMemory() function can be used to access the memory using WinDriver’s WDC memory access APIs, defined in the <code>WinDriver/include/wdc_lib.h</code> header file.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;There may be differences between the API in your version of WinDriver and that used in the following example (such as differences in field names and/or types). </p>
</blockquote>
</blockquote>
<div class="fragment"><div class="line"><span class="comment">/* LockReservedMemory: Returns a WDC handle for accessing</span></div>
<div class="line"><span class="comment">     the reserved memory block.</span></div>
<div class="line"><span class="comment">   Parameters:</span></div>
<div class="line"><span class="comment">     pReservedRegionBase: The physical base address of</span></div>
<div class="line"><span class="comment">         the reserved memory region (as calculated in the</span></div>
<div class="line"><span class="comment">         previous step)</span></div>
<div class="line"><span class="comment">     qwReservedRegionLength: The length (in bytes) of the</span></div>
<div class="line"><span class="comment">         reserved memory region, i.e.,:</span></div>
<div class="line"><span class="comment">         &lt;size_in_MB&gt; (as configured in Step 1) * 0x100000</span></div>
<div class="line"><span class="comment">   Note:</span></div>
<div class="line"><span class="comment">     The function uses the high-level WDC APIs.</span></div>
<div class="line"><span class="comment">     You can implement similar code using the low-level</span></div>
<div class="line"><span class="comment">     WD_CardRegister() API — see the WinDriver User&#39;s</span></div>
<div class="line"><span class="comment">     Manual for details.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> LockReservedMemory(<a class="code hl_typedef" href="windrvr_8h_a87e5f7df556231197437964aa7df4ff9.html#a87e5f7df556231197437964aa7df4ff9">PHYS_ADDR</a> pReservedRegionBase,</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> qwReservedRegionLength)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line">    <a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    <a class="code hl_struct" href="structWD__CARD.html">WD_CARD</a> deviceInfo;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Set the reserved memory&#39;s resources information */</span></div>
<div class="line">    <a class="code hl_define" href="windrvr_8h_a76937ecb185a91a54d8ff74a7f9dfaa2.html#a76937ecb185a91a54d8ff74a7f9dfaa2">BZERO</a>(deviceInfo);</div>
<div class="line">    SetMemoryItem(&amp;deviceInfo, pReservedRegionBase,</div>
<div class="line">        qwReservedRegionLength);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Get a handle to the reserved memory block */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f">WDC_IsaDeviceOpen</a>(&amp;hDev, &amp;deviceInfo, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div>
<div class="line">        <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf( <span class="stringliteral">&quot;Failed opening a WDC device handle.</span></div>
<div class="line"><span class="stringliteral">            Error 0x%lx — %s\n&quot;</span>, dwStatus,</div>
<div class="line">            <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Return the handle to the reserved memory */</span></div>
<div class="line">    <span class="keywordflow">return</span> hDev;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* SetMemoryItem: Initializes a WDC device information</span></div>
<div class="line"><span class="comment">     structure for a specified memory region.</span></div>
<div class="line"><span class="comment">   Parameters:</span></div>
<div class="line"><span class="comment">     pDeviceInfo: Pointer to a resources information structure</span></div>
<div class="line"><span class="comment">     pPhysAddr:      The memory region&#39;s physical base address</span></div>
<div class="line"><span class="comment">     qwBytes:     The memory region&#39;s length, in bytes</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keywordtype">void</span> SetMemoryItem(<a class="code hl_struct" href="structWD__CARD.html">WD_CARD</a> *pDeviceInfo, <a class="code hl_typedef" href="windrvr_8h_a87e5f7df556231197437964aa7df4ff9.html#a87e5f7df556231197437964aa7df4ff9">PHYS_ADDR</a> pPhysAddr, <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> qwBytes)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structWD__ITEMS.html">WD_ITEMS</a> *pItem = pDeviceInfo-&gt;<a class="code hl_variable" href="structWD__CARD_a8becaa4ba55a748721a272ca21c249d0.html#a8becaa4ba55a748721a272ca21c249d0">Item</a>;</div>
<div class="line"> </div>
<div class="line">    pDeviceInfo-&gt;<a class="code hl_variable" href="structWD__CARD_abe345c213a5cc968c5edefa75ba6f943.html#abe345c213a5cc968c5edefa75ba6f943">dwItems</a> = 2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* 1st item: Bus */</span></div>
<div class="line">    pItem[0].<a class="code hl_variable" href="structWD__ITEMS_a84dea0c101ef51fffa93ee58bd89043b.html#a84dea0c101ef51fffa93ee58bd89043b">item</a> = <a class="code hl_enumvalue" href="windrvr_8h_a025279585f93967b0c7184f5b8597490.html#a025279585f93967b0c7184f5b8597490a54459fdaa74824f129f58e7d0551c633">ITEM_BUS</a>;</div>
<div class="line">    pItem[0].<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_a8386a08eab9d50d76b28c2ef92bfded2.html#a8386a08eab9d50d76b28c2ef92bfded2">Bus</a>.<a class="code hl_variable" href="structWD__BUS_aa5ecac774624d6a46872d9a0eb9928b3.html#aa5ecac774624d6a46872d9a0eb9928b3">dwBusType</a> = <a class="code hl_enumvalue" href="windrvr_8h_abc6126af1d45847bc59afa0aa3216b04.html#abc6126af1d45847bc59afa0aa3216b04a3636667a9b8de5d52059105ecb6010d2">WD_BUS_ISA</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* 2nd item: Memory */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a84dea0c101ef51fffa93ee58bd89043b.html#a84dea0c101ef51fffa93ee58bd89043b">item</a> = <a class="code hl_enumvalue" href="windrvr_8h_a025279585f93967b0c7184f5b8597490.html#a025279585f93967b0c7184f5b8597490af5b94d99cadddbc9cfad6de062d8a8bb">ITEM_MEMORY</a>;</div>
<div class="line">    <span class="comment">/* Lock the memory for exclusive use */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a7f7bde4f2924abe528eba8b51729d4a9.html#a7f7bde4f2924abe528eba8b51729d4a9">fNotSharable</a> = 1;</div>
<div class="line">    <span class="comment">/* Set the reserved memory&#39;s base address */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">Mem</a>.<a class="code hl_variable" href="structWD__ITEMS_a6618364135e2a22483855ce703a0131c.html#a6618364135e2a22483855ce703a0131c">pPhysicalAddr</a> = pPhysAddr;</div>
<div class="line">    <span class="comment">/* Set the reserved memory&#39;s size */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">Mem</a>.<a class="code hl_variable" href="structWD__ITEMS_a0e69b4863bb6c71f3b2b5bc26ed05e8b.html#a0e69b4863bb6c71f3b2b5bc26ed05e8b">qwBytes</a> = qwBytes;</div>
<div class="line">    <span class="comment">/* Set the reserved memory&#39;s address space */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">Mem</a>.<a class="code hl_variable" href="structWD__ITEMS_a3cc07a04fb10ae6beed113aee9b164ac.html#a3cc07a04fb10ae6beed113aee9b164ac">dwBar</a> = 0;</div>
<div class="line">    <span class="comment">/* Map physical memory as cached (applicable only to RAM). */</span></div>
<div class="line">    pItem[1].<a class="code hl_variable" href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">I</a>.<a class="code hl_variable" href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">Mem</a>.<a class="code hl_variable" href="structWD__ITEMS_a3481054654d0746b2bf66c262a2adb50.html#a3481054654d0746b2bf66c262a2adb50">dwOptions</a> = <a class="code hl_enumvalue" href="windrvr_8h_a0dd4286b8b46d5f0414a071e08f99b34.html#a0dd4286b8b46d5f0414a071e08f99b34a7d1fbb0b5ed2837822736b2bd4314b3c">WD_ITEM_MEM_ALLOW_CACHE</a>;</div>
<div class="line">}</div>
<div class="ttc" id="astructWD__BUS_aa5ecac774624d6a46872d9a0eb9928b3_html_aa5ecac774624d6a46872d9a0eb9928b3"><div class="ttname"><a href="structWD__BUS_aa5ecac774624d6a46872d9a0eb9928b3.html#aa5ecac774624d6a46872d9a0eb9928b3">WD_BUS::dwBusType</a></div><div class="ttdeci">WD_BUS_TYPE dwBusType</div><div class="ttdoc">Bus Type: WD_BUS_PCI/ISA/EISA.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00665">windrvr.h:665</a></div></div>
<div class="ttc" id="astructWD__CARD_a8becaa4ba55a748721a272ca21c249d0_html_a8becaa4ba55a748721a272ca21c249d0"><div class="ttname"><a href="structWD__CARD_a8becaa4ba55a748721a272ca21c249d0.html#a8becaa4ba55a748721a272ca21c249d0">WD_CARD::Item</a></div><div class="ttdeci">WD_ITEMS Item[WD_CARD_ITEMS]</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00749">windrvr.h:749</a></div></div>
<div class="ttc" id="astructWD__CARD_abe345c213a5cc968c5edefa75ba6f943_html_abe345c213a5cc968c5edefa75ba6f943"><div class="ttname"><a href="structWD__CARD_abe345c213a5cc968c5edefa75ba6f943.html#abe345c213a5cc968c5edefa75ba6f943">WD_CARD::dwItems</a></div><div class="ttdeci">DWORD dwItems</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00747">windrvr.h:747</a></div></div>
<div class="ttc" id="astructWD__CARD_html"><div class="ttname"><a href="structWD__CARD.html">WD_CARD</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00745">windrvr.h:746</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a0e69b4863bb6c71f3b2b5bc26ed05e8b_html_a0e69b4863bb6c71f3b2b5bc26ed05e8b"><div class="ttname"><a href="structWD__ITEMS_a0e69b4863bb6c71f3b2b5bc26ed05e8b.html#a0e69b4863bb6c71f3b2b5bc26ed05e8b">WD_ITEMS::qwBytes</a></div><div class="ttdeci">UINT64 qwBytes</div><div class="ttdoc">Address range.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00701">windrvr.h:701</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a3481054654d0746b2bf66c262a2adb50_html_a3481054654d0746b2bf66c262a2adb50"><div class="ttname"><a href="structWD__ITEMS_a3481054654d0746b2bf66c262a2adb50.html#a3481054654d0746b2bf66c262a2adb50">WD_ITEMS::dwOptions</a></div><div class="ttdeci">DWORD dwOptions</div><div class="ttdoc">Bitmask of WD_ITEM_MEM_OPTIONS flags.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00712">windrvr.h:712</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a3cc07a04fb10ae6beed113aee9b164ac_html_a3cc07a04fb10ae6beed113aee9b164ac"><div class="ttname"><a href="structWD__ITEMS_a3cc07a04fb10ae6beed113aee9b164ac.html#a3cc07a04fb10ae6beed113aee9b164ac">WD_ITEMS::dwBar</a></div><div class="ttdeci">DWORD dwBar</div><div class="ttdoc">PCI Base Address Register number.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00711">windrvr.h:711</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c_html_a3db4e8fac096adebe46f343f4ff4131c"><div class="ttname"><a href="structWD__ITEMS_a3db4e8fac096adebe46f343f4ff4131c.html#a3db4e8fac096adebe46f343f4ff4131c">WD_ITEMS::I</a></div><div class="ttdeci">union WD_ITEMS::@15 I</div></div>
<div class="ttc" id="astructWD__ITEMS_a6618364135e2a22483855ce703a0131c_html_a6618364135e2a22483855ce703a0131c"><div class="ttname"><a href="structWD__ITEMS_a6618364135e2a22483855ce703a0131c.html#a6618364135e2a22483855ce703a0131c">WD_ITEMS::pPhysicalAddr</a></div><div class="ttdeci">PHYS_ADDR pPhysicalAddr</div><div class="ttdoc">Physical address on card.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00700">windrvr.h:700</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a7f7bde4f2924abe528eba8b51729d4a9_html_a7f7bde4f2924abe528eba8b51729d4a9"><div class="ttname"><a href="structWD__ITEMS_a7f7bde4f2924abe528eba8b51729d4a9.html#a7f7bde4f2924abe528eba8b51729d4a9">WD_ITEMS::fNotSharable</a></div><div class="ttdeci">DWORD fNotSharable</div><div class="ttdoc">ITEM_TYPE.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00694">windrvr.h:694</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a8386a08eab9d50d76b28c2ef92bfded2_html_a8386a08eab9d50d76b28c2ef92bfded2"><div class="ttname"><a href="structWD__ITEMS_a8386a08eab9d50d76b28c2ef92bfded2.html#a8386a08eab9d50d76b28c2ef92bfded2">WD_ITEMS::Bus</a></div><div class="ttdeci">WD_BUS Bus</div><div class="ttdoc">ITEM_BUS.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00739">windrvr.h:739</a></div></div>
<div class="ttc" id="astructWD__ITEMS_a84dea0c101ef51fffa93ee58bd89043b_html_a84dea0c101ef51fffa93ee58bd89043b"><div class="ttname"><a href="structWD__ITEMS_a84dea0c101ef51fffa93ee58bd89043b.html#a84dea0c101ef51fffa93ee58bd89043b">WD_ITEMS::item</a></div><div class="ttdeci">DWORD item</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00693">windrvr.h:693</a></div></div>
<div class="ttc" id="astructWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900_html_ac808e22b22c02d7f6371fa3ec89e1900"><div class="ttname"><a href="structWD__ITEMS_ac808e22b22c02d7f6371fa3ec89e1900.html#ac808e22b22c02d7f6371fa3ec89e1900">WD_ITEMS::Mem</a></div><div class="ttdeci">struct WD_ITEMS::@15::@16 Mem</div><div class="ttdoc">ITEM_MEMORY.</div></div>
<div class="ttc" id="astructWD__ITEMS_html"><div class="ttname"><a href="structWD__ITEMS.html">WD_ITEMS</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00691">windrvr.h:692</a></div></div>
<div class="ttc" id="awdc__lib_8h_a09e73731126a73d6c4ca23187472393f_html_a09e73731126a73d6c4ca23187472393f"><div class="ttname"><a href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f">WDC_IsaDeviceOpen</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_IsaDeviceOpen(_Outptr_ WDC_DEVICE_HANDLE *phDev, _In_ const WD_CARD *pDeviceInfo, _In_ const PVOID pDevCtx)</div><div class="ttdoc">Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...</div></div>
<div class="ttc" id="awindrvr_8h_a025279585f93967b0c7184f5b8597490_html_a025279585f93967b0c7184f5b8597490a54459fdaa74824f129f58e7d0551c633"><div class="ttname"><a href="windrvr_8h_a025279585f93967b0c7184f5b8597490.html#a025279585f93967b0c7184f5b8597490a54459fdaa74824f129f58e7d0551c633">ITEM_BUS</a></div><div class="ttdeci">@ ITEM_BUS</div><div class="ttdoc">Bus.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00678">windrvr.h:677</a></div></div>
<div class="ttc" id="awindrvr_8h_a025279585f93967b0c7184f5b8597490_html_a025279585f93967b0c7184f5b8597490af5b94d99cadddbc9cfad6de062d8a8bb"><div class="ttname"><a href="windrvr_8h_a025279585f93967b0c7184f5b8597490.html#a025279585f93967b0c7184f5b8597490af5b94d99cadddbc9cfad6de062d8a8bb">ITEM_MEMORY</a></div><div class="ttdeci">@ ITEM_MEMORY</div><div class="ttdoc">Memory.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00675">windrvr.h:675</a></div></div>
<div class="ttc" id="awindrvr_8h_a0dd4286b8b46d5f0414a071e08f99b34_html_a0dd4286b8b46d5f0414a071e08f99b34a7d1fbb0b5ed2837822736b2bd4314b3c"><div class="ttname"><a href="windrvr_8h_a0dd4286b8b46d5f0414a071e08f99b34.html#a0dd4286b8b46d5f0414a071e08f99b34a7d1fbb0b5ed2837822736b2bd4314b3c">WD_ITEM_MEM_ALLOW_CACHE</a></div><div class="ttdeci">@ WD_ITEM_MEM_ALLOW_CACHE</div><div class="ttdoc">Map physical memory as cached; applicable only to host RAM, not to local memory on the card.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00686">windrvr.h:684</a></div></div>
<div class="ttc" id="awindrvr_8h_a87e5f7df556231197437964aa7df4ff9_html_a87e5f7df556231197437964aa7df4ff9"><div class="ttname"><a href="windrvr_8h_a87e5f7df556231197437964aa7df4ff9.html#a87e5f7df556231197437964aa7df4ff9">PHYS_ADDR</a></div><div class="ttdeci">UINT64 PHYS_ADDR</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00361">windrvr.h:361</a></div></div>
<div class="ttc" id="awindrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9_html_aae17ebb9ef7279d026817fb22f8aebe9"><div class="ttname"><a href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a></div><div class="ttdeci">unsigned __int64 UINT64</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00297">windrvr.h:297</a></div></div>
<div class="ttc" id="awindrvr_8h_abc6126af1d45847bc59afa0aa3216b04_html_abc6126af1d45847bc59afa0aa3216b04a3636667a9b8de5d52059105ecb6010d2"><div class="ttname"><a href="windrvr_8h_abc6126af1d45847bc59afa0aa3216b04.html#abc6126af1d45847bc59afa0aa3216b04a3636667a9b8de5d52059105ecb6010d2">WD_BUS_ISA</a></div><div class="ttdeci">@ WD_BUS_ISA</div><div class="ttdoc">ISA.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00657">windrvr.h:657</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="ch10_3_buffer_sharing_between_multiple_processes"></a>
10.3. Buffer sharing between multiple processes</h1>
<p >This section describes how to share a contiguous DMA buffer or a kernel buffer between multiple processes.</p>
<p >The buffer sharing mechanism can be used to improve the work of multiple processes by allowing the developer avoiding unnecessary buffer copying. Coupled with the WinDriver IPC mechanism it might also be used as a way for two processes to convey large messages/data. Currently WinDriver supports sharing DMA contiguous buffer (See <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a> ) and Kernel buffer (See <a class="el" href="wds__lib_8h_a350377180f47fe81b8282a61566390fb.html#a350377180f47fe81b8282a61566390fb" title="Allocates a memory buffer that can be shared between the user mode and the kernel mode (&quot;shared buffe...">WDS_SharedBufferAlloc()</a> ).</p>
<p >In order to share a buffer the developer must first pass its global handle to the other process(es). See Macros <a class="el" href="wds__lib_8h_a22a581dacd74fcc20cdbe43870f09f6f.html#a22a581dacd74fcc20cdbe43870f09f6f" title="Utility macro that returns a kernel buffer global handle that can be used for buffer sharing between ...">WDS_SharedBufferGetGlobalHandle()</a> and <a class="el" href="wdc__lib_8h_aafcd74948e5256ad94c64e75d703a815.html#aafcd74948e5256ad94c64e75d703a815" title="Utility macro that returns a contiguous DMA global handle that can be used for buffer sharing between...">WDC_DMAGetGlobalHandle()</a> for getting a buffer's global handle.</p>
<p >Than, the handle should be passed to the other process(es). E.g. by WinDriver IPC calls: <a class="el" href="wds__lib_8h_a414d35a067bd99be0512d9805810f6f6.html#a414d35a067bd99be0512d9805810f6f6" title="Sends a message to a specific process with WinDriver IPC unique ID.">WDS_IpcUidUnicast()</a>, <a class="el" href="wds__lib_8h_aee68dceb1d68ba938849039cecdfbb92.html#aee68dceb1d68ba938849039cecdfbb92" title="Sends a message to all processes that registered with the same sub-group ID.">WDS_IpcSubGroupMulticast()</a> or <a class="el" href="wds__lib_8h_ab972dc5b019f88943a4b42c3a252a967.html#ab972dc5b019f88943a4b42c3a252a967" title="Sends a message to all processes that were registered with the same group ID as the sending process.">WDS_IpcMulticast()</a>.</p>
<p >After a process gets the global buffer handle, it should use <a class="el" href="wdc__lib_8h_a8369d86288b62fe93791febc6e3f55a8.html#a8369d86288b62fe93791febc6e3f55a8" title="Retrieves a contiguous DMA buffer which was allocated by another process.">WDC_DMABufGet()</a> or <a class="el" href="wds__lib_8h_a7ba0155bee47774551439957fa42fa6e.html#a7ba0155bee47774551439957fa42fa6e" title="Retrieves a shared buffer which was allocated by another process.">WDS_SharedBufferGet()</a> to retrieve the buffer. WinDriver will re-map the buffer to the new process virtual memory (I.e. user-space) and will fill all the necessary information as though the buffer was allocated from the calling process.</p>
<p >Once the process no longer needs the shared buffer it should use the regular unlock/free calls - <a class="el" href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155" title="Unlocks and frees the memory allocated for a DMA buffer by a previous call to WDC_DMAContigBufLock(),...">WDC_DMABufUnlock()</a> appropriately.</p>
<p >WinDriver manages all system resources, hence the call to <a class="el" href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155" title="Unlocks and frees the memory allocated for a DMA buffer by a previous call to WDC_DMAContigBufLock(),...">WDC_DMABufUnlock()</a> will not remove system resources until all processes no longer use the buffer.</p>
<h1><a class="anchor" id="ch10_4_single_root_i-o_virtualization_sr-iov"></a>
10.4. Single Root I/O Virtualization (SR-IOV)</h1>
<h2><a class="anchor" id="ch10_4_1_introduction_single_root_i_o_virtualization_sr-iov"></a>
10.4.1. Introduction</h2>
<p >Single Root I/O Virtualization (SR-IOV) is a PCIe extended capability which makes one physical device appear as multiple virtual devices. The physical device is referred to as Physical Function (PF) while the virtual devices are referred to as Virtual Functions (VF).</p>
<p >Allocation of VF can be dynamically controlled by the PF via registers encapsulated in the capability. By default, SR-IOV is disabled and the PF behaves as a regular PCIe device. Once it is turned on, each VF's PCI configuration space can be accessed by its own domain, bus, slot and function number (Routing ID). Each VF also has a PCI memory space, which is used to map its register set.A VF device driver operates on the register set so it can be functional and appear as a real PCI device.</p>
<p >At the moment, WinDriver only supports SR-IOV in Linux.</p>
<p ><b>Important notes</b>:</p>
<ul>
<li>VFs have to be the same type of device as the PF.</li>
<li>SR-IOV requires hardware support, as the number of VFs that can be presented depends upon the device.</li>
<li>The PCI SIG SR-IOV specification indicates that each device can have up to 256 VFs, but practical limits are usually lower, as each VF requires actual hardware resources.</li>
<li>VFs can't be used to configure the device.</li>
</ul>
<h2><a class="anchor" id="ch10_4_2_using_sr-iov_with_windriver"></a>
10.4.2. Using SR-IOV with WinDriver</h2>
<p >The following steps were required to operate the Intel 82599ES 10-Gigabit SFI/SFP+ Network Adaptor. Other cards might require different adjustments.</p>
<p >Make sure that prior to installing WinDriver you have run <code>./configure --enable-sriov-support</code> from the <code>WinDriver/redist</code> directory.</p>
<p >The <code>pci_diag</code> application may be run from the <code>WinDriver/samples/c/pci_diag</code> directory, in order to show relevant SR-IOV options.</p>
<p >It is possible that upon boot it will be required to add <code>pci=assign-busses</code> to the boot arguments in the kernel command line. This tells the kernel to always assign all PCI bus numbers, overriding whatever the firmware may have done.</p>
<p >Otherwise, assigning VF to a device may result in "bus number is out of range" error. This argument can be added by editing the file <code>/etc/default/grub/</code>, and adding it to the GRUB_CMDLINE_LINUX_DEFAULT variable. Then run update-grub to make this change permanent. Under Ubuntu, a temporary change of this variable can be done by pressing 'e' when the GRUB menu, and appending the argument to the 'linux' line. WinDriver provides you with the API for enabling, disabling and getting the number of assigned virtual functions - see the description of <a class="el" href="wdc__lib_8h_ad6e718316cb00a7771fcf3b5bd7cb14e.html#ad6e718316cb00a7771fcf3b5bd7cb14e" title="SR-IOV API functions are not part of the standard WinDriver API, and not included in the standard ver...">WDC_PciSriovEnable()</a>, <a class="el" href="wdc__lib_8h_a20a87513fc981dc637f15395cd9a5eea.html#a20a87513fc981dc637f15395cd9a5eea" title="Disables SR-IOV for a supported device and removes all the assigned VFs.">WDC_PciSriovDisable()</a>, and <a class="el" href="wdc__lib_8h_a574895ff192728d02d33e5f039d63a83.html#a574895ff192728d02d33e5f039d63a83" title="Gets the number of virtual functions assigned to a supported device.">WDC_PciSriovGetNumVFs()</a> respectively.</p>
<h1><a class="anchor" id="ch10_5_using_windrivers_ipc_apis"></a>
10.5. Using WinDriver's IPC APIs</h1>
<p >This section describes how to use WinDriver to perform Inter-Process Communication.</p>
<p >WinDriver IPC allows several WinDriver-based user applications to send and receive user defined messages.</p>
<p >The <code>pci_diag</code> sample found in <code>WinDriver/util</code> (source code found in <code>WinDriver/samples/c/pci_diag</code>) examplifies usage of this ability. Using IPC with WinDriver requires having a license that includes IPC support. IPC APIs will fully work during the Evaluation period.</p>
<h2><a class="anchor" id="ch10_5_1_ipc_overview"></a>
10.5.1 IPC Overview</h2>
<p >You should define a group ID that will be used by all your applications, and optionally you can also define several sub-group IDs to differentiate between different types of applications. For example, define one sub-group ID for operational applications, and another sub-group ID for monitoring or debug applications. This will enable you to send messages only to one type of application.</p>
<p >An IPC message can be sent in three ways:</p><ul>
<li>Multicast - The message will be sent to all processes that were registered with the same group ID.</li>
<li>Sub-group Multicast - The message will be sent to all processes that were registered with the same sub-group ID.</li>
<li>Unicast (By WinDriver IPC unique ID) - The message will be sent to one specific process.</li>
</ul>
<p >In order to start working with WinDriver IPC each user application must first register by calling <a class="el" href="wds__lib_8h_a380d7301f68cdeefd1ee8793a8b374eb.html#a380d7301f68cdeefd1ee8793a8b374eb" title="Registers an application with WinDriver IPC.">WDS_IpcRegister()</a>. It must provide a group ID and a sub-group ID and can optionally provides callback function to receive incoming messages. WinDriver IPC unique ID is received either in the result of <a class="el" href="wds__lib_8h_ac800406d9a87d40d91edcb08083e44fe.html#ac800406d9a87d40d91edcb08083e44fe" title="Scans and returns information of all registered processes that share the application process groupID ...">WDS_IpcScanProcs()</a> or in the message received by the callback function. Multicast messages may be sent by calling <a class="el" href="wds__lib_8h_ab972dc5b019f88943a4b42c3a252a967.html#ab972dc5b019f88943a4b42c3a252a967" title="Sends a message to all processes that were registered with the same group ID as the sending process.">WDS_IpcMulticast()</a> or <a class="el" href="wds__lib_8h_aee68dceb1d68ba938849039cecdfbb92.html#aee68dceb1d68ba938849039cecdfbb92" title="Sends a message to all processes that registered with the same sub-group ID.">WDS_IpcSubGroupMulticast()</a>, while unicast messages may be sent by WinDriver IPC unique ID by calling <a class="el" href="wds__lib_8h_a414d35a067bd99be0512d9805810f6f6.html#a414d35a067bd99be0512d9805810f6f6" title="Sends a message to a specific process with WinDriver IPC unique ID.">WDS_IpcUidUnicast()</a>.</p>
<p >Query of current registered processes can be done using <a class="el" href="wds__lib_8h_ac800406d9a87d40d91edcb08083e44fe.html#ac800406d9a87d40d91edcb08083e44fe" title="Scans and returns information of all registered processes that share the application process groupID ...">WDS_IpcScanProcs()</a>.</p>
<h2><a class="anchor" id="ch10_5_2_shared_interrupts_via_ipc"></a>
10.5.2. Shared Interrupts via IPC</h2>
<p >A method of acknowledging interrupts from more than one process is by using the Shared Interrupts via IPC API provided by WinDriver.</p>
<p >This mechanism allows creating a special IPC "process" that sends IPC messages to other processes that are registered to WinDriver IPC.</p>
<h3><a class="anchor" id="ch10_5_2_1_enabling_shared_interrupts"></a>
10.5.2.1. Enabling Shared Interrupts:</h3>
<p >A recommended method would be: In each process that you'd like to enable the Shared Interrupts in:</p>
<ul>
<li>Register the process to IPC using <a class="el" href="wds__lib_8h_a380d7301f68cdeefd1ee8793a8b374eb.html#a380d7301f68cdeefd1ee8793a8b374eb" title="Registers an application with WinDriver IPC.">WDS_IpcRegister()</a>.</li>
<li>Write your own callback function that is relevant to what you wish to occur when a Shared Interrupt occurs. Send a pointer to that function as an argument to <a class="el" href="wds__lib_8h_a03ad418c2390fb1d669ca572210031ad.html#a03ad418c2390fb1d669ca572210031ad" title="Enables the shared interrupts mechanism of WinDriver.">WDS_SharedIntEnable()</a>. You can write a different callback for each process to acheive a different handling of the interrupt in different contexts.</li>
</ul>
<h3><a class="anchor" id="ch10_5_2_2_disabling_shared_interrupts"></a>
10.5.2.2. Disabling Shared Interrupts:</h3>
<p >You can either disable Shared Interrupts locally (for the current process only) using <a class="el" href="wds__lib_8h_a34570a15ccf48ca435e8a54ffb5c42e9.html#a34570a15ccf48ca435e8a54ffb5c42e9" title="Disables the Shared Interrupts mechanism of WinDriver for the current process.">WDS_SharedIntDisableLocal()</a> or disable Shared Interrupts for all processes by using <a class="el" href="wds__lib_8h_a168a978d541377d2943b590903d46132.html#a168a978d541377d2943b590903d46132" title="Disables the Shared Interrupts mechanism of WinDriver for all processes.">WDS_SharedIntDisableGlobal()</a>.</p>
<h1><a class="anchor" id="ch10_6_faq_pci_advanced_features"></a>
10.6. FAQ</h1>
<h2><a class="anchor" id="ch10_6_1_what_is_the_significance_of_marking_a_resource_as_shared_with_windriver_and_how_can_i_verify_the_shared_status_of_a_specific_resource_on_my_card"></a>
10.6.1. What is the significance of marking a resource as 'shared' with WinDriver, and how can I verify the 'shared' status of a specific resource on my card?</h2>
<p >The "shared" status determines whether the resource is locked for exclusive use. When a memory, I/O, or interrupt item is defined as non-sharable, the device registration function — <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a>, or the low-level <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> function — checks whether the resource is already locked for exclusive use. If it is, the registration fails; otherwise, the resource is locked exclusively, and any subsequent attempt to lock the resource — either from within the same application, or from another WinDriver application — will fail, until the resource is released using <a class="el" href="wdc__lib_8h_a665bdde3465a88ceaac2d8dc7d21e188.html#a665bdde3465a88ceaac2d8dc7d21e188" title="Uninitializes a WDC PCI device structure and frees the memory allocated for it.">WDC_PciDeviceClose()</a> / <a class="el" href="wdc__lib_8h_a2a4b820da9b800812dedf52b775e71e1.html#a2a4b820da9b800812dedf52b775e71e1" title="Uninitializes a WDC ISA device structure and frees the memory allocated for it.">WDC_IsaDeviceClose()</a>, or the low-level <a class="el" href="windrvr_8h_ac7dcb9399ded534dd90ae859babe6025.html#ac7dcb9399ded534dd90ae859babe6025" title="Unregisters a device and frees the resources allocated to it.">WD_CardUnregister()</a> function.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Device registers cannot be defined as shared. </p>
</blockquote>
</blockquote>
<p>PCI resources, and specifically interrupts, should generally be defined as sharable.</p>
<p >For memory and I/O, the share status defined with WinDriver affects only WinDriver-based applications. However, for interrupts there is further significance to the share status, since it also determines whether other drivers (not necessarily WinDriver drivers) can lock the same interrupt. For an explanation of how to read the value of the PCI interrupt status register, please see futher FAQ questions.</p>
<p >Use one of the following methods to check whether a resource is defined as sharable:</p>
<ul>
<li>From your code, print the value of the <code>fNotSharable</code> flag for the memory/IO/interrupt item that you wish to check — <code>deviceInfo.Card.Item[i].fNotSharable</code> when using the WDC API, or <code>cardReg.Card.Item[i].fNotSharable</code> when using the low-level WinDriver API. A value of 1 indicates that the resources is not sharable. A value of 0 indicates that the resource is sharable.</li>
<li>If you have used the DriverWizard to generate your code, you can run the DriverWizard, open the <code>xxx.wdp</code> DriverWizard project file, which served as the basis for your application, select the <b>Memory</b>, <b>I/O</b>, or <b>Interrupt</b> tab (respectively) and click on <b>Edit</b>. Then look to see if the <b>Shared</b> box in the Resource Information window is checked, to signify that the resource is defined as shared for this device. Note that this test is only relevant when using the original <code>xxx.wdp</code> project file for your application code, and assuming your code does not modify the "shared" status — since any changes made in the <code>xxx.wdp</code> file, via the DriverWizard, will only affect subsequent code generation, and will not affect the existing application code. Therefore, checking the “shared” values from the code is more accurate.</li>
</ul>
<p >As a general guideline, avoid locking the same resource twice. It is always recommend to release a previously locked resource before trying to lock it again (either from the same application, or from different applications). If you need to access the resources from several applications, you can share the handle received from a single call to the device registration function — <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a>, or the low-level <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> function.</p>
<h2><a class="anchor" id="ch10_6_2_can_i_access_the_same_device_simultaneously_from_several_windriver_applications"></a>
10.6.2. Can I access the same device, simultaneously, from several WinDriver applications?</h2>
<p >It is possible to create several WinDriver-based driver processes that will access the same card, although we do not recommend this, and it should not generally be required.</p>
<p >Should you decide to implement such a design, consider the synchronization issues carefully. To bypass the synchronization problems, we recommend you use only one point of access to your hardware. Use a single process to directly access your hardware, while the other processes should access the hardware only via this process. The advantage of this design is that only one point requires synchronization.</p>
<p >Please note, however, that we will not be able to provide technical support specifically related to the implementation of such designs and accompanying issues (such as synchronization problems that might occur). You should therefore carefully consider if this is indeed the desired design in your case.</p>
<p >For USB, note that while multiple calls to <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> for the same device may succeed, after the first attach callback accepts control of the device no other attach notifications will be received until <a class="el" href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88" title="Stops listening to devices matching the criteria, and unregisters the notification callbacks for thos...">WDU_Uninit()</a> is called for the relevant <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> call. Using a single process to perform a single <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> call with a single attach callback function, as suggested above, will eliminate problems resulting from multiple <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> calls.</p>
<p >You may consider accessing the device from one application, and communicate with other apps using the IPC API.</p>
<h2><a class="anchor" id="ch10_6_3_how_can_i_read_the_value_of_the_pci_interrupt_status_register_from_my_windriver_isr_in_order_to_determine_for_example_which_card_generated_the_interrupt_when_the_irq_is_shared_between_several_devices"></a>
10.6.3. How can I read the value of the PCI interrupt status register from my WinDriver ISR, in order to determine, for example, which card generated the interrupt when the IRQ is shared between several devices?</h2>
<p >When handling the interrupts from the user mode you must acknowledge (clear) the interrupt on the card whether your card generated the interrupt or not (in case of shared IRQs). However, this does not necessarily present a problem.</p>
<p >To determine which card generated the interrupt, and activate your ISR only in case the interrupt was generated by your card, you can set up the transfer commands of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure, which is passed to <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> / <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a>, or to the lower level <a class="el" href="windrvr_8h_a0f76bcc6859511bff8f79e1fd28ae2c0.html#a0f76bcc6859511bff8f79e1fd28ae2c0" title="Registers an interrupt service routine (ISR) to be called upon interrupt.">WD_IntEnable()</a> function — <code>int.Cmds</code> — to include a command to read from the interrupt register before clearing the interrupt. The register will then be read in the kernel, immediately when an interrupt is received and before it is cleared, and you will be able to access the read value from your user mode interrupt handler routine when it is activated.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;In order to save the read value you must set the <code>INTERRUPT_CMD_COPY</code> flag in the dwOptions field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure (int.dwOptions |= <code>INTERRUPT_CMD_COPY</code>). </p>
</blockquote>
</blockquote>
<p>When using WinDriver’s Kernel PlugIn feature to handle the interrupts directly in the kernel, you can read the value of the interrupt status register on your card directly when an interrupt is received, from within your [KP_IntAtIrql()] (<a class="el" href="kp__pci_8c_a766459ac39112e0692658ec3e3597712.html#a766459ac39112e0692658ec3e3597712">KP_PCI_IntAtIrql</a>) routine, and proceed to acknowledge (clear) the interrupt and execute your ISR only if the value of the status register indicates that the interrupt was indeed generated by your card. For more information on how to handle shared PCI interrupts from the Kernel PlugIn, please refer to the Kernel PlugIn chapter of this manual.</p>
<h2><a class="anchor" id="ch10_6_4_i_need_to_be_able_to_count_the_number_of_interrupts_occurring_and_possibly_call_a_routine_every_time_an_interrupt_occurs_is_this_possible_with_windriver"></a>
10.6.4. I need to be able to count the number of interrupts occurring and possibly call a routine every time an interrupt occurs. Is this possible with WinDriver?</h2>
<p >Yes. You can use the DriverWizard to generate a diagnostics code for your device, which includes a skeletal interrupt handling mechanism that also monitors the number of interrupts received. You may need to modify the code slightly to suit your hardware’s specification with regard to interrupt handling.</p>
<p >You can also refer to the <code>int_io</code> sample, which is available under the <code>WinDriver/samples/c/int_io/</code> directory, for an example of handling ISA interrupts with WinDriver.</p>
<p >Both the sample and the generated code will install an interrupt and spawn a thread that waits on it. The number of interrupts received is returned in the <code>dwCounter</code> field of the <a class="el" href="structWD__INTERRUPT.html">WD_INTERRUPT</a> structure.</p>
<h2><a class="anchor" id="ch10_6_5_does_windriver_poll_the_interrupt_busy_wait"></a>
10.6.5. Does WinDriver poll the interrupt (Busy Wait)?</h2>
<p >No. When calling <a class="el" href="windrvr_8h_a1bce9e80b0bb6cbbc98572c1014cf212.html#a1bce9e80b0bb6cbbc98572c1014cf212" title="Waits for an interrupt.">WD_IntWait()</a> (which is called from the high-level <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> and <a class="el" href="windrvr__int__thread_8h_acc61c8f0b6e874720e7b2438e1214c8f.html#acc61c8f0b6e874720e7b2438e1214c8f">InterruptEnable()</a> APIs) the calling thread is put to sleep. CPU cycles are not wasted on waiting. When an interrupt occurs the thread is awaken and you can perform your interrupt handling.</p>
<h2><a class="anchor" id="ch10_6_6_can_i_write_to_disk_files_during_an_interrupt_routine"></a>
10.6.6. Can I write to disk files during an interrupt routine?</h2>
<p >Yes. WinDriver enables you to implement your interrupt service routine (ISR) in the user mode, thereby allowing you to perform all library function calls from within your ISR. Just remember to keep it short, so you don’t miss the next interrupt.</p>
<p >If you select to implement your ISR in the kernel, using WinDriver’s Kernel PlugIn feature, you will not be able to use the standard user mode file I/O functions. You can either leave the file I/O handling in the user-mode ISR, and implement your interrupt code so that the user-mode interrupt routine is executed only once every several interrupts. You can refer to the generated DriverWizard Kernel PlugIn code and/or to the generic WinDriver Kernel PlugIn sample — <code>WinDriver/samples/c/pci_diag/kp_pci/kp_pci.c</code> — for an example of monitoring the interrupt count); or replace the user-mode file I/O code with calls to OS-specific functions, which can be called at the kernel level (for example, the WDK <code>ZwCreateFile()</code>, <code>ZwWriteFile()</code> and <code>ZwReadFile()</code> functions). Please note, however, that this will diminish your driver’s cross-platform portability. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
