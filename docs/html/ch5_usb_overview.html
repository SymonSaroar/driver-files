<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 5: USB Overview"/>
<title>Jungo WinDriver: Chapter 5: USB Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch5_usb_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 5: USB Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap05"></a>This chapter explores the basic characteristics of the Universal Serial Bus (USB) and introduces WinDriver USB's features and architecture.</p>
<blockquote class="doxtable">
<p >&zwj;<b>ℹ️ Note</b></p>
<blockquote class="doxtable">
<p >&zwj;The references to the WinDriver USB toolkit in this chapter relate to the standard WinDriver USB toolkit for development of USB host drivers. </p>
</blockquote>
</blockquote>
<h1><a class="anchor" id="ch5_1_introduction_to_usb"></a>
5.1. Introduction to USB</h1>
<p >USB (Universal Serial Bus) is an industry standard extension to the PC architecture for attaching peripherals to the computer. It was originally developed in 1995 by leading PC and telecommunication industry companies, such as Intel, Compaq, Microsoft and NEC. USB was developed to meet several needs, among them the needs for an inexpensive and widespread connectivity solution for peripherals in general and for computer telephony integration in particular, an easy-to-use and flexible method of reconfiguring the PC, and a solution for adding a large number of external peripherals. The USB standard meets these needs.</p>
<p >The USB specification allows for the connection of a maximum of 127 peripheral devices (including hubs) to the system, either on the same port or on different ports.</p>
<p >USB also supports Plug-and-Play installation and hot swapping.</p>
<p >The <b>USB 1.1</b> standard supports both isochronous and asynchronous data transfers and has dual speed data transfer: 1.5 Mb/s (megabits per second) for <b>low-speed</b> USB devices and 12 Mb/s for <b>full-speed</b> USB devices (much faster than the original serial port). Cables connecting the device to the PC can be up to five meters (16.4 feet) long. USB includes built-in power distribution for low power devices and can provide limited power (up to 500 mA of current) to devices attached on the bus. The <b>USB 2.0</b> standard supports a signalling rate of 480 Mb/s, known as **'high-speed'**, which is 40 times faster than the USB 1.1 full-speed transfer rate.</p>
<p >USB 2.0 is fully forward- and backward-compatible with USB 1.1 and uses existing cables and connectors. USB 2.0 supports connections with PC peripherals that provide expanded functionality and require wider bandwidth. In addition, it can handle a larger number of peripherals simultaneously. USB 2.0 enhances the user's experience of many applications, including interactive gaming, broadband Internet access, desktop and Web publishing, Internet services and conferencing.</p>
<p >The <b>USB 3.2 Gen 1</b> standard supports a signalling rate of up to 5 Gb/s in a new mode known as <b>SuperSpeed USB</b>. The <b>USB 3.2 Gen 2</b> standard supports a signalling rate of up to 10 Gb/s in a new mode known as <b>SuperSpeed USB 10Gbps</b>. The <b>USB 3.2 Gen 2x2</b> standard supports a signalling rate of up to 20 Gb/s in newer modes also named <b>SuperSpeed USB 20Gbps</b> whilist preserving backwards compatibility with previous USB versions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">New name   </th><th class="markdownTableHeadLeft">Old name   </th><th class="markdownTableHeadLeft">Original name   </th><th class="markdownTableHeadLeft">SuperSpeed name   </th><th class="markdownTableHeadLeft">Max name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">USB 3.2 Gen 2x2   </td><td class="markdownTableBodyLeft">N/A   </td><td class="markdownTableBodyLeft">USB 3.2   </td><td class="markdownTableBodyLeft">SuperSpeed USB 20Gbps   </td><td class="markdownTableBodyLeft">20Gbps    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">USB 3.2 Gen 2   </td><td class="markdownTableBodyLeft">USB 3.1 Gen 2   </td><td class="markdownTableBodyLeft">USB 3.1   </td><td class="markdownTableBodyLeft">SuperSpeed USB 10Gbps   </td><td class="markdownTableBodyLeft">10Gbps    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">USB 3.2 Gen 1   </td><td class="markdownTableBodyLeft">USB 3.1 Gen 1   </td><td class="markdownTableBodyLeft">USB 3.0   </td><td class="markdownTableBodyLeft">SuperSpeed USB   </td><td class="markdownTableBodyLeft">5Gbps   </td></tr>
</table>
<p >Because of its benefits USB is currently enjoying broad market acceptance.</p>
<h1><a class="anchor" id="ch5_2_windriver_usb_benefits"></a>
5.2. WinDriver USB Benefits</h1>
<p >This section describes the main benefits of the USB standard and the WinDriver USB toolkit, which supports this standard:</p>
<ul>
<li>External connection, maximizing ease of use</li>
<li>Self identifying peripherals supporting automatic mapping of function to driver and configuration</li>
<li>Dynamically attachable and re-configurable peripherals</li>
<li>Suitable for device bandwidths ranging from a few Kb/s to hundreds of Mb/s</li>
<li>Supports isochronous as well as asynchronous transfer types over the same set of wires</li>
<li>Supports simultaneous operation of many devices (multiple connections)</li>
<li>Supports a data transfer rate of up to 10 Gbp/s (super-speed+) for USB 3.1, up to 5 Gbp/s(super-speed) for USB 3.0, up to 480 Mb/s (high-speed) for USB 2.0 and up to 12 Mb/s (full-speed) for USB 1.1. The supported speed also depends on the operating system and hardware utilised</li>
<li>Guaranteed bandwidth and low latencies; appropriate for telephony, audio, etc. (isochronous transfer may use almost the entire bus bandwidth)</li>
<li>Flexibility: supports a wide range of packet sizes and a wide range of data transfer rates</li>
<li>Robustness: built-in error handling mechanism and dynamic insertion and removal of deviceswith no delay observed by the user</li>
<li>Synergy with PC industry; Uses commodity technologies</li>
<li>Optimized for integration in peripheral and host hardware</li>
<li>Low-cost implementation, therefore suitable for development of low-cost peripherals</li>
<li>Low-cost cables and connectors</li>
<li>Built-in power management and distribution</li>
<li>Specific library support for custom USB HID devices</li>
</ul>
<h1><a class="anchor" id="ch5_3_usb_components"></a>
5.3. USB Components</h1>
<p >The Universal Serial Bus (USB) consists of the following primary components:</p>
<p ><b>USB Host</b></p>
<p >The USB host platform is where the USB host controller is installed and where the client software/device driver runs. The <em>USB Host Controller</em> is the interface between the hostand the USB peripherals. The host is responsible for detecting the insertion and removal of USB devices, managing the control and data flow between the host and the devices, providing power to attached devices and more.</p>
<p ><b>USB Hub</b></p>
<p >A USB device that allows multiple USB devices to attach to a single USB port ona USB host. Hubs on the back plane of the hosts are called <em>root hubs</em>. Other hubs are called external hubs.</p>
<p ><b>USB Function</b></p>
<p >A USB device that can transmit or receive data or control information over the bus and that provides a function. A function is typically implemented as a separate peripheral device that plugs into a port on a hub using a cable. However, it is also possible to create a <em>compound device</em>, which is a physical package that implements multiple functions and anembedded hub with a single USB cable. A compound device appears to the host as a hub with one or more non-removable USB devices, which may have ports to support the connection of external devices.</p>
<h1><a class="anchor" id="ch5_4_data_flow_in_usb_devices"></a>
5.4. Data Flow in USB Devices</h1>
<p >During the operation of a USB device, the host can initiate a flow of data between the client software and the device.</p>
<p >Data can be transferred between the host and only one device at a time (<em>peer to peer communication</em>). However, two hosts cannot communicate directly, nor can two USB devices (with the exception of On-The-Go (OTG) devices, where one device acts as the master (host) and the other as the slave.)</p>
<p >The data on the USB bus is transferred via pipes that run between software memory buffers on the host and endpoints on the device.</p>
<p >Data flow on the USB bus is half-duplex, i.e., data can be transmitted only in one direction at a given time.</p>
<p >An <b>endpoint</b> is a uniquely identifiable entity on a USB device, which is the source or terminus ofthe data that flows from or to the device. Each USB device, logical or physical, has a collection of independent endpoints. The three USB speeds (low, full and high) all support one bi-directional control endpoint (endpoint zero) and 15 unidirectional endpoints. Each unidirectional endpoint can be used for either inbound or outbound transfers, so theoretically there are 30 supportedend points. Each endpoint has the following attributes: bus access frequency, bandwidth requirement, endpoint number, error handling mechanism, maximum packet size that can be transmitted or received, transfer type and direction (into or out of the device).</p>
<p ><b>USB Endpoints</b></p>
<div class="image">
<img src="USBENDPOINT.png" alt=""/>
</div>
 <p >A <b>pipe</b> is a logical component that represents an association between an endpoint on the USB device and software on the host. Data is moved to and from a device through a pipe. A pipe can be either a stream pipe or a message pipe, depending on the type of data transfer used in the pipe. <em>Stream pipes</em> handle interrupt, bulk and isochronous transfers, while <em>message pipes</em> support the control transfer type.</p>
<h1><a class="anchor" id="ch5_5_usb_data_exchange"></a>
5.5. USB Data Exchange</h1>
<p >The USB standard supports two kinds of data exchange between a host and a device: functional data exchange and control exchange.</p>
<p ><b>Functional Data Exchange</b> is used to move data to and from the device. There are three types of USB data transfers: Bulk, Interrupt and Isochronous.</p>
<p ><b>Control Exchange</b> is used to determine device identification and configuration requirements, and to configure a device; it can also be used for other device-specific purposes, including control of other pipes on the device. Control exchange takes place via a control pipe — the default <em>pipe 0</em>, which always exists. The control transfer consists of a <em>setup stage</em> (in which a setup packet is sent from the host to the device), an optional <em>data stage</em> and a <em>status stage</em>.</p>
<p >The figure below depicts a USB device with one bi-directional control pipe (endpoint) and two functional data transfer pipes (endpoints), as identified by WinDriver's DriverWizard utility.</p>
<p ><b>USB Pipes</b></p>
<div class="image">
<img src="wiz_usb_select_dev_ifc.png" alt=""/>
</div>
 <h1><a class="anchor" id="ch5_6_usb_data_transfer_types"></a>
5.6. USB Data Transfer Types</h1>
<p >The USB device (function) communicates with the host by transferring data through a pipe between a memory buffer on the host and an endpoint on the device. USB supports four different transfer types. A type is selected for a specific endpoint according to the requirements of the device and the software. The transfer type of a specific endpoint is determined in the endpoint descriptor.</p>
<p >The USB specification provides for the following data transfer types:</p>
<h2><a class="anchor" id="ch5_6_1_control_transfer"></a>
5.6.1. Control Transfer</h2>
<p >Control Transfer is mainly intended to support configuration, command and status operations between the software on the host and the device.</p>
<p >This transfer type is used for low-, full- and high-speed devices.</p>
<p >Each USB device has at least one control pipe (default pipe), which provides access to the configuration, status and control information.</p>
<p >Control transfer is bursty, non-periodic communication.</p>
<p >The control pipe is bi-directional — i.e., data can flow in both directions.</p>
<p >Control transfer has a robust error detection, recovery and retransmission mechanism and retries are made without the involvement of the driver.</p>
<p >The maximum packet size for control endpoints can be only 8 bytes for low-speed devices; 8, 16,32, or 64 bytes for full-speed devices; and only 64 bytes for high-speed devices.</p>
<p >For more in-depth information regarding USB control transfers and their implementation, <br  />
 refer to <a class="el" href="ch14_usb_advanced_features.html">Chapter 14: USB Advanced Features</a> of the manual.</p>
<h2><a class="anchor" id="ch5_6_2_isochronous_transfer"></a>
5.6.2. Isochronous Transfer</h2>
<p >Isochronous Transfer is most commonly used for time-dependent information, such as multimedia streams and telephony.</p>
<p >This transfer type can be used by full-speed and high-speed devices, but not by low-speed devices.</p>
<p >Isochronous transfer is periodic and continuous.</p>
<p >The isochronous pipe is unidirectional, i.e., a certain endpoint can either transmit or receive information. Bi-directional isochronous communication requires two isochronous pipes, one in each direction.</p>
<p >USB guarantees the isochronous transfer access to the USB bandwidth (i.e., it reserves the required amount of bytes of the USB frame) with bounded latency, and guarantees the data transfer rate through the pipe, unless there is less data transmitted.</p>
<p >Since timeliness is more important than correctness in this type of transfer, no retries are made in case of error in the data transfer. However, the data receiver can determine that an error occurred on the bus.</p>
<h2><a class="anchor" id="ch5_6_3_interrupt_transfer"></a>
5.6.3. Interrupt Transfer</h2>
<p >Interrupt Transfer is intended for devices that send and receive small amounts of data infrequently or in an asynchronous time frame.</p>
<p >This transfer type can be used for low-, full- and high-speed devices.</p>
<p >Interrupt transfer type guarantees a maximum service period and that delivery will be re-attempted in the next period if there is an error on the bus.</p>
<p >The interrupt pipe, like the isochronous pipe, is unidirectional and periodical.</p>
<p >The maximum packet size for interrupt endpoints can be 8 bytes or less for low-speed devices; 64bytes or less for full-speed devices; and 1,024 bytes or less for high-speed devices.</p>
<h2><a class="anchor" id="ch5_6_4_bulk_transfer"></a>
5.6.4. Bulk Transfer</h2>
<p >Bulk Transfer is typically used for devices that transfer large amounts of non-time sensitive data, and that can use any available bandwidth, such as printers and scanners.</p>
<p >This transfer type can be used by full-speed and high-speed devices, but not by low-speed devices.</p>
<p >Bulk transfer is non-periodic, large packet, bursty communication.</p>
<p >Bulk transfer allows access to the bus on an "as-available" basis, guarantees the data transfer but not the latency, and provides an error check mechanism with retries attempts. If part of the USB bandwidth is not being used for other transfers, the system will use it for bulk transfer.</p>
<p >Like the other stream pipes (isochronous and interrupt), the bulk pipe is also unidirectional, so bi-directional transfers require two endpoints.</p>
<p >The maximum packet size for bulk endpoints can be 8, 16, 32, or 64 bytes for full-speed devices, and 512 bytes for high-speed devices.</p>
<h1><a class="anchor" id="ch5_7_usb_configuration"></a>
5.7. USB Configuration</h1>
<p >Before the USB function (or functions, in a compound device) can be operated, the devicemust be configured. The host does the configuring by acquiring the configuration information from the USB device. USB devices report their attributes by descriptors. A <b>descriptor</b> is the defined structure and format in which the data is transferred. A complete description of the USB descriptors can be found in <a class="el" href="ch14_usb_advanced_features.html#ch14_2_usb_control_transfers_overview">14.2. USB Control Transfers Overview</a>.</p>
<p >It is best to view the USB descriptors as a hierarchical structure with four levels:</p>
<ul>
<li>The Device level</li>
<li>The Configuration level</li>
<li>The Interface level (this level may include an optional sub-level called Alternate Setting)</li>
<li>The Endpoint level</li>
</ul>
<p >There is only one device descriptor for each USB device. Each device has one or more configurations, each configuration has one or more interfaces, and each interface has zero or more endpoints.</p>
<p ><b>Device Descriptors</b></p>
<div class="image">
<img src="device_descriptors.png" alt=""/>
</div>
 <p ><b>Device Level</b></p>
<p >The device descriptor includes general information about the USB device, i.e. global information for all of the device configurations. The device descriptor identifies, among other things, the device class (HID device, hub, locator device, etc.), subclass, protocol code,vendor ID, device ID and more. Each USB device has one device descriptor.</p>
<p ><b>Configuration Level</b></p>
<p >A USB device has one or more configuration descriptors. Each descriptor identifies the number of interfaces grouped in the configuration and the power attributes of the configuration (such as self-powered, remote wakeup, maximum power consumption and more). Only one configuration can be loaded at a given time. For example, an ISDN adapter might have two different configurations, one that presents it with a single interface of 128 Kb/s and a second that presents it with two interfaces of 64 Kb/s each.</p>
<p ><b>Interface Level</b></p>
<p >The interface is a related set of endpoints that present a specific functionality or feature of the device. Each interface may operate independently. The interface descriptor describes the number of the interface, the number of endpoints used by this interface and the interface-specific class, subclass and protocol values when the interface operates independently.</p>
<p >In addition, an interface may have <b>alternate settings</b>. The alternate settings allow the endpoints or their characteristics to be varied after the device is configured.</p>
<p ><b>Endpoint Level</b></p>
<p >The lowest level is the endpoint descriptor, which provides the host with information regarding the endpoint's data transfer type and maximum packet size. For isochronous endpoints, the maximum packet size is used to reserve the required bus time forthe data transfer — i.e., the bandwidth. Other endpoint attributes are its bus access frequency, endpoint number, error handling mechanism and direction. The same endpoint can have different properties (and consequently different uses) in different alternate settings.</p>
<p >Seems complicated? Not at all! WinDriver automates the USB configuration process. The included DriverWizard utility and USB diagnostics application scan the USB bus, detect all USB devices and their configurations, interfaces, alternate settings and endpoints, and enable you to pick the desired configuration before starting driver development.</p>
<p >WinDriver identifies the endpoint transfer type as determined in the endpoint descriptor. The driver created with WinDriver contains all configuration information acquired at this early stage.</p>
<h1><a class="anchor" id="ch5_8_windriver_usb"></a>
5.8. WinDriver USB</h1>
<p >WinDriver USB enables developers to quickly develop high-performance drivers for USB-based devices without having to learn the USB specifications and operating system internals, or use the operating system development kits. For example, Windows drivers can be developed without using the Windows Driver Kit (WDK) or learning the Windows Driver Model (WDM).</p>
<p >The driver code developed with WinDriver USB is binary compatible across the supported Windows platforms and source code compatible across all supported operating systems. For an up-to-date list of supported operating systems, see <a class="el" href="ch1_overview.html#ch1_4_supported_platforms">1.4. Supported Platforms</a>.</p>
<p >WinDriver USB is a generic tool kit that supports all USB devices from all vendors and with all types of configurations.</p>
<p >WinDriver USB encapsulates the USB specification and architecture, letting you focus on your application logic. WinDriver USB features the graphical DriverWizard utility, which enables you to easily detect your hardware, view its configuration information, and test it, before writing a single line of code: DriverWizard first lets you choose the desired configuration, interface and alternate setting combination, using a friendly graphical user interface. After detecting and configuring your USB device, you can proceed to test the communication with the device — perform data transfers on the pipes, send control requests, reset the pipes, etc. — in order to ensure that all your hardware resources function as expected.</p>
<p >After your hardware is diagnosed, you can use DriverWizard to automatically generate your device driver source code. WinDriver USB provides user-mode APIs, which you can call from within your application in order to implement the communication with your device. The WinDriver USB API includes USB-unique operations such as reset of a pipe or a device. The generated DriverWizard code implements a diagnostics application, which demonstrates how to use WinDriver's USB API to drive your specific device. In order to use the application you just need to compile and run it. You can jump-start your development cycle by using this application as your skeletal driver and then modifying the code as needed to implement the desired driver functionality for your specific device.</p>
<p >DriverWizard also automates the creation of an INF file that registers your device to work with WinDriver, which is an essential step in order to correctly identify and handle USB devices using WinDriver.</p>
<p >With WinDriver USB, all development is done in the user mode, using familiar development and debugging tools and your favorite compiler or development environment (such as MS Visual Studio, CMake, GCC, Windows GCC).</p>
<h1><a class="anchor" id="ch5_9_windriver_usb_architecture"></a>
5.9. WinDriver USB Architecture</h1>
<p >To access your hardware, your application calls the WinDriver kernel module using functions from the WinDriver USB API. The high-level functions utilize the low-level functions, which use IOCTLs to enable communication between the WinDriver kernel module and your user-mode application. The WinDriver kernel module accesses your USB device resources through the native operating system calls.</p>
<p >There are two layers responsible for abstracting the USB device to the USB device driver. The upper layer is the <b>USB Driver (USBD)</b> layer, which includes the USB Hub Driver and the USB Core Driver. The lower level is the <b>Host Controller Driver (HCD)</b> layer. The division of duties between the HCD and USBD layers is not defined and is operating system dependent. Both the HCD and USBD are software interfaces and components of the operating system, where the HCD layer represents a lower level of abstraction.</p>
<p >The <b>HCD</b> is the software layer that provides an abstraction of the host controller hardware, while the <b>USBD</b> provides an abstraction of the USB device and the data transfer between the host software and the function of the USB device.</p>
<p >The <b>USBD</b> communicates with its clients (the specific device driver, for example) through the USB Driver Interface (<b>USBDI</b>). At the lower level, the Core Driver and USB Hub Driver implement the hardware access and data transfer by communicating with the HCD using the Host Controller Driver Interface (<b>HCDI</b>).</p>
<p >The USB Hub Driver is responsible for identifying the addition and removal of devices from a particular hub. When the Hub Driver receives a signal that a device was attached or detached, it uses additional host software and the USB Core Driver to recognize and configure the device. The software implementing the configuration can include the hub driver, the device driver, and other software.</p>
<p >WinDriver USB abstracts the configuration procedure and hardware access described above for the developer. With WinDriver's USB API, developers can perform all the hardware-related operations without having to master the lower-level implementation for supporting these operations.</p>
<p ><b>WinDriver USB Architecture</b></p>
<div class="image">
<img src="wdusb_arch_detailed.png" alt=""/>
</div>
 <h1><a class="anchor" id="ch5_10_windriver_usb_wdu_library_overview"></a>
5.10. WinDriver USB (WDU) Library Overview</h1>
<p >This section provides a general overview of WinDriver's USB Library (WDU), including:</p>
<ul>
<li>An outline of the WDU_xxx API calling sequence.</li>
<li>Instructions for upgrading code developed with the previous WinDriver USB API, used in version 5.22 and earlier, to use the improved WDU_xxx API. If you do not need to upgrade USB driver code developed with an older version of WinDriver, simply skip this section.</li>
</ul>
<p >The WDU library's interface is found in the <code>WinDriver/include/wdu_lib.h</code> and <br  />
 <code>WinDriver/include/windrvr.h</code> header files, which should be included from any source file that calls the WDU API (<a class="el" href="wdu__lib_8h.html">wdu_lib.h</a> already includes <a class="el" href="windrvr_8h.html">windrvr.h</a>).</p>
<h2><a class="anchor" id="ch5_10_1_calling_sequence_for_windriver_usb"></a>
5.10.1. Calling Sequence for WinDriver USB</h2>
<p >The WinDriver WDU_xxx USB API is designed to support event-driven transfers between your user-mode USB application and USB devices. This is in contrast to earlier versions, in which USB devices were initialized and controlled using a specific sequence of function calls.</p>
<p >You can implement the three user callback functions specified in the next section: <code>WDU_ATTACH_CALLBACK</code>, <code>WDU_DETACH_CALLBACK</code> and <code>WDU_POWER_CHANGE_CALLBACK</code> (at the very least <code>WDU_ATTACH_CALLBACK</code>). These functions are used to notify your application when a relevant system event occurs, such as the attaching or detaching of a USB device. For best performance, minimal processing should be done in these functions.</p>
<p >Your application calls <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> and provides the criteria according to which the system identifies a device as relevant or irrelevant. The <a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a> function must also pass pointers to the user callback functions.</p>
<p >Your application then simply waits to receive a notification of an event. Upon receipt of such a notification, processing continues. Your application may make use of any functions defined in the high- or low-level APIs below. The high-level functions, provided for your convenience, make use of the low-level functions, which in turn use IOCTLs to enable communication between the WinDriver kernel module and your user-mode application.</p>
<p >When exiting, your application calls <a class="el" href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88" title="Stops listening to devices matching the criteria, and unregisters the notification callbacks for thos...">WDU_Uninit()</a> to stop listening to devices matching the given criteria and to unregister the notification callbacks for these devices.</p>
<p >The following figure depicts the calling sequence described above. Each vertical line represents a function or process. Each horizontal arrow represents a signal or request, drawn from the initiator to the recipient. Time progresses from top to bottom.</p>
<p ><b>WinDriver USB Calling Sequence</b></p>
<div class="image">
<img src="wd_usb_calling_sequence.png" alt=""/>
</div>
 <p >The following piece of meta-code can serve as a framework for your user-mode application's code:</p>
<div class="fragment"><div class="line">attach()</div>
<div class="line">{</div>
<div class="line">    ...    </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">this</span> is my device        </div>
<div class="line">        <span class="comment">/*        </span></div>
<div class="line"><span class="comment">        Set the desired alternate setting ;        </span></div>
<div class="line"><span class="comment">        Signal main() about the attachment of this device        </span></div>
<div class="line"><span class="comment">        */</span> </div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;  </div>
<div class="line">    <span class="keywordflow">else</span>        </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">detach()</div>
<div class="line">{    </div>
<div class="line">    ...   </div>
<div class="line">    signal main() about the detachment of this device    </div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">main()</div>
<div class="line">{    </div>
<div class="line">    <a class="code hl_function" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357">WDU_Init</a>(...);  </div>
<div class="line"> </div>
<div class="line">    ...    </div>
<div class="line">    <span class="keywordflow">while</span> (...)   </div>
<div class="line">    {      </div>
<div class="line">        <span class="comment">/* wait for new devices */</span>       </div>
<div class="line"> </div>
<div class="line">        ...        </div>
<div class="line">        </div>
<div class="line">        <span class="comment">/* issue transfers */</span>      </div>
<div class="line">        ...  </div>
<div class="line">    }   </div>
<div class="line">    ...    </div>
<div class="line">    <a class="code hl_function" href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88">WDU_Uninit</a>();</div>
<div class="line">}</div>
<div class="ttc" id="akpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00264">kpstdlib.h:264</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
<div class="ttc" id="awdu__lib_8h_a043527105668e3c0e1ec6af7965b2357_html_a043527105668e3c0e1ec6af7965b2357"><div class="ttname"><a href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357">WDU_Init</a></div><div class="ttdeci">DWORD DLLCALLCONV WDU_Init(_Outptr_ WDU_DRIVER_HANDLE *phDriver, _In_ WDU_MATCH_TABLE *pMatchTables, _In_ DWORD dwNumMatchTables, _In_ WDU_EVENT_TABLE *pEventTable, _In_ const char *pcLicense, _In_ DWORD dwOptions)</div><div class="ttdoc">Starts listening to devices matching a criteria, and registers notification callbacks for those devic...</div></div>
<div class="ttc" id="awdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88_html_ab518806876f8a02b0d069dcdb4a12b88"><div class="ttname"><a href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88">WDU_Uninit</a></div><div class="ttdeci">void DLLCALLCONV WDU_Uninit(_In_ WDU_DRIVER_HANDLE hDriver)</div><div class="ttdoc">Stops listening to devices matching the criteria, and unregisters the notification callbacks for thos...</div></div>
</div><!-- fragment --><h2><a class="anchor" id="ch5_10_2_upgrading_from_the_wd_xxx_usb_api_to_the_wdu_xxx_api"></a>
5.10.2. Upgrading from the WD_xxx USB API to the WDU_xxx API</h2>
<p >The WinDriver WDU_xxx USB API, provided beginning with version 6.0.0, is designed to support event-driven transfers between your user-mode USB application and USB devices. This is in contrast to earlier versions, in which USB devices were initialized and controlled using a specific sequence of function calls.</p>
<p >As a result of this change, you will need to modify your USB applications that were designed to interface with earlier versions of WinDriver to ensure that they will work with WinDriver versions 6.X on all supported platforms and not only on Microsoft Windows.</p>
<p >You will have to reorganize your application's code so that it conforms with the framework illustrated by the piece of meta-code provided in <a class="el" href="ch5_usb_overview.html#ch5_10_1_calling_sequence_for_windriver_usb">5.10.1. Calling Sequence for WinDriver USB</a></p>
<p >In addition, the functions that collectively define the USB API have been changed. The new functions provide an improved interface between user-mode USB applications and the WinDriver kernel module. Note that the new functions receive their parameters directly, unlike the old functions, which received their parameters using a structure.</p>
<p >The table below lists the legacy functions in the left column and indicates in the right column which function or functions replace(s) each of the legacy functions. Use this table to quickly determine which new functions to use in your new code.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><b>Low Level API</b>   </th><th class="markdownTableHeadLeft"><b>High Level API</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><em>Previous Function</em>   </td><td class="markdownTableBodyLeft"><em>New Function</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><a class="el" href="wd__log_8h_af5b59012df248f79156d5d154eea6264.html#af5b59012df248f79156d5d154eea6264">WD_Open()</a>, <a class="el" href="windrvr_8h_a8ebc8cdd387b0c4d8c9cdb1c1fca6763.html#a8ebc8cdd387b0c4d8c9cdb1c1fca6763" title="Returns the version number of the WinDriver kernel module currently running.">WD_Version()</a>, WD_UsbScanDevice()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_a043527105668e3c0e1ec6af7965b2357.html#a043527105668e3c0e1ec6af7965b2357" title="Starts listening to devices matching a criteria, and registers notification callbacks for those devic...">WDU_Init()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">WD_UsbDeviceRegister()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_ab6c13860c49a49a691bff1bb8379f1d0.html#ab6c13860c49a49a691bff1bb8379f1d0" title="Sets the alternate setting for the specified interface.">WDU_SetInterface()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">WD_UsbGetConfiguration()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_a975050b3993f592471a8bc85c5e9a6f2.html#a975050b3993f592471a8bc85c5e9a6f2" title="Gets configuration information from the device including all the descriptors in a WDU_DEVICE struct.">WDU_GetDeviceInfo()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">WD_UsbDeviceUnregister()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_ab518806876f8a02b0d069dcdb4a12b88.html#ab518806876f8a02b0d069dcdb4a12b88" title="Stops listening to devices matching the criteria, and unregisters the notification callbacks for thos...">WDU_Uninit()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">WD_UsbTransfer()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_a449c8e40df947e5cf1947966ed7b55ee.html#a449c8e40df947e5cf1947966ed7b55ee" title="Transfers data to/from a device.">WDU_Transfer()</a>, <a class="el" href="wdu__lib_8h_a08590e9faa6866c6616eff76d06f2874.html#a08590e9faa6866c6616eff76d06f2874">WDU_TransferDefaultPipe()</a>, <a class="el" href="wdu__lib_8h_a4c1ed5302cc89aeb71a8d27ea458b484.html#a4c1ed5302cc89aeb71a8d27ea458b484">WDU_TransferBulk()</a>, <a class="el" href="wdu__lib_8h_a3659a73e2a215c0969345af7b2b2b70e.html#a3659a73e2a215c0969345af7b2b2b70e">WDU_TransferIsoch()</a>, <a class="el" href="wdu__lib_8h_a2f002ad293373f995140048e12cce680.html#a2f002ad293373f995140048e12cce680">WDU_TransferInterrupt()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">USB_TRANSFER_HALT option   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_a14fe6aee511c7a337983b55f4ec9a6ea.html#a14fe6aee511c7a337983b55f4ec9a6ea" title="Halts the transfer on the specified pipe (only one simultaneous transfer per-pipe is allowed by WinDr...">WDU_HaltTransfer()</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">WD_UsbResetPipe()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_aac629a036ea367ff5af11e5d496954c1.html#aac629a036ea367ff5af11e5d496954c1" title="Resets a pipe.">WDU_ResetPipe()</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">WD_UsbResetDevice(), WD_UsbResetDeviceEx()   </td><td class="markdownTableBodyLeft"><a class="el" href="wdu__lib_8h_afb26bcb75ea4a50c773585f5478a1a13.html#afb26bcb75ea4a50c773585f5478a1a13" title="Resets a device (supported only on Windows).">WDU_ResetDevice()</a>   </td></tr>
</table>
<h1><a class="anchor" id="ch5_11_faq_usb_overview"></a>
5.11. FAQ</h1>
<h2><a class="anchor" id="ch5_11_1_how_do_i_reset_my_usb_device_using_windriver"></a>
5.11.1 How do I reset my USB device using WinDriver?</h2>
<p >You can use <a class="el" href="wdu__lib_8h_afb26bcb75ea4a50c773585f5478a1a13.html#afb26bcb75ea4a50c773585f5478a1a13" title="Resets a device (supported only on Windows).">WDU_ResetDevice()</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
