<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110109-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-110109-1');
</script>
<script type="text/javascript" src="../common/version.js"></script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Chapter 11: Improving PCI Performance"/>
<title>Jungo WinDriver: Chapter 11: Improving PCI Performance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-main.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="wd_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jungo WinDriver
   &#160;
   <span id="projectnumber"></span>
   </div>
   <div id="projectbrief">Official Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ch11_improving_pci_performance.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 11: Improving PCI Performance </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_chap11"></a> </p>
<h1><a class="anchor" id="ch11_1_improving_pci_performance_overview"></a>
11.1. Improving PCI Performance Overview</h1>
<p >Once your user-mode driver has been written and debugged, you might find that certain modules in your code do not operate fast enough (for example: an interrupt handler or accessing I/O mapped regions). If this is the case, try to improve performance in one of the following ways:</p>
<ul>
<li>Implement DMA I/O mechanism for your transfers (<a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a> or <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a>).</li>
<li>Create a Kernel PlugIn driver (<a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a>) and move the performance-critical portions of your code to the Kernel PlugIn.</li>
</ul>
<p >In general (this is true for most cases) I/O transfers from and to your PCI device could be of the following types: (This could vary depending on the device)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><b>Transfer type</b>   </th><th class="markdownTableHeadLeft"><b>Speed</b>   </th><th class="markdownTableHeadLeft"><b>Hardness of implementation</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Blocking   </td><td class="markdownTableBodyLeft">Slowest   </td><td class="markdownTableBodyLeft">Easy, use <a class="el" href="wdc__lib_8h_a4d758b86edaa43e4a07f378e176341d1.html#a4d758b86edaa43e4a07f378e176341d1" title="Reads a block of data from the device.">WDC_ReadAddrBlock()</a> / WriteAddrBlock()    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Non Blocking   </td><td class="markdownTableBodyLeft">Slower   </td><td class="markdownTableBodyLeft">Easy, use WDC_ReadAddrXXX / WDC_WriteAddrXXX    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">DMA with interrupts method   </td><td class="markdownTableBodyLeft">Fast   </td><td class="markdownTableBodyLeft">Harder to implement, requires using <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> / <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a> and a firm understanding of the device's specifics    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">DMA with polling method   </td><td class="markdownTableBodyLeft">Fastest   </td><td class="markdownTableBodyLeft">Harder to implement, requires using <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> / <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a> and a firm understanding of the device's specifics   </td></tr>
</table>
<p >WinDriver's enhanced support's advantage is that it saves the developer time on getting acquainted with the popular DMA IPs available on the market today, and allows them to utilize DMA without having to spend time on learning how to implement DMA for their device, or at least reducing their learning curve. For more info see <a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">Chapter 9: Enhanced Support for Specific Chipsets</a>.</p>
<p >Use the following checklist to determine how to best improve the performance of your driver.</p>
<h2><a class="anchor" id="ch11_1_1_performance_improvement_checklist"></a>
11.1.1. Performance Improvement Checklist</h2>
<p >The following checklist will help you determine how to improve the performance of your driver:</p>
<p ><b>ISA Card — accessing an I/O-mapped range on the card</b></p>
<p >When transferring a large amount of data, use block (string) transfers and/or group several data transfer function calls into a single multi-transfer function call, <br  />
 as explained in <a class="el" href="ch11_improving_pci_performance.html#ch11_1_3_2_block_transfers_and_grouping_multiple_transfers_burst_transfer">11.1.3.2. Block Transfers and Grouping Multiple Transfers (Burst Transfer)</a> below.</p>
<p >If this does not solve the problem, handle the I/O at kernel mode by writing a Kernel PlugIn driver, as explained in <a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a> and <a class="el" href="ch13_creating_a_kernel_plugin_driver.html">Chapter 13: Creating a Kernel PlugIn Driver</a>.</p>
<p ><b>PCI Card — accessing an I/O-mapped range on the card</b></p>
<p >Avoid using I/O ranges in your hardware design. Use Memory mapped ranges instead as they are accessed significantly faster.</p>
<p ><b>Accessing a memory-mapped range on the card</b></p>
<p >Try to access memory directly instead of using function calls, as explained in <a class="el" href="ch11_improving_pci_performance.html#ch11_2_1_implementing_scatter-gather_dma">11.2.1. Implementing Scatter/Gather DMA</a> below. When transferring large amounts of data, consider also the solution to problem #1 above.</p>
<p >If the problem persists, then there is a hardware design problem. You will not be able to increase performance by using any software design method, writing a Kernel PlugIn, or even by writing a full kernel driver.</p>
<p ><b>Interrupt latency — missing interrupts, receiving interrupts too late</b></p>
<p >Handle the interrupts in the kernel mode by writing a Kernel PlugIn driver, <br  />
 as explained in <a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a> and <br  />
 <a class="el" href="ch13_creating_a_kernel_plugin_driver.html">Chapter 13: Creating a Kernel PlugIn Driver</a>.</p>
<p ><b>PCI target access vs. master access</b></p>
<p >PCI target access is usually slower than PCI master access (bus-master DMA). For large data transfers, bus-master DMA access is preferable. Read <a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a> to learn how to use WinDriver to implement bus master DMA.</p>
<h2><a class="anchor" id="ch11_1_2_pci_transfers_overview"></a>
11.1.2 PCI Transfers Overview</h2>
<p >There are two PCI transfer options: reading/writing to FIFO (string transfers), or reading/writing to different memory blocks.</p>
<p >In the case of reading/writing to memory blocks, the data is transferred to/from a memory address in the PC from/to a memory address in the card, and then both the card’s memory address and the PC’s memory address are incremented for the next transfer. This way, the data is transferred between the address in the PC and the same relative address in the card.</p>
<p ><b>PCI Transfer</b></p>
<div class="image">
<img src="pci_transfer.jpg" alt=""/>
</div>
 <p >In the case of reading/writing to FIFO, the data is transferred to/from a memory address in the PC from/to a single address in the card, and then only the PC’s memory address is incremented for the next transfer. This way the data is transferred between incremented memory addresses in the PC and the same FIFO in the card’s memory.</p>
<p ><b>PCI String Transfer</b></p>
<div class="image">
<img src="pci_string_transfer.jpg" alt=""/>
</div>
 <p >The <code><a class="el" href="structWD__TRANSFER.html">WD_TRANSFER</a></code> structure includes an automatic increment flag, called [fAutoinc] (WD_TRANSFER_fAutoinc). When defined as TRUE, the I/O or memory address is incremented for transfer to/from FIFO (string transfers), when defined as <code>FALSE</code>, all data is transferred to the same port/address.</p>
<p >For more information on PCI transfers, please refer to the description of WinDriver’s <code><a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a></code> function, which executes a read/write instruction to an I/O port or to a memory address.</p>
<h2><a class="anchor" id="ch11_1_3_improving_the_performance_of_a_user-mode_driver"></a>
11.1.3. Improving the Performance of a User-Mode Driver</h2>
<p >As a general rule, transfers to memory-mapped regions are faster than transfers to I/O-mapped regions, because WinDriver enables you to access memory-mapped regions directly from the user mode, without the need for a function call, as explained in <a class="el" href="ch11_improving_pci_performance.html#ch11_1_3_1_using_direct_access_to_memory-mapped_regions">11.1.3.1. Using Direct Access to Memory-Mapped Regions</a>.</p>
<p >In addition, the WinDriver APIs enable you to improve the performance of your I/O and memory data transfers by using block (string) transfers and by grouping several data transfers into a single function call, as explained in <a class="el" href="ch11_improving_pci_performance.html#ch11_1_3_2_block_transfers_and_grouping_multiple_transfers_burst_transfer">11.1.3.2. Block Transfers and Grouping Multiple Transfers (Burst Transfer)</a>.</p>
<h3><a class="anchor" id="ch11_1_3_1_using_direct_access_to_memory-mapped_regions"></a>
11.1.3.1. Using Direct Access to Memory-Mapped Regions</h3>
<p >When registering a PCI card, using <a class="el" href="wdc__lib_8h_a458f2b87b43dac172f259ce78d5380ee.html#a458f2b87b43dac172f259ce78d5380ee" title="Allocates and initializes a WDC PCI device structure, registers the device with WinDriver,...">WDC_PciDeviceOpen()</a> / <a class="el" href="wdc__lib_8h_a09e73731126a73d6c4ca23187472393f.html#a09e73731126a73d6c4ca23187472393f" title="Allocates and initializes a WDC ISA device structure, registers the device with WinDriver,...">WDC_IsaDeviceOpen()</a> or the low-level <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> function, WinDriver returns both user-mode and kernel-mode mappings of the card's physical memory regions. These addresses can then be used to access the memory regions on the card directly, either from the user mode or from the kernel mode (respectively), thus eliminating the context switches between the user and kernel modes and the function calls overhead for accessing the memory.</p>
<p >The <a class="el" href="wdc__defs_8h_abf63426839a108305154d04eb320970e.html#abf63426839a108305154d04eb320970e">WDC_MEM_DIRECT_ADDR</a> macro provides the relevant direct memory access base address — user-mode mapping when called from the user-mode / kernel-mode mapping when called from a Kernel PlugIn driver (see <a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a>) — for a given memory address region on the card. You can then pass the mapped base address to the <a class="el" href="wdc__lib_8h_ac6d6201adc3cf1013cdb3099cbb744a7.html#ac6d6201adc3cf1013cdb3099cbb744a7" title="Direct memory read/write macros.">WDC_ReadMem8()</a> / <a class="el" href="wdc__lib_8h_abddddb6e319732f0a254e4a7035aa73b.html#abddddb6e319732f0a254e4a7035aa73b" title="reads 2 byte (16 bits) from a specified memory address.">WDC_ReadMem16()</a> / <a class="el" href="wdc__lib_8h_a4d90eca61f33d8bff76a4412e1a758ec.html#a4d90eca61f33d8bff76a4412e1a758ec" title="reads 4 byte (32 bits) from a specified memory address.">WDC_ReadMem32()</a> / <a class="el" href="wdc__lib_8h_a49e0ec96162bce7e1feaf0952cdc06e0.html#a49e0ec96162bce7e1feaf0952cdc06e0" title="reads 8 byte (64 bits) from a specified memory address.">WDC_ReadMem64()</a> and <a class="el" href="wdc__lib_8h_a2796276f0264ce8c5d3e667b79fd2af0.html#a2796276f0264ce8c5d3e667b79fd2af0" title="writes 1 byte (8 bits) to a specified memory address.">WDC_WriteMem8()</a> / <a class="el" href="wdc__lib_8h_a8f98d08d0bb313503b286e5da1adfeb0.html#a8f98d08d0bb313503b286e5da1adfeb0" title="writes 2 byte (16 bits) to a specified memory address.">WDC_WriteMem16()</a> / <a class="el" href="wdc__lib_8h_af29a24e3bd554944cfe692437f63294a.html#af29a24e3bd554944cfe692437f63294a" title="writes 4 byte (32 bits) to a specified memory address.">WDC_WriteMem32()</a>/ <a class="el" href="wdc__lib_8h_a8ee16051bad7b881e131979de13c3f48.html#a8ee16051bad7b881e131979de13c3f48" title="writes 8 byte (64 bits) to a specified memory address.">WDC_WriteMem64()</a> macros, along with the desired offset within the selected memory region, to directly access a specific memory address on the card, either from the user mode or in the kernel. In addition, all the <a class="el" href="wdc__lib_8h_a4d1ba64fa08ddf8dd1e8ce67f574da9c.html#a4d1ba64fa08ddf8dd1e8ce67f574da9c" title="Read/write a device&#39;s address space (8/16/32/64 bits)">WDC_ReadAddr8()</a> / <a class="el" href="wdc__lib_8h_a9c4b1e7c789b5d5e82f00dff2943ab23.html#a9c4b1e7c789b5d5e82f00dff2943ab23" title="reads 2 byte (16 bits) from a specified memory or I/O address.">WDC_ReadAddr16()</a> / <a class="el" href="wdc__lib_8h_acc138b33c2a286f2d476c4022d15cecc.html#acc138b33c2a286f2d476c4022d15cecc" title="reads 4 byte (32 bits) from a specified memory or I/O address.">WDC_ReadAddr32()</a> / <a class="el" href="wdc__lib_8h_aeed668a016ac973f91dd666b6ceadaba.html#aeed668a016ac973f91dd666b6ceadaba" title="reads 8 byte (64 bits) from a specified memory or I/O address.">WDC_ReadAddr64()</a> and <a class="el" href="wdc__lib_8h_ac458858f26b4042168954e9218bbbe13.html#ac458858f26b4042168954e9218bbbe13" title="writes 1 byte (8 bits) to a specified memory or I/O address.">WDC_WriteAddr8()</a> / <a class="el" href="wdc__lib_8h_a253ae691b9765714785e66a57798c818.html#a253ae691b9765714785e66a57798c818" title="writes 2 byte (16 bits) to a specified memory or I/O address.">WDC_WriteAddr16()</a> / <a class="el" href="wdc__lib_8h_a6b5a874590eadf62b4bf9c090f09886d.html#a6b5a874590eadf62b4bf9c090f09886d" title="writes 4 byte (32 bits) to a specified memory or I/O address.">WDC_WriteAddr32()</a> / <a class="el" href="wdc__lib_8h_add71342f5ab0dec9921e81859adbd9c8.html#add71342f5ab0dec9921e81859adbd9c8" title="writes 8 byte (64 bits) to a specified memory or I/O address.">WDC_WriteAddr64()</a> functions — with the exception of <a class="el" href="wdc__lib_8h_a4d758b86edaa43e4a07f378e176341d1.html#a4d758b86edaa43e4a07f378e176341d1" title="Reads a block of data from the device.">WDC_ReadAddrBlock()</a> and <a class="el" href="wdc__lib_8h_a543e6b1e8ad8158c00f734b8a0bb5358.html#a543e6b1e8ad8158c00f734b8a0bb5358" title="Writes a block of data to the device.">WDC_WriteAddrBlock()</a> — access memory addresses directly, using the correct mapping, based on the calling context (user mode/kernel mode).</p>
<p >When using the low-level WD_xxx() APIs, the user-mode and kernel-mode mappings of the card's physical memory regions are returned by <a class="el" href="windrvr_8h_a4458f37f4b52cbd6de13323100ea2097.html#a4458f37f4b52cbd6de13323100ea2097" title="Card registration function.">WD_CardRegister()</a> within the pTransAddr and pUserDirectAddr fields of the <code>pCardReg-&gt;Card.Item[i]</code> card resource item structures. The pTransAddr result should be used as a base address in calls to <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> or <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a> or when accessing memory directly from a Kernel PlugIn driver (<a class="el" href="ch12_understanding_the_kernel_plugin.html">Chapter 12: Understanding the Kernel PlugIn</a>).</p>
<p >To access the memory directly from your user-mode process, use pUserDirectAddr as a regular pointer. Whatever the method you select to access the memory on your card, it is important to align the base address according to the size of the data type, especially when issuing string transfer commands. Otherwise, the transfers are split into smaller portions.</p>
<p >The easiest way to align data is to use basic types when defining a buffer, i.e.:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="windrvr_8h_a4ae1dab0fb4b072a66584546209e7d58.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> buf[len]; <span class="comment">/* for BYTE transfers - not aligned */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_a2b0e863dadf920709ec53d9088ee7c91.html#a2b0e863dadf920709ec53d9088ee7c91">WORD</a> buf[len]; <span class="comment">/* for WORD transfers - aligned on a 2-byte boundary */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> buf[len]; <span class="comment">/* for DWORD transfers - aligned on a 4-byte boundary */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> buf[len]; <span class="comment">/* for QWORD transfers - aligned on a 8-byte boundary */</span></div>
<div class="ttc" id="awindrvr_8h_a2b0e863dadf920709ec53d9088ee7c91_html_a2b0e863dadf920709ec53d9088ee7c91"><div class="ttname"><a href="windrvr_8h_a2b0e863dadf920709ec53d9088ee7c91.html#a2b0e863dadf920709ec53d9088ee7c91">WORD</a></div><div class="ttdeci">unsigned short int WORD</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00316">windrvr.h:316</a></div></div>
<div class="ttc" id="awindrvr_8h_a4ae1dab0fb4b072a66584546209e7d58_html_a4ae1dab0fb4b072a66584546209e7d58"><div class="ttname"><a href="windrvr_8h_a4ae1dab0fb4b072a66584546209e7d58.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></div><div class="ttdeci">unsigned char BYTE</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00315">windrvr.h:315</a></div></div>
<div class="ttc" id="awindrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9_html_aae17ebb9ef7279d026817fb22f8aebe9"><div class="ttname"><a href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a></div><div class="ttdeci">unsigned __int64 UINT64</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00297">windrvr.h:297</a></div></div>
<div class="ttc" id="awindrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018_html_ae1e6edbbc26d6fbc71a90190d0266018"><div class="ttname"><a href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a></div><div class="ttdeci">unsigned int UINT32</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00320">windrvr.h:320</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="ch11_1_3_2_block_transfers_and_grouping_multiple_transfers_burst_transfer"></a>
11.1.3.2. Block Transfers and Grouping Multiple Transfers (Burst Transfer)</h3>
<p >The main methods for transferring large amounts of data between PCI-device memory addresses and a host machine’s random-access memory (RAM) are block transfers (which may or may not result in PCI burst transfers), and bus-master DMA.</p>
<p >Block transfers are easier to implement, but DMA is much more effective and reliable for transferring large amounts of data, as explained in <a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a>.</p>
<p >You can use the WinDriver <a class="el" href="wdc__lib_8h_a4d758b86edaa43e4a07f378e176341d1.html#a4d758b86edaa43e4a07f378e176341d1" title="Reads a block of data from the device.">WDC_ReadAddrBlock()</a> and <a class="el" href="wdc__lib_8h_a543e6b1e8ad8158c00f734b8a0bb5358.html#a543e6b1e8ad8158c00f734b8a0bb5358" title="Writes a block of data to the device.">WDC_WriteAddrBlock()</a> functions (or the low-level <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> function with a string command) to perform block (string) transfers — i.e., transfer blocks of data from the device memory (read) or to the device memory (write). You can use also <a class="el" href="wdc__lib_8h_a1c930425141ee9e086419280343b1969.html#a1c930425141ee9e086419280343b1969" title="Performs a group of memory and/or I/O read/write transfers.">WDC_MultiTransfer()</a> (or the low-level <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a> function) to group multiple block transfers into a single function call. This is more efficient than performing multiple single transfers. The WinDriver block-transfer functions use assembler string instructions (such as <code>REP MOVSD</code>, or a 64-bit MMX instruction for 64-bit transfers) to move a block of memory between PCI-mapped memory on the device and the host’s RAM. From a software perspective, this is the most that can be done to attempt to initiate PCI burst transfers.</p>
<p >The hardware uses PCI burst mode to perform burst transfers — i.e., transfer the data in “bursts” of block reads/writes, resulting in a small performance improvement compared to the alternative of single WORD transfers. Some host controllers implement burst transfers by grouping access to successive PCI addresses into PCI bursts.</p>
<p >The host-side software has no way to control whether a target PCI transfer is issued as a burst transfer. The most the host can do is initiate transfers using assembler string instructions — as done by the WinDriver block-transfer APIs — but there’s no guarantee that this will translate into burst transfers, as this is entirely up to the hardware. Most PCI host controllers support PCI burst mode for write transfers. It is generally less common to find similar burst-mode support for PCI readtransfers.</p>
<p >To sum it up, to transfer large amounts of data to/from memory addresses or I/O addresses (which by definition cannot be accessed directly, as opposed to memory addresses), use the following methods to improve performance by reducing the function calls overhead and context switches between the user and kernel modes:</p>
<ul>
<li>Perform block (string) transfers using <a class="el" href="wdc__lib_8h_a4d758b86edaa43e4a07f378e176341d1.html#a4d758b86edaa43e4a07f378e176341d1" title="Reads a block of data from the device.">WDC_ReadAddrBlock()</a> / <a class="el" href="wdc__lib_8h_a543e6b1e8ad8158c00f734b8a0bb5358.html#a543e6b1e8ad8158c00f734b8a0bb5358" title="Writes a block of data to the device.">WDC_WriteAddrBlock()</a> , or the low-level <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> function.</li>
<li>Group several transfers into a single function call, using <a class="el" href="wdc__lib_8h_a1c930425141ee9e086419280343b1969.html#a1c930425141ee9e086419280343b1969" title="Performs a group of memory and/or I/O read/write transfers.">WDC_MultiTransfer()</a> or the low-level <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a> function.</li>
</ul>
<h3><a class="anchor" id="ch11_1_3_3_performing_64-bit_data_transfers"></a>
11.1.3.3. Performing 64-Bit Data Transfers</h3>
<p >The ability to perform actual 64-bit transfers is dependent on the existence of support for such transfers by the hardware, CPU, bridge, etc., and can be affected by any of these factors or their specific combination.</p>
<p >WinDriver supports 64-bit PCI data transfers on the supported 64-bit platforms, as well as on Windows and Linux 32-bit x86 platforms. If your PCI hardware (card and bus) is 64-bit, the ability to perform 64-bit data transfers on 32-bit platforms will enable you to utilize your hardware's broader bandwidth, even if your host operating system is only 32-bit.</p>
<p >However, note that:</p>
<ul>
<li>The ability to perform actual 64-bit transfers requires that such transfers be supported by the hardware — including the CPU, the PCI card, the PCI host controller, and the PCI bridge — and it can be affected by any of these components or their specific combination.</li>
<li>The conventional wisdom among hardware engineers is that performing two 32-bit DWORD transfers is more efficient than performing a single 64-bit QWORD transfer; the reason is that the 64-bit transfer requires an additional CPU cycle to negotiate a 64-bit transfer mode, and this cycle can be used, instead, to perform a second 32-bit transfer. Therefore, performing 64-bit transfers is generally more advisable if you wish to transfer more than 64 bits of data in a single burst.</li>
</ul>
<p >This innovative technology makes possible data transfer rates previously unattainable on 32-bit platforms. Drivers developed using WinDriver will attain significantly better performance results than drivers written with the WDK or other driver development tools.</p>
<p >To date, such tools do not enable 64-bit data transfer on x86 platforms running 32-bit operating systems. Jungo's benchmark performance testing results for 64-bit data transfer indicate a significant improvement of data transfer rates compared to 32-bit data transfer, guaranteeing that drivers developed with WinDriver will achieve far better performance than 32-bit data transfer normally allows.</p>
<p >You can perform 64-bit data transfers using any of the following methods:</p>
<ul>
<li>Call <a class="el" href="wdc__lib_8h_aeed668a016ac973f91dd666b6ceadaba.html#aeed668a016ac973f91dd666b6ceadaba" title="reads 8 byte (64 bits) from a specified memory or I/O address.">WDC_ReadAddr64()</a> or <a class="el" href="wdc__lib_8h_add71342f5ab0dec9921e81859adbd9c8.html#add71342f5ab0dec9921e81859adbd9c8" title="writes 8 byte (64 bits) to a specified memory or I/O address.">WDC_WriteAddr64()</a> .</li>
<li>Call <a class="el" href="wdc__lib_8h_a4d758b86edaa43e4a07f378e176341d1.html#a4d758b86edaa43e4a07f378e176341d1" title="Reads a block of data from the device.">WDC_ReadAddrBlock()</a> with an access mode of WDC_SIZE_64 .</li>
<li>Call <a class="el" href="wdc__lib_8h_a1c930425141ee9e086419280343b1969.html#a1c930425141ee9e086419280343b1969" title="Performs a group of memory and/or I/O read/write transfers.">WDC_MultiTransfer()</a> or the low-level <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> or <a class="el" href="windrvr_8h_a47d9652ae5036119969b08ea06d52161.html#a47d9652ae5036119969b08ea06d52161" title="Executes multiple read/write instructions to I/O ports and/or memory addresses.">WD_MultiTransfer()</a> functions with QWORD read/write transfer commands (see the documentation of these functions for details).</li>
</ul>
<p >You can also perform 64-bit transfers to/from the PCI configuration space using <a class="el" href="wdc__lib_8h_a9a360c5b140e8d839f18f4df0751fae4.html#a9a360c5b140e8d839f18f4df0751fae4" title="Reads 8 bytes (64 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg64()</a> and <a class="el" href="wdc__lib_8h_a14c0d130cdebdf917359c940f7bf80ef.html#a14c0d130cdebdf917359c940f7bf80ef" title="Reads 8 bytes (64 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfgBySlot64()</a> / <a class="el" href="wdc__lib_8h_a4b20d1d04030b3fac7d9d197efde0a5b.html#a4b20d1d04030b3fac7d9d197efde0a5b" title="writes 8 bytes (64 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express...">WDC_PciWriteCfgBySlot64()</a> .</p>
<p >The best way to improve the performance of large PCI memory data transfers is by using bus-master direct memory access (DMA), and not by performing block transfers (which as explained above, may or may not result in PCI burst transfers).</p>
<p >Most PCI architectures today provide DMA capability, which enables data to be transferred directly between memory-mapped addresses on the PCI device and the host’s RAM, freeing the CPU from involvement in the data transfer and thus improving the host’s performance.</p>
<p >DMA data-buffer sizes are limited only by the size of the host’s RAM and the available memory.</p>
<h1><a class="anchor" id="ch11_2_performing_direct_memory_access_dma"></a>
11.2. Performing Direct Memory Access (DMA)</h1>
<p >This section describes how to use WinDriver to implement bus-master <b>Direct Memory Access (DMA)</b> for devices capable of acting as bus masters. Such devices have a DMA controller, which the driver should program directly.</p>
<p >DMA is a capability provided by some computer bus architectures — including PCI and PCIe — which allows data to be sent directly from an attached device to the memory on the host, freeing the CPU from involvement with the data transfer and thus improving the host's performance.</p>
<p >A DMA buffer can be allocated in two ways:</p>
<ul>
<li><b>Contiguous buffer</b> — A contiguous block of memory is allocated.</li>
<li><b>Scatter/Gather</b> — The allocated buffer can be fragmented in the physical memory and does not need to be allocated contiguously. The allocated physical memory blocks are mapped to a contiguous buffer in the calling process's virtual address space, thus enabling easy access to the allocated physical memory blocks.</li>
</ul>
<p >The programming of a device's DMA controller is hardware specific. Normally, you need to program your device with the local address (on your device), the host address (the physical memory address on your PC) and the transfer count (the size of the memory block to transfer), and then set the register that initiates the transfer.</p>
<p >WinDriver provides you with API for implementing both contiguous-buffer DMA and Scatter/Gather DMA (if supported by the hardware) — see the description of <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a>, and <a class="el" href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155" title="Unlocks and frees the memory allocated for a DMA buffer by a previous call to WDC_DMAContigBufLock(),...">WDC_DMABufUnlock()</a> .</p>
<p >The following sections include code samples that demonstrate how to use WinDriver to implement Scatter/Gather DMA and contiguous-buffer DMA, and an explanation on how to preallocate contiguous DMA buffers on Windows.</p>
<p >The sample routines demonstrate using either an interrupt mechanism or a polling mechanism to determine DMA completion.</p>
<p >The sample routines allocate a DMA buffer and enable DMA interrupts (if polling is not used) and then free the buffer and disable the interrupts (if enabled) for each DMA transfer. However, when you implement your actual DMA code, you can allocate DMA buffer(s) once, at the beginning of your application, enable the DMA interrupts (if polling is not used), then perform DMA transfers repeatedly, using the same buffer(s), and disable the interrupts (if enabled) and free the buffer(s) only when your application no longer needs to perform DMA.</p>
<h2><a class="anchor" id="ch11_2_1_implementing_scatter-gather_dma"></a>
11.2.1. Implementing Scatter/Gather DMA</h2>
<p >Following is a sample routine that uses WinDriver's WDC API to allocate a Scatter/Gather DMA buffer and perform bus-master DMA transfers.</p>
<h3><a class="anchor" id="ch11_2_1_1_c_example_implementing_scatter-gather_dma"></a>
11.2.1.1. C Example</h3>
<p >A more detailed example, which is specific to the enhanced support for PLX chipsets can be found in the <br  />
 <code>WinDriver/samples/c/plx/lib/plx_lib.c</code> library file and <br  />
 <code>WinDriver/samples/c/plx/diag_lib/plx_diag_lib.c</code> diagnostics library file (which utilizes the <code>plx_lib.c</code> DMA API).</p>
<div class="fragment"><div class="line">BOOL DMARoutine(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, DWORD dwDMABufSize,</div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, BOOL fPolling, BOOL fToDev)</div>
<div class="line">{</div>
<div class="line">    PVOID pBuf;</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    <span class="comment">/* Allocate a user-mode buffer for Scatter/Gather DMA */</span></div>
<div class="line">    pBuf = <a class="code hl_function" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a>(dwDMABufSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!pBuf)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Lock the DMA buffer and program the DMA controller */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMAOpen(hDev, pBuf, u32LocalAddr, dwDMABufSize, fToDev, &amp;pDma))</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!MyDMAInterruptEnable(hDev, MyDmaIntHandler, pDma))</div>
<div class="line">            <span class="keywordflow">goto</span> Exit; <span class="comment">/* Failed enabling DMA interrupts */</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Flush the CPU caches (see documentation of WDC_DMASyncCpu()) */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a47d7ef797133fee963afc724869e1865.html#a47d7ef797133fee963afc724869e1865">WDC_DMASyncCpu</a>(pDma);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to initiate the DMA transfer */</span></div>
<div class="line">    MyDMAStart(hDev, pDma);</div>
<div class="line">    <span class="comment">/* Wait for the DMA transfer to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(hDev, pDma, fPolling);</div>
<div class="line">    <span class="comment">/* Flush the I/O caches (see documentation of WDC_DMASyncIo()) */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a17c967a5232aa89d4cb252e0194e0223.html#a17c967a5232aa89d4cb252e0194e0223">WDC_DMASyncIo</a>(pDma);</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line"> </div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(hDev, pDma, fPolling);</div>
<div class="line">    <a class="code hl_function" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a>(pBuf);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAOpen: Locks a Scatter/Gather DMA buffer */</span></div>
<div class="line">BOOL DMAOpen(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, PVOID pBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, DWORD dwDMABufSize, BOOL fToDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> **ppDma)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus, i;</div>
<div class="line">    DWORD dwOptions = fToDev ? <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b">DMA_TO_DEVICE</a> : <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec">DMA_FROM_DEVICE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Lock a Scatter/Gather DMA buffer */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93">WDC_DMASGBufLock</a>(hDev, pBuf, dwOptions, dwDMABufSize, ppDma);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed locking a Scatter/Gather DMA buffer. Error 0x%lx - %s\n&quot;</span>,</div>
<div class="line">        dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Program the device&#39;s DMA registers for each physical page */</span></div>
<div class="line">    MyDMAProgram((*ppDma)-&gt;Page, (*ppDma)-&gt;dwPages, fToDev, u32LocalAddr);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* DMAClose: Unlocks a previously locked Scatter/Gather DMA buffer */</span></div>
<div class="line"><span class="keywordtype">void</span> DMAClose(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    MyDMAInterruptDisable(hDev);</div>
<div class="line">    <span class="comment">/* Unlock and free the DMA buffer */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155">WDC_DMABufUnlock</a>(pDma);</div>
<div class="line">}</div>
<div class="ttc" id="akpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00268">kpstdlib.h:268</a></div></div>
<div class="ttc" id="akpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9_html_a736d9ab37afc2ba50e25346a3d49a8d9"><div class="ttname"><a href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a></div><div class="ttdeci">void *__cdecl malloc(unsigned long size)</div></div>
<div class="ttc" id="akpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d_html_aa8cecfc5c5c054d2875c03e77b7be15d"><div class="ttname"><a href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a></div><div class="ttdeci">#define TRUE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00264">kpstdlib.h:264</a></div></div>
<div class="ttc" id="akpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1_html_aa93f0eb578d23995850d61f7d61c55c1"><div class="ttname"><a href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a></div><div class="ttdeci">#define FALSE</div><div class="ttdef"><b>Definition:</b> <a href="kpstdlib_8h_source.html#l00260">kpstdlib.h:260</a></div></div>
<div class="ttc" id="akpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650_html_acc3b4a8c7b4ba9ec1fd2138ca3f6f650"><div class="ttname"><a href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a></div><div class="ttdeci">void __cdecl free(void *buf)</div></div>
<div class="ttc" id="astatus__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288_html_a8bc5849b8718e5f3a60bd8b1ef001288"><div class="ttname"><a href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a></div><div class="ttdeci">const char *DLLCALLCONV Stat2Str(_In_ DWORD dwStatus)</div><div class="ttdoc">Retrieves the status string that corresponds to a status code.</div></div>
<div class="ttc" id="astructWD__DMA_html"><div class="ttname"><a href="structWD__DMA.html">WD_DMA</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00508">windrvr.h:509</a></div></div>
<div class="ttc" id="awdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93_html_a08bdeefcdb49c8d3313462ec463b2d93"><div class="ttname"><a href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93">WDC_DMASGBufLock</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMASGBufLock(_In_ WDC_DEVICE_HANDLE hDev, _In_ PVOID pBuf, _In_ DWORD dwOptions, _In_ DWORD dwDMABufSize, _Outptr_ WD_DMA **ppDma)</div><div class="ttdoc">Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...</div></div>
<div class="ttc" id="awdc__lib_8h_a17c967a5232aa89d4cb252e0194e0223_html_a17c967a5232aa89d4cb252e0194e0223"><div class="ttname"><a href="wdc__lib_8h_a17c967a5232aa89d4cb252e0194e0223.html#a17c967a5232aa89d4cb252e0194e0223">WDC_DMASyncIo</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMASyncIo(_In_ WD_DMA *pDma)</div><div class="ttdoc">Synchronizes the I/O caches with the DMA buffer, by flushing the data from the I/O caches and updatin...</div></div>
<div class="ttc" id="awdc__lib_8h_a47d7ef797133fee963afc724869e1865_html_a47d7ef797133fee963afc724869e1865"><div class="ttname"><a href="wdc__lib_8h_a47d7ef797133fee963afc724869e1865.html#a47d7ef797133fee963afc724869e1865">WDC_DMASyncCpu</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMASyncCpu(_In_ WD_DMA *pDma)</div><div class="ttdoc">Synchronizes the cache of all CPUs with the DMA buffer, by flushing the data from the CPU caches.</div></div>
<div class="ttc" id="awdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155_html_a5bde92ce8231d56ffe1aff172ccb6155"><div class="ttname"><a href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155">WDC_DMABufUnlock</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMABufUnlock(_In_ WD_DMA *pDma)</div><div class="ttdoc">Unlocks and frees the memory allocated for a DMA buffer by a previous call to WDC_DMAContigBufLock(),...</div></div>
<div class="ttc" id="awdc__lib_8h_afe93a4914e351fedf921e137fa525e7f_html_afe93a4914e351fedf921e137fa525e7f"><div class="ttname"><a href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a></div><div class="ttdeci">void * WDC_DEVICE_HANDLE</div><div class="ttdoc">Handle to device information struct.</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l00033">wdc_lib.h:33</a></div></div>
<div class="ttc" id="awindrvr_8h_a4be61f088cf6870c6ff37ab94aba215c_html_a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41"><div class="ttname"><a href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a></div><div class="ttdeci">@ WD_STATUS_SUCCESS</div><div class="ttdoc">[0] Operation completed successfully</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01041">windrvr.h:1041</a></div></div>
<div class="ttc" id="awindrvr_8h_ada5365d842d0c9e6e733231afd74e555_html_ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b"><div class="ttname"><a href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b">DMA_TO_DEVICE</a></div><div class="ttdeci">@ DMA_TO_DEVICE</div><div class="ttdoc">memory pages are locked to be read by device</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00437">windrvr.h:437</a></div></div>
<div class="ttc" id="awindrvr_8h_ada5365d842d0c9e6e733231afd74e555_html_ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec"><div class="ttname"><a href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec">DMA_FROM_DEVICE</a></div><div class="ttdeci">@ DMA_FROM_DEVICE</div><div class="ttdoc">memory pages are locked to be written by device</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00435">windrvr.h:434</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="ch11_2_1_2_c-sharp_example_implementing_scatter-gather_dma"></a>
11.2.1.2. C# Example</h3>
<p >A more detailed example, which is specific to the enhanced support for PLX chipsets can be found in the <code>WinDriver/samples/c/plx/dotnet/lib/</code> library and <code>WinDriver/samples/c/plx/dotnet/diag/</code> diagnostics library.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> DMARoutine(PCI_Device dev, DWORD dwDMABufSize, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, <span class="keywordtype">bool</span> fPolling, <span class="keywordtype">bool</span> fToDev, IntHandler MyDmaIntHandler)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> fRet = <span class="keyword">false</span>;</div>
<div class="line">    IntPtr pBuf = IntPtr.Zero;</div>
<div class="line">    Log log = <span class="keyword">new</span> Log(<span class="keyword">new</span> Log.TRACE_LOG(TraceLog),</div>
<div class="line">    <span class="keyword">new</span> Log.ERR_LOG(ErrLog));</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> wdDma = <span class="keyword">new</span> <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a>();</div>
<div class="line">    DmaBuffer dmaBuf = <span class="keyword">new</span> DmaBufferSG(dev, log);</div>
<div class="line">    <span class="comment">/* Allocate user mode buffer for Scatter/Gather DMA */</span></div>
<div class="line">    pBuf = Marshal.AllocHGlobal((<span class="keywordtype">int</span>)dwDMABufSize);</div>
<div class="line">    <span class="keywordflow">if</span> (pBuf == IntPtr.Zero)</div>
<div class="line">    {</div>
<div class="line">        fRet = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Lock the DMA buffer and program the DMA controller */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMAOpen(ref dmaBuf, pBuf, u32LocalAddr, dwDMABufSize,  fToDev, ref wdDma))</div>
<div class="line">    {</div>
<div class="line">        fRet = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!MyDMAInterruptEnable(dev, MyDmaIntHandler, ref wdDma))</div>
<div class="line">        {</div>
<div class="line">            fRet = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">goto</span> Exit; <span class="comment">/* Failed enabling DMA interrupts */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Flush the CPU caches (see documentation of WDC_DMASyncCpu()) */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMASyncCpu(dmaBuf.pWdDma);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to initiate the DMA transfer */</span></div>
<div class="line">    MyDmaStart(dev, ref wdDma);</div>
<div class="line">    <span class="comment">/* Wait for the DMA transfer to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(dev, ref wdDma, fPolling);</div>
<div class="line">    <span class="comment">/* Flush the I/O caches (see documentation of WDC_DMASyncIo()) */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMASyncIo(dmaBuf.pWdDma);</div>
<div class="line">    fRet = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(dev, dmaBuf, fPolling);</div>
<div class="line">    <span class="keywordflow">if</span> (pBuf != IntPtr.Zero)</div>
<div class="line">        Marshal.FreeHGlobal(pBuf);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* OpenDMA: Locks a Scatter/Gather DMA buffer */</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">bool</span> DMAOpen(ref DmaBuffer dmaBuf, IntPtr pBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, DWORD bufSize, <span class="keywordtype">bool</span> fToDev, ref <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> wdDma)</div>
<div class="line">{</div>
<div class="line">    IntPtr pDma = dmaBuf.pWdDma;</div>
<div class="line">    <a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev = dmaBuf.DeviceHandle;</div>
<div class="line">    DWORD dwOptions = fToDev ? (DWORD)<a class="code hl_enumeration" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>.DMA_TO_DEVICE :</div>
<div class="line">    (DWORD)<a class="code hl_enumeration" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>.DMA_FROM_DEVICE;</div>
<div class="line"> </div>
<div class="line">    wdDma = MarshalDMA(pDma);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Lock a Scatter/Gather DMA buffer */</span></div>
<div class="line">    <span class="keywordflow">if</span> (wdc_lib_decl.WDC_DMASGBufLock(hDev, pBuf, dwOptions, bufSize, ref pDma) != (DWORD)wdc_err.WD_STATUS_SUCCESS)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Program the device&#39;s DMA registers for each physical page */</span></div>
<div class="line">    MyDMAProgram(fToDev, wdDma.Page[0], wdDma.dwPages, u32LocalAddr);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAClose: Unlocks a previously locked Scatter/Gather DMA buffer */</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> DMAClose(PCI_Device dev, DmaBuffer dmaBuf, <span class="keywordtype">bool</span> fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">        MyDMAInterruptDisable(dev);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Unlock and free the DMA buffer */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMABufUnlock(dmaBuf.pWdDma);</div>
<div class="line">}</div>
<div class="ttc" id="awindrvr_8h_ada5365d842d0c9e6e733231afd74e555_html_ada5365d842d0c9e6e733231afd74e555"><div class="ttname"><a href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a></div><div class="ttdeci">WD_DMA_OPTIONS</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00416">windrvr.h:416</a></div></div>
</div><!-- fragment --><p >Notice the difference between ref <a class="el" href="structWD__DMA.html">WD_DMA</a> wdDma and IntPtr pWdDma. The former is used by C# user functions, while the latter is used by WDC API C functions, that can only take a pointer, not a reference.</p>
<h3><a class="anchor" id="ch11_2_1_3_what_should_you_implement_implementing_scatter_gather_dma"></a>
11.2.1.3. What Should You Implement?</h3>
<p >In the code sample above, it is up to you to implement the following MyDMAxxx() routines, according to your device's specification:</p>
<ul>
<li>MyDMAProgram(): Program the device's DMA registers. Refer the device's data sheet for the details.</li>
<li>MyDMAStart(): Write to the device to initiate DMA transfers.</li>
<li>MyDMAInterruptEnable() and MyDMAInterruptDisable(): Use <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> / <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> (respectively) to enable/disable the software interrupts and write/read the relevant register(s) on the device in order to physically enable/disable the hardware DMA interrupts <br  />
 (see <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a> for details regarding interrupt handling with WinDriver.)</li>
<li>MyDMAWaitForCompletion(): Poll the device for completion or wait for "DMA DONE" interrupt.</li>
<li>MyDmaIntHandler: The device's interrupt handler. IntHandler is a pointer to a function prototype of your choice.</li>
</ul>
<p >When using the basic WD_xxx API to allocate a Scatter/Gather DMA buffer that is larger than 1MB, you need to set the [DMA_LARGE_BUFFER] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a9d5b8bed9d9e8bdf452736b6dc5a5f0d">DMA_LARGE_BUFFER</a>) flag in the call to <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a> and allocate memory for the additional memory pages.</p>
<p >However, when using <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> to allocate the DMA buffer, you do not need any special implementation for allocating large buffers, since the function handles this for you.</p>
<h2><a class="anchor" id="ch11_2_2_implementing_contiguous-buffer_dma"></a>
11.2.2. Implementing Contiguous-Buffer DMA</h2>
<p >Following is a sample routine that uses WinDriver's WDC API to allocate a contiguous DMA buffer and perform bus-master DMA transfers.</p>
<p >For more detailed, hardware-specific, contiguous DMA examples, refer to the following enhanced-support chipset sample library files:</p>
<ul>
<li>PLX — <code>WinDriver/samples/c/plx/lib/plx_lib.c</code> and <br  />
 <code>WinDriver/samples/c/plx/diag_lib/plx_diag_lib.c</code> <br  />
 (which utilizes the <code>plx_lib.c</code> DMA API)</li>
<li>Xilinx Bus Master DMA (BMD) design — <code>WinDriver/samples/c/xilinx/bmd_design/bmd_lib.c</code></li>
</ul>
<h3><a class="anchor" id="ch11_2_2_1_c_example_implementing_contiguous-buffer_dma"></a>
11.2.2.1. C Example</h3>
<div class="fragment"><div class="line">BOOL DMARoutine(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, DWORD dwDMABufSize,</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, BOOL fPolling, BOOL fToDev)</div>
<div class="line">{</div>
<div class="line">    PVOID pBuf = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Allocate a DMA buffer and open DMA for the selected channel */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMAOpen(hDev, &amp;pBuf, u32LocalAddr, dwDMABufSize, fToDev, &amp;pDma))</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!MyDMAInterruptEnable(hDev, MyDmaIntHandler, pDma))</div>
<div class="line">            <span class="keywordflow">goto</span> Exit; <span class="comment">/* Failed enabling DMA interrupts */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Flush the CPU caches (see documentation of WDC_DMASyncCpu()) */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a47d7ef797133fee963afc724869e1865.html#a47d7ef797133fee963afc724869e1865">WDC_DMASyncCpu</a>(pDma);</div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to initiate the DMA transfer */</span></div>
<div class="line">    MyDMAStart(hDev, pDma);</div>
<div class="line">    <span class="comment">/* Wait for the DMA transfer to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(hDev, pDma, fPolling);</div>
<div class="line">    <span class="comment">/* Flush the I/O caches (see documentation of WDC_DMASyncIo()) */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a17c967a5232aa89d4cb252e0194e0223.html#a17c967a5232aa89d4cb252e0194e0223">WDC_DMASyncIo</a>(pDma);</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(hDev, pDma, fPolling);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAOpen: Allocates and locks a contiguous DMA buffer */</span></div>
<div class="line">BOOL DMAOpen(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, PVOID *ppBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr,</div>
<div class="line">    DWORD dwDMABufSize, BOOL fToDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> **ppDma)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line">    DWORD dwOptions = fToDev ? <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b">DMA_TO_DEVICE</a> : <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec">DMA_FROM_DEVICE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Allocate and lock a contiguous DMA buffer */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5">WDC_DMAContigBufLock</a>(hDev, ppBuf, dwOptions, dwDMABufSize, ppDma);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed locking a contiguous DMA buffer. Error 0x%lx - %s\n&quot;</span>,</div>
<div class="line">            dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Program the device&#39;s DMA registers for the physical DMA page */</span></div>
<div class="line">    MyDMAProgram((*ppDma)-&gt;Page, (*ppDma)-&gt;dwPages, fToDev, u32LocalAddr);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAClose: Frees a previously allocated contiguous DMA buffer */</span></div>
<div class="line"><span class="keywordtype">void</span> DMAClose(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">        MyDMAInterruptDisable(hDev);</div>
<div class="line">    <span class="comment">/* Unlock and free the DMA buffer */</span></div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a5bde92ce8231d56ffe1aff172ccb6155.html#a5bde92ce8231d56ffe1aff172ccb6155">WDC_DMABufUnlock</a>(pDma);</div>
<div class="line">}</div>
<div class="ttc" id="awdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5_html_a95ffd06d0067799a13db513a87ddabe5"><div class="ttname"><a href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5">WDC_DMAContigBufLock</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMAContigBufLock(_In_ WDC_DEVICE_HANDLE hDev, _Outptr_ PVOID *ppBuf, _In_ DWORD dwOptions, _In_ DWORD dwDMABufSize, _Outptr_ WD_DMA **ppDma)</div><div class="ttdoc">Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...</div></div>
</div><!-- fragment --><h3><a class="anchor" id="ch11_2_2_2_c-sharp_example_implementing_contiguous-buffer_dma"></a>
11.2.2.2. C# Example</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> DMARoutine(PCI_Device dev, DWORD dwDMABufSize, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr,</div>
<div class="line">    <span class="keywordtype">bool</span> fPolling, <span class="keywordtype">bool</span> fToDev, IntHandler MyDmaIntHandler)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> fRet = <span class="keyword">false</span>;</div>
<div class="line">    IntPtr pBuf = IntPtr.Zero;</div>
<div class="line">    Log log = <span class="keyword">new</span> Log(<span class="keyword">new</span> Log.TRACE_LOG(TraceLog),</div>
<div class="line">    <span class="keyword">new</span> Log.ERR_LOG(ErrLog));</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> wdDma = <span class="keyword">new</span> <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a>();</div>
<div class="line">    DmaBuffer dmaBuf = <span class="keyword">new</span> DmaBufferContig(dev, log);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Lock the DMA buffer and program the DMA controller */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMAOpen(ref dmaBuf, pBuf, u32LocalAddr, dwDMABufSize,</div>
<div class="line">        fToDev, ref wdDma))</div>
<div class="line">    {</div>
<div class="line">        fRet = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!MyDMAInterruptEnable(dev, MyDmaIntHandler, ref wdDma))</div>
<div class="line">        {</div>
<div class="line">            fRet = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">goto</span> Exit; <span class="comment">/* Failed enabling DMA interrupts */</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Flush the CPU caches (see documentation of WDC_DMASyncCpu()) */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMASyncCpu(dmaBuf.pWdDma);</div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to initiate the DMA transfer */</span></div>
<div class="line">    MyDmaStart(dev, ref wdDma);</div>
<div class="line">    <span class="comment">/* Wait for the DMA transfer to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(dev, ref wdDma, fPolling);</div>
<div class="line">    <span class="comment">/* Flush the I/O caches (see documentation of WDC_DMASyncIo()) */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMASyncIo(dmaBuf.pWdDma);</div>
<div class="line">    fRet = <span class="keyword">true</span>;</div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(dev, dmaBuf, fPolling);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* OpenDMA: Locks a Contiguous DMA buffer */</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">bool</span> DMAOpen(ref DmaBuffer dmaBuf, IntPtr pBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr,</div>
<div class="line">    DWORD bufSize, <span class="keywordtype">bool</span> fToDev, ref <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> wdDma)</div>
<div class="line">{</div>
<div class="line">    IntPtr pDma = dmaBuf.pWdDma;</div>
<div class="line">    <a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev = dmaBuf.DeviceHandle;</div>
<div class="line">    DWORD dwOptions = fToDev ? (DWORD)<a class="code hl_enumeration" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>.DMA_TO_DEVICE :</div>
<div class="line">    (DWORD)<a class="code hl_enumeration" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>.DMA_FROM_DEVICE;</div>
<div class="line">    wdDma = MarshalDMA(pDma);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Lock a Scatter/Gather DMA buffer */</span></div>
<div class="line">    <span class="keywordflow">if</span> (wdc_lib_decl.WDC_DMAContigBufLock(hDev, ref pBuf, dwOptions,</div>
<div class="line">        bufSize, ref pDma) != (DWORD)wdc_err.WD_STATUS_SUCCESS)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Program the device&#39;s DMA registers for each physical page */</span></div>
<div class="line">    MyDMAProgram(fToDev, wdDma.Page[0], wdDma.dwPages, u32LocalAddr);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* DMAClose: Unlocks a previously locked Scatter/Gather DMA buffer */</span></div>
<div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> DMAClose(PCI_Device dev, DmaBuffer dmaBuf, <span class="keywordtype">bool</span> fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">        MyDMAInterruptDisable(dev);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Unlock and free the DMA buffer */</span></div>
<div class="line">    wdc_lib_decl.WDC_DMABufUnlock(dmaBuf.pWdDma);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="ch11_2_2_3_what_should_you_implement_implementing_contiguous-buffer_dma"></a>
11.2.2.3. What Should You Implement?</h3>
<p >In the code sample above, it is up to you to implement the following MyDMAxxx() routines, according to your device's specification:</p>
<ul>
<li>MyDMAProgram(): Program the device's DMA registers. Refer the device's data sheet for the details.</li>
<li>MyDMAStart(): Write to the device to initiate DMA transfers.</li>
<li>MyDMAInterruptEnable() and MyDMAInterruptDisable(): Use <a class="el" href="wdc__lib_8h_a0de3da14960f4ffc8d02350506808c4c.html#a0de3da14960f4ffc8d02350506808c4c" title="Enables interrupt handling for the device.">WDC_IntEnable()</a> / <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> (respectively) to enable/disable the software interrupts and write/read the relevant register(s) on the device in order to physically enable/disable the hardware DMA interrupts <br  />
 (see <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a> for details regarding interrupt handling with WinDriver.)</li>
<li>MyDMAWaitForCompletion(): Poll the device for completion or wait for "DMA DONE" interrupt.</li>
<li>MyDmaIntHandler: The device's interrupt handler. IntHandler is a pointer to a function prototype of your choice.</li>
</ul>
<h3><a class="anchor" id="ch11_2_2_4_preallocating_contiguous_dma_buffers_on_windows"></a>
11.2.2.4. Preallocating Contiguous DMA Buffers on Windows</h3>
<p >WinDriver doesn't limit the size of the DMA buffer that can be allocated using its DMA APIs. However, the success of the DMA allocation is dependent on the amount of available system resources at the time of the allocation. Therefore, the earlier you try to allocate the buffer, the better your chances of succeeding.</p>
<p >WinDriver for Windows allows you to configure your device INF file to preallocate contiguous DMA buffers at boot time, thus increasing the odds that the allocation(s) will succeed. You may preallocate a maximum of 512 buffers: — 256 host-to-device buffers and/or 256 device-to-host buffers.</p>
<p >There are 2 ways to preallocate contiguous DMA buffers on Windows: directly from the DriverWizard, or manually via editing the INF file.</p>
<p ><b>Directly from DriverWizard</b>:</p>
<ul>
<li>In DriverWizard, start a new project, select a device from the list and click <b>Generate .INF file</b>.</li>
<li>Check Preallocate Host-To-Device DMA Buffers and/or Preallocate Device-To-Host DMA Buffers to enable the text boxes under each checkbox.</li>
<li>Adjust the Size, Count and Flags parameters as desired. The supported WinDriver DMA flags are documented in the [WD_DMA_OPTIONS] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>) enum.</li>
<li>Click <b>Next</b>, and you will then be prompted to choose a filename for your .INF file. After choosing a filename, the INF file will be created and ready to use, with your desired parameters.</li>
</ul>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;The Size and Flags fields must be hexadecimal numbers, formatted with the "0x" prefix, as shown below. </p>
</blockquote>
</blockquote>
<p><b>DriverWizard INF File Information</b></p>
<div class="image">
<img src="wiz_pci_inf_info.png" alt=""/>
</div>
 <p ><b>Manually by editing an existing INF file</b>:</p>
<ul>
<li>Add the required configuration under the <code>UpdateRegistryDevice</code> registry key in your device INF file, as shown below.</li>
</ul>
<p >The examples are for configuring preallocation of eight DMA buffers but you may, of-course, select to preallocate just one buffer (or none at all). To preallocate unidirectional buffers, add these lines:</p>
<div class="fragment"><div class="line">; Host-to-device DMA buffer:</div>
<div class="line">HKR,, &quot;DmaToDeviceCount&quot;,0x00010001,0x04 ; Number of preallocated</div>
<div class="line">                                         ; DMA_TO_DEVICE buffers</div>
<div class="line">HKR,, &quot;DmaToDeviceBytes&quot;,0x00010001,0x100000 ; Buffer size, in bytes</div>
<div class="line">HKR,, &quot;DmaToDeviceOptions&quot;,0x00010001,0x41 ; DMA flags (0x40=DMA_TO_DEVICE</div>
<div class="line">                                           ; + 0x1=DMA_KERNEL_BUFFER_ALLOC</div>
<div class="line">; Device-to-host DMA buffer:</div>
<div class="line">HKR,, &quot;DmaFromDeviceCount&quot;,0x00010001,0x04 ; Number of preallocated</div>
<div class="line">                                           ; DMA_FROM_DEVICE buffers</div>
<div class="line">HKR,, &quot;DmaFromDeviceBytes&quot;,0x00010001,0x100000 ; Buffer size, in bytes</div>
<div class="line">HKR,, &quot;DmaFromDeviceOptions&quot;,0x00010001,0x21 ; DMA flags (0x20=DMA_FROM_DEVICE</div>
<div class="line">                                             ; + 0x1=DMA_KERNEL_BUFFER_ALLOC)</div>
</div><!-- fragment --><ul>
<li>Edit the buffer sizes and add flags to the options masks in the INF file, as needed. Note, however, that the direction flags and the [DMA_KERNEL_BUFFER_ALLOC] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a0f3f567292f1d9799e9415869ca998e4">DMA_KERNEL_BUFFER_ALLOC</a>) flag must be set as shown in Step 1.</li>
</ul>
<p >The supported WinDriver DMA flags for the <code>dwOptions</code> field of the <a class="el" href="structWD__DMA.html">WD_DMA</a> struct are documented in [WD_DMA_OPTIONS] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555">WD_DMA_OPTIONS</a>).</p>
<p ><code>DmaFromDeviceCount</code> and <code>DmaFromDeviceCount</code> values are supported from version 12.4.0. If those values aren’t set value of 1 will be assumed.</p>
<p >The Wizard-generated and relevant sample WinDriver device INF files already contain the unidirectional buffers configuration lines, so you only need to remove the comment indicator ; at the start of each line. The examples are for configuring preallocation of 8 DMA buffers (4 for each direction), but you may, of-course, select to preallocate just one buffer (or none at all, by leaving the above code commented out).</p>
<p >In your code, the first n calls (if you configured the INF file to preallocate n DMA buffers) to the contiguous-DMA-lock function — <code><a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a></code> — should set parameter values that match the buffer configurations in the INF file:</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;For a device-to-host buffer, the DMA-options mask parameter (<code>dwOptions</code> / <code>pDma</code>-&gt;<code>dwOptions</code>) should contain the same DMA flags set in the <code>DmaFromDeviceOptions</code> registry key value, and the buffer-size parameter (<code>dwDMABufSize</code> / <code>pDma</code>-&gt;<code>dwBytes</code>) should be set to the value of the <code>DmaFromDeviceBytes</code> registry key value. For a host-to-device buffer, the DMA-options mask parameter (<code>dwOptions</code> / <code>pDma</code>-&gt;<code>dwOptions</code>) should contain the same flags set in the <code>DmaToDeviceOptions</code> registry key value, and the buffer-size parameter (<code>dwDMABufSize</code> / <code>pDma</code>-&gt;<code>dwBytes</code>) should be set to the value of the <code>DmaToDeviceBytes</code> registry key value. </p>
</blockquote>
</blockquote>
<p>In calls to <code><a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a></code>, the DMA configuration information is provided via dedicated function parameters — <code>dwDMABufSize</code> and <code>dwOptions</code>. In calls to <code><a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a></code>, the information is provided within the fields of the <code><a class="el" href="structWD__DMA.html">WD_DMA</a></code> struct pointed to by the <code>pDma</code> parameter — <code>pDma</code>-&gt;<code>dwBytes</code> and <code>pDma</code>-&gt;<code>dwOptions</code>.</p>
<p >When using <code><a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a></code> you don't need to explicitly set the [DMA_KERNEL_BUFFER_ALLOC] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a0f3f567292f1d9799e9415869ca998e4">DMA_KERNEL_BUFFER_ALLOC</a>) flag (which must be set in the INF-file configuration) because the function sets this flag automatically.</p>
<p >When using the low-level WinDriver <code><a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a></code> function, the DMA options are set in the function's <code>pDma</code>-&gt;<code>dwOptions</code> parameter — which must also include the [DMA_KERNEL_BUFFER_ALLOC] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a0f3f567292f1d9799e9415869ca998e4">DMA_KERNEL_BUFFER_ALLOC</a>) flag — and the buffer size is set in the <code>pDma</code>-&gt;<code>dwBytes</code> parameter.</p>
<p >If the buffer preallocation fails due to insufficient resources, you may need to increase the size of the non-paged pool (from which the memory is allocated).</p>
<h1><a class="anchor" id="ch11_3_performing_direct_memory_access_dma_transactions"></a>
11.3. Performing Direct Memory Access (DMA) transactions</h1>
<p >This section describes how to use WinDriver to implement bus-master Direct Memory Access (DMA) transactions for devices capable of acting as bus masters. Such devices have a DMA controller, which the driver should program directly.</p>
<p >DMA is a capability provided by some computer bus architectures — including PCI and PCIe — which allows data to be sent directly from an attached device to the memory on the host, freeing the CPU from involvement with the data transfer and thus improving the host's performance.</p>
<p >To understand the use of WinDriver's DMA transaction API, you must be familiar with the following concepts:</p>
<p ><b>DMA transaction</b></p>
<p >A DMA transaction is a complete I/O operation, such as a single read or write request from an application.</p>
<p ><b>DMA transfer</b></p>
<p >A DMA transfer is a single hardware operation that transfers data from computer memory to a device or from the device to computer memory.</p>
<p >A single DMA transaction always consists of at least one DMA transfer, but a transaction can consist of many transfers.</p>
<p >A DMA transaction buffer can be allocated in two ways:</p>
<ul>
<li><b>Contiguous buffer</b> — A contiguous block of memory is allocated.</li>
<li><b>Scatter/Gather (SG)</b> — The allocated buffer can be fragmented in the physical memory and does not need to be allocated contiguously. The allocated physical memory blocks are mapped to a contiguous buffer in the calling process's virtual address space, thus enabling easy access to the allocated physical memory blocks.</li>
</ul>
<p >The programming of a device's DMA controller is hardware specific. Normally, you need to program your device with the local address (on your device), the host address (the physical memory address on your PC) and the transfer count (the size of the memory block to transfer), and then set the register that initiates the transfer. WinDriver provides you with an API for implementing both Contiguous-Buffer DMA transactions and Scatter/Gather DMA transactions (if supported by the hardware) — see the description of <a class="el" href="wdc__lib_8h_a5a309ccd603c490085737d42b0c0e365.html#a5a309ccd603c490085737d42b0c0e365" title="Initializes the transaction, allocates a contiguous DMA buffer, locks it in physical memory,...">WDC_DMATransactionContigInit()</a>, <a class="el" href="wdc__lib_8h_a29b69c9bc746e1f526abf44f1b1f2162.html#a29b69c9bc746e1f526abf44f1b1f2162" title="Initializes the transaction and locks a pre-allocated user-mode memory buffer for DMA.">WDC_DMATransactionSGInit()</a>, <a class="el" href="wdc__lib_8h_a9d46d11094c1eb67990ab02cb274ced1.html#a9d46d11094c1eb67990ab02cb274ced1" title="Notifies WinDriver that a device&#39;s DMA transfer operation is completed.">WDC_DMATransferCompletedAndCheck()</a>, <a class="el" href="wdc__lib_8h_a37e6e178c0f6e37bd79e81d99ffcc3f0.html#a37e6e178c0f6e37bd79e81d99ffcc3f0" title="Terminates a specified DMA transaction without deleting the associated WD_DMA transaction structure.">WDC_DMATransactionRelease()</a> and <a class="el" href="wdc__lib_8h_a0f8200bb5c7b0808e5f54d57f5e9c17b.html#a0f8200bb5c7b0808e5f54d57f5e9c17b" title="Unlocks and frees the memory allocated for a DMA buffer transaction by a previous call to WDC_DMATran...">WDC_DMATransactionUninit()</a>.</p>
<p ><b>DMA transaction diagram</b></p>
<div class="image">
<img src="dma_transaction_diagram.png" alt=""/>
</div>
 <p >The following sections include code samples that demonstrate how to use WinDriver to implement a Scatter/Gather DMA transaction (see <a class="el" href="ch11_improving_pci_performance.html#ch11_2_1_implementing_scatter-gather_dma">11.2.1. Implementing Scatter/Gather DMA</a>) and a Contiguous-Buffer DMA transaction (see <a class="el" href="ch11_improving_pci_performance.html#ch11_2_2_implementing_contiguous-buffer_dma">11.2.2. Implementing Contiguous-Buffer DMA</a>).</p>
<p >The sample routines demonstrate using either an interrupt mechanism or a polling mechanism to determine DMA completion.</p>
<h2><a class="anchor" id="ch11_3_1_implementing_scatter-gather_dma_transactions"></a>
11.3.1. Implementing Scatter/Gather DMA transactions</h2>
<p >Following is a sample routine that uses WinDriver's WDC API to initialize a Scatter/Gather DMA transaction buffer and perform bus-master DMA transfers.</p>
<p >For more detailed, hardware-specific, Scatter Gather DMA transaction examples, refer to the following enhanced-support chipset (<a class="el" href="ch9_enhanced_support_for_specific_chipsets.html">Chapter 9: Enhanced Support for Specific Chipsets</a>) sample library files:</p>
<ul>
<li>PLX — <code>WinDriver/samples/c/plx/lib/plx_lib.c</code>, <code>WinDriver/samples/c/plx/diag_lib/plx_diag_lib.c</code> (which utilizes the plx_lib.c DMA API) and <code>WinDriver/samples/c/plx/9656/p9656_diag.c</code></li>
<li>XDMA design — <code>WinDriver/samples/c/xilinx/xdma/xdma_lib.c</code></li>
</ul>
<h3><a class="anchor" id="ch11_3_1_1_c_example_implementing_scatter-gather_dma_transactions"></a>
11.3.1.1. C Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAX_TRANSFER_SIZE 0xFFFF </span><span class="comment">/* According to the device limits */</span><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32PADR; <span class="comment">/* PCI address */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LADR; <span class="comment">/* Local address */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32SIZ; <span class="comment">/* Transfer size */</span></div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32DPR; <span class="comment">/* Next descriptor pointer */</span></div>
<div class="line">} MY_DMA_TRANSFER_ELEMENT; <span class="comment">/* DMA transfer element */</span></div>
<div class="line"> </div>
<div class="line">BOOL DMATransactionRoutine(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, DWORD dwDMABufSize,</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, BOOL fPolling, BOOL fToDev)</div>
<div class="line">{</div>
<div class="line">    PVOID pBuf;</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Allocate a user-mode buffer for a Scatter/Gather DMA transaction */</span></div>
<div class="line">    pBuf = <a class="code hl_function" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc</a>(dwDMABufSize);</div>
<div class="line">    <span class="keywordflow">if</span> (!pBuf)</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialize the DMA transaction */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionInit(hDev, pBuf, u32LocalAddr, dwDMABufSize, fToDev, &amp;pDma,</div>
<div class="line">        fPolling))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionExecute(hDev, pDma, fPolling))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Wait for the DMA transaction to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(hDev, pDma, fPolling);</div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionRelease(hDev, pDma))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The DMA transaction can be reused as many times as you like</span></div>
<div class="line"><span class="comment">    * Notice: after each call to DMATransactionExecute</span></div>
<div class="line"><span class="comment">    * (WDC_DMATransactionExecute) there must be a call to</span></div>
<div class="line"><span class="comment">    * DMATransactionRelease (WDC_DMATransactionRelease) */</span></div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(hDev, pDma, fPolling);</div>
<div class="line">    <a class="code hl_function" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a>(pBuf);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionInit: Initializes a Scatter/Gather DMA transaction buffer */</span></div>
<div class="line">BOOL DMATransactionInit(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, PVOID pBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr,</div>
<div class="line">    DWORD dwDMABufSize, BOOL fToDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> **ppDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus, dwNumCmds, i;</div>
<div class="line">    DWORD dwOptions = fToDev ? <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b">DMA_TO_DEVICE</a> : <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec">DMA_FROM_DEVICE</a>;</div>
<div class="line">    <a class="code hl_struct" href="structWD__TRANSFER.html">WD_TRANSFER</a> *pTrans;</div>
<div class="line">    <a class="code hl_struct" href="structWDC__INTERRUPT__PARAMS.html">WDC_INTERRUPT_PARAMS</a> interruptsParams;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        pTrans = GetMyTransCmds(&amp;dwNumCmds);</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_aad293fa3cdd74b1d4dcaca8d36795e22.html#aad293fa3cdd74b1d4dcaca8d36795e22">pTransCmds</a> = pTrans;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a8f09a15cc59933c26eaeb5c8136ad886.html#a8f09a15cc59933c26eaeb5c8136ad886">dwNumCmds</a> = dwNumCmds;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a792da0266327ca28d405a9540e0f3e17.html#a792da0266327ca28d405a9540e0f3e17">dwOptions</a> = <a class="code hl_enumvalue" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6">INTERRUPT_CMD_COPY</a>;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a0bf056911e1660f3449ee02e21f683b2.html#a0bf056911e1660f3449ee02e21f683b2">funcIntHandler</a> = MyDmaIntHandler;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a31466da9f049274b0a377122f79605ae.html#a31466da9f049274b0a377122f79605ae">pData</a> = hDev;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_ad38a68453c9ccb8e894aaea239aa0356.html#ad38a68453c9ccb8e894aaea239aa0356">fUseKP</a> = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialize a Scatter/Gather DMA transaction buffer */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a29b69c9bc746e1f526abf44f1b1f2162.html#a29b69c9bc746e1f526abf44f1b1f2162">WDC_DMATransactionSGInit</a>(hDev, pBuf, dwOptions, dwDMABufSize,</div>
<div class="line">        ppDma, &amp;interruptsParams, MAX_TRANSFER_SIZE,</div>
<div class="line">        <span class="keyword">sizeof</span>(MY_DMA_TRANSFER_ELEMENT));</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to initialize a Scatter/Gather DMA transaction buffer. Error &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;0x%lx - %s\n&quot;</span>, dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">Exit:</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionExecute: Executes the DMA transaction */</span></div>
<div class="line">BOOL DMATransactionExecute(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    DWORD dwPage;</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> u64Offset;</div>
<div class="line"> </div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a3df10832c06baa617828081a18482c28.html#a3df10832c06baa617828081a18482c28">WDC_DMATransactionExecute</a>(pDma, DMATransactionProgram, hDev);</div>
<div class="line">    <span class="keywordflow">if</span> (dwStatus != <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to execute DMA transaction. Error 0x%lx - %s\n&quot;</span>,</div>
<div class="line">            dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">Exit:</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionProgram: Programs the device&#39;s DMA registers and starts the</span></div>
<div class="line"><span class="comment">* DMA */</span></div>
<div class="line"><span class="keywordtype">void</span> DMATransactionProgram(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev)</div>
<div class="line">{</div>
<div class="line">    PDEV_CTX pDevCtx = (PDEV_CTX)<a class="code hl_function" href="wdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1.html#a4cc38c7f222c2d20cc40243b2fad51f1">WDC_GetDevContext</a>(hDev);</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = pDevCtx-&gt;pDma;</div>
<div class="line">    BOOL fToDev = pDevCtx-&gt;fToDev;</div>
<div class="line">    DWORD dwPage;</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> u64Offset;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The value of u64Offset is the required offset on the device */</span></div>
<div class="line">    u64Offset = pDevCtx-&gt;u32LocalAddr + pDma-&gt;<a class="code hl_variable" href="structWD__DMA_a2028ecf3810b1aab32d4a7c8ece67e7b.html#a2028ecf3810b1aab32d4a7c8ece67e7b">dwBytesTransferred</a>;</div>
<div class="line">    <span class="keywordflow">for</span> (dwPage = 0; dwPage &lt; pDma-&gt;<a class="code hl_variable" href="structWD__DMA_ae6a6a2d9f011d81b7cd2bd719a70433c.html#ae6a6a2d9f011d81b7cd2bd719a70433c">dwPages</a>; dwPage++)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* Use pDma-&gt;Page array, u64Offset, fToDev,...</span></div>
<div class="line"><span class="comment">        * to program the device&#39;s DMA registers for each physical page */</span></div>
<div class="line">        u64Offset += pDma-&gt;<a class="code hl_variable" href="structWD__DMA_acdd5c22660d80d6f3816ad8a15dc7e77.html#acdd5c22660d80d6f3816ad8a15dc7e77">Page</a>[dwPage].<a class="code hl_variable" href="structWD__DMA__PAGE_a3b430f83710faf4328d7040733f1445e.html#a3b430f83710faf4328d7040733f1445e">dwBytes</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Enable interrupts on hardware */</span></div>
<div class="line">    MyDMAInterruptHardwareEnable(hDev);</div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to start the DMA transfer */</span></div>
<div class="line">    MyDMAStart(hDev, pDma);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* MyDmaIntHandler: Interrupt handler */</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_define" href="windrvr_8h_abd951991ce3a6320fb0d1eee9350d35d.html#abd951991ce3a6320fb0d1eee9350d35d">DLLCALLCONV</a> MyDmaIntHandler(PVOID pData)</div>
<div class="line">{</div>
<div class="line">    PDEV_CTX pDevCtx = (PDEV_CTX)<a class="code hl_function" href="wdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1.html#a4cc38c7f222c2d20cc40243b2fad51f1">WDC_GetDevContext</a>(hDev);</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = pDevCtx-&gt;pDma;</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line"> </div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a9d46d11094c1eb67990ab02cb274ced1.html#a9d46d11094c1eb67990ab02cb274ced1">WDC_DMATransferCompletedAndCheck</a>(pDma, <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (dwStatus == <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transaction completed */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dwStatus != <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215ca33b5db37829dbca045a0c0683ed52fba">WD_MORE_PROCESSING_REQUIRED</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transfer failed */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">/* dwStatus == WD_MORE_PROCESSING_REQUIRED */</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transfer completed (but the transaction is not completed) */</span></div>
<div class="line">        <span class="comment">/* If the fRunCallback parameter given to</span></div>
<div class="line"><span class="comment">        * WDC_DMATransferCompletedAndCheck() is TRUE, then the</span></div>
<div class="line"><span class="comment">        * DMATransactionProgram function is automatically called</span></div>
<div class="line"><span class="comment">        * synchronously by WDC_DMATransferCompletedAndCheck */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionRelease: Releases the DMA transaction */</span></div>
<div class="line">BOOL DMATransactionRelease(<a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus = <a class="code hl_function" href="wdc__lib_8h_a37e6e178c0f6e37bd79e81d99ffcc3f0.html#a37e6e178c0f6e37bd79e81d99ffcc3f0">WDC_DMATransactionRelease</a>(pDma);</div>
<div class="line">    <span class="keywordflow">return</span> (dwStatus == <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>) ? <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> : <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAClose: Deletes a previously initiated Scatter/Gather DMA transaction */</span></div>
<div class="line"><span class="keywordtype">void</span> DMAClose(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">        MyDMAInterruptDisable(hDev);</div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a0f8200bb5c7b0808e5f54d57f5e9c17b.html#a0f8200bb5c7b0808e5f54d57f5e9c17b">WDC_DMATransactionUninit</a>(pDma);</div>
<div class="line">}</div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_a0bf056911e1660f3449ee02e21f683b2_html_a0bf056911e1660f3449ee02e21f683b2"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_a0bf056911e1660f3449ee02e21f683b2.html#a0bf056911e1660f3449ee02e21f683b2">WDC_INTERRUPT_PARAMS::funcIntHandler</a></div><div class="ttdeci">INT_HANDLER funcIntHandler</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01486">wdc_lib.h:1486</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_a31466da9f049274b0a377122f79605ae_html_a31466da9f049274b0a377122f79605ae"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_a31466da9f049274b0a377122f79605ae.html#a31466da9f049274b0a377122f79605ae">WDC_INTERRUPT_PARAMS::pData</a></div><div class="ttdeci">PVOID pData</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01487">wdc_lib.h:1487</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_a792da0266327ca28d405a9540e0f3e17_html_a792da0266327ca28d405a9540e0f3e17"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_a792da0266327ca28d405a9540e0f3e17.html#a792da0266327ca28d405a9540e0f3e17">WDC_INTERRUPT_PARAMS::dwOptions</a></div><div class="ttdeci">DWORD dwOptions</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01485">wdc_lib.h:1485</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_a8f09a15cc59933c26eaeb5c8136ad886_html_a8f09a15cc59933c26eaeb5c8136ad886"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_a8f09a15cc59933c26eaeb5c8136ad886.html#a8f09a15cc59933c26eaeb5c8136ad886">WDC_INTERRUPT_PARAMS::dwNumCmds</a></div><div class="ttdeci">DWORD dwNumCmds</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01484">wdc_lib.h:1484</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_aad293fa3cdd74b1d4dcaca8d36795e22_html_aad293fa3cdd74b1d4dcaca8d36795e22"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_aad293fa3cdd74b1d4dcaca8d36795e22.html#aad293fa3cdd74b1d4dcaca8d36795e22">WDC_INTERRUPT_PARAMS::pTransCmds</a></div><div class="ttdeci">WD_TRANSFER * pTransCmds</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01483">wdc_lib.h:1483</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_ad38a68453c9ccb8e894aaea239aa0356_html_ad38a68453c9ccb8e894aaea239aa0356"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS_ad38a68453c9ccb8e894aaea239aa0356.html#ad38a68453c9ccb8e894aaea239aa0356">WDC_INTERRUPT_PARAMS::fUseKP</a></div><div class="ttdeci">BOOL fUseKP</div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01488">wdc_lib.h:1488</a></div></div>
<div class="ttc" id="astructWDC__INTERRUPT__PARAMS_html"><div class="ttname"><a href="structWDC__INTERRUPT__PARAMS.html">WDC_INTERRUPT_PARAMS</a></div><div class="ttdef"><b>Definition:</b> <a href="wdc__lib_8h_source.html#l01482">wdc_lib.h:1482</a></div></div>
<div class="ttc" id="astructWD__DMA__PAGE_a3b430f83710faf4328d7040733f1445e_html_a3b430f83710faf4328d7040733f1445e"><div class="ttname"><a href="structWD__DMA__PAGE_a3b430f83710faf4328d7040733f1445e.html#a3b430f83710faf4328d7040733f1445e">WD_DMA_PAGE::dwBytes</a></div><div class="ttdeci">DWORD dwBytes</div><div class="ttdoc">Size of page.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00502">windrvr.h:502</a></div></div>
<div class="ttc" id="astructWD__DMA_a2028ecf3810b1aab32d4a7c8ece67e7b_html_a2028ecf3810b1aab32d4a7c8ece67e7b"><div class="ttname"><a href="structWD__DMA_a2028ecf3810b1aab32d4a7c8ece67e7b.html#a2028ecf3810b1aab32d4a7c8ece67e7b">WD_DMA::dwBytesTransferred</a></div><div class="ttdeci">DWORD dwBytesTransferred</div><div class="ttdoc">bytes transferred count</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00536">windrvr.h:536</a></div></div>
<div class="ttc" id="astructWD__DMA_acdd5c22660d80d6f3816ad8a15dc7e77_html_acdd5c22660d80d6f3816ad8a15dc7e77"><div class="ttname"><a href="structWD__DMA_acdd5c22660d80d6f3816ad8a15dc7e77.html#acdd5c22660d80d6f3816ad8a15dc7e77">WD_DMA::Page</a></div><div class="ttdeci">WD_DMA_PAGE Page[WD_DMA_PAGES]</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00538">windrvr.h:538</a></div></div>
<div class="ttc" id="astructWD__DMA_ae6a6a2d9f011d81b7cd2bd719a70433c_html_ae6a6a2d9f011d81b7cd2bd719a70433c"><div class="ttname"><a href="structWD__DMA_ae6a6a2d9f011d81b7cd2bd719a70433c.html#ae6a6a2d9f011d81b7cd2bd719a70433c">WD_DMA::dwPages</a></div><div class="ttdeci">DWORD dwPages</div><div class="ttdoc">Number of pages in buffer.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00521">windrvr.h:521</a></div></div>
<div class="ttc" id="astructWD__TRANSFER_html"><div class="ttname"><a href="structWD__TRANSFER.html">WD_TRANSFER</a></div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00563">windrvr.h:564</a></div></div>
<div class="ttc" id="awdc__lib_8h_a0f8200bb5c7b0808e5f54d57f5e9c17b_html_a0f8200bb5c7b0808e5f54d57f5e9c17b"><div class="ttname"><a href="wdc__lib_8h_a0f8200bb5c7b0808e5f54d57f5e9c17b.html#a0f8200bb5c7b0808e5f54d57f5e9c17b">WDC_DMATransactionUninit</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransactionUninit(_In_ WD_DMA *pDma)</div><div class="ttdoc">Unlocks and frees the memory allocated for a DMA buffer transaction by a previous call to WDC_DMATran...</div></div>
<div class="ttc" id="awdc__lib_8h_a29b69c9bc746e1f526abf44f1b1f2162_html_a29b69c9bc746e1f526abf44f1b1f2162"><div class="ttname"><a href="wdc__lib_8h_a29b69c9bc746e1f526abf44f1b1f2162.html#a29b69c9bc746e1f526abf44f1b1f2162">WDC_DMATransactionSGInit</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransactionSGInit(_In_ WDC_DEVICE_HANDLE hDev, _In_ PVOID pBuf, _In_ DWORD dwOptions, _In_ DWORD dwDMABufSize, _Outptr_ WD_DMA **ppDma, _In_ WDC_INTERRUPT_PARAMS *pInterruptParams, _In_ DWORD dwMaxTransferSize, _In_ DWORD dwTransferElementSize)</div><div class="ttdoc">Initializes the transaction and locks a pre-allocated user-mode memory buffer for DMA.</div></div>
<div class="ttc" id="awdc__lib_8h_a37e6e178c0f6e37bd79e81d99ffcc3f0_html_a37e6e178c0f6e37bd79e81d99ffcc3f0"><div class="ttname"><a href="wdc__lib_8h_a37e6e178c0f6e37bd79e81d99ffcc3f0.html#a37e6e178c0f6e37bd79e81d99ffcc3f0">WDC_DMATransactionRelease</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransactionRelease(_In_ WD_DMA *pDma)</div><div class="ttdoc">Terminates a specified DMA transaction without deleting the associated WD_DMA transaction structure.</div></div>
<div class="ttc" id="awdc__lib_8h_a3df10832c06baa617828081a18482c28_html_a3df10832c06baa617828081a18482c28"><div class="ttname"><a href="wdc__lib_8h_a3df10832c06baa617828081a18482c28.html#a3df10832c06baa617828081a18482c28">WDC_DMATransactionExecute</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransactionExecute(_Inout_ WD_DMA *pDma, _In_ DMA_TRANSACTION_CALLBACK funcDMATransactionCallback, _In_ PVOID DMATransactionCallbackCtx)</div><div class="ttdoc">Begins the execution of a specified DMA transaction.</div></div>
<div class="ttc" id="awdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1_html_a4cc38c7f222c2d20cc40243b2fad51f1"><div class="ttname"><a href="wdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1.html#a4cc38c7f222c2d20cc40243b2fad51f1">WDC_GetDevContext</a></div><div class="ttdeci">PVOID DLLCALLCONV WDC_GetDevContext(_In_ WDC_DEVICE_HANDLE hDev)</div><div class="ttdoc">Returns the device's user context information.</div></div>
<div class="ttc" id="awdc__lib_8h_a9d46d11094c1eb67990ab02cb274ced1_html_a9d46d11094c1eb67990ab02cb274ced1"><div class="ttname"><a href="wdc__lib_8h_a9d46d11094c1eb67990ab02cb274ced1.html#a9d46d11094c1eb67990ab02cb274ced1">WDC_DMATransferCompletedAndCheck</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransferCompletedAndCheck(_Inout_ WD_DMA *pDma, _In_ BOOL fRunCallback)</div><div class="ttdoc">Notifies WinDriver that a device's DMA transfer operation is completed.</div></div>
<div class="ttc" id="awindrvr_8h_a4be61f088cf6870c6ff37ab94aba215c_html_a4be61f088cf6870c6ff37ab94aba215ca33b5db37829dbca045a0c0683ed52fba"><div class="ttname"><a href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215ca33b5db37829dbca045a0c0683ed52fba">WD_MORE_PROCESSING_REQUIRED</a></div><div class="ttdeci">@ WD_MORE_PROCESSING_REQUIRED</div><div class="ttdoc">[0xC0000016] More Processing Required.</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l01236">windrvr.h:1230</a></div></div>
<div class="ttc" id="awindrvr_8h_a99fb83031ce9923c84392b4e92f956b5_html_a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6"><div class="ttname"><a href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6">INTERRUPT_CMD_COPY</a></div><div class="ttdeci">@ INTERRUPT_CMD_COPY</div><div class="ttdoc">Copy any data read in the kernel as a result of a read transfer command, and return it to the user wi...</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00591">windrvr.h:587</a></div></div>
<div class="ttc" id="awindrvr_8h_abd951991ce3a6320fb0d1eee9350d35d_html_abd951991ce3a6320fb0d1eee9350d35d"><div class="ttname"><a href="windrvr_8h_abd951991ce3a6320fb0d1eee9350d35d.html#abd951991ce3a6320fb0d1eee9350d35d">DLLCALLCONV</a></div><div class="ttdeci">#define DLLCALLCONV</div><div class="ttdef"><b>Definition:</b> <a href="windrvr_8h_source.html#l00032">windrvr.h:32</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="ch11_3_1_2_c-sharp_example_implementing_scatter-gather_dma_transactions"></a>
11.3.1.2. C# Example</h3>
<p >A detailed example, which is specific to the enhanced support for PLX chipsets can be found in the <code>WinDriver/samples/c/plx/dotnet/lib/</code> library and <code>WinDriver/samples/c/plx/dotnet/diag/</code> diagnostics library.</p>
<h3><a class="anchor" id="ch11_3_1_3_what_should_you_implement_implementing_scatter-gather_dma_transactions"></a>
11.3.1.3. What Should You Implement?</h3>
<p >In the code sample above, it is up to you to implement the following MyDMAxxx() routines and MY_DMA_TRANSFER_ELEMENT structure according to your device's specification and your needs:</p>
<ul>
<li>MY_DMA_TRANSFER_ELEMENT: A DMA transfer element structure according to your device's specification.</li>
<li>MyDMAStart(): Write to the device to initiate DMA transfers.</li>
<li>MyDMAInterruptHardwareEnable(): Write/read the relevant register(s) on the device in order to physically enable the hardware DMA interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">Section 10.4</a> for details regarding interrupt handling with WinDriver).</li>
<li>MyDMAInterruptDisable(): Use <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> to disable the software interrupts and write/read the relevant register(s) on the device in order to physically disable the hardware DMA interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">Section 11.4</a> for details regarding interrupt handling with WinDriver).</li>
<li>MyDMAWaitForCompletion(): Poll the device for completion or wait for a "DMA transfer done" interrupt.</li>
<li>MyDmaIntHandler: The device's interrupt handler. IntHandler is a pointer to a function prototype of your choice.</li>
</ul>
<h2><a class="anchor" id="ch11_3_2_implementing_contiguous-buffer_dma_transactions"></a>
11.3.2. Implementing Contiguous-Buffer DMA transactions</h2>
<p >Following is a sample routine that uses WinDriver's WDC API to initialize a Contiguous- Buffer DMA transaction and perform bus-master DMA transfers.</p>
<p >For more detailed, hardware-specific, contiguous DMA examples, refer to the following enhanced-support chipset sample library files:</p>
<ul>
<li>PLX — <code>WinDriver/samples/c/plx/lib/plx_lib.c</code> and <code>WinDriver/samples/c/plx/diag_lib/plx_diag_lib.c</code> (which utilizes the <code>plx_lib.c</code> DMA API)</li>
<li>XDMA design — <code>WinDriver/samples/c/xilinx/xdma/xdma_lib.c</code></li>
</ul>
<h3><a class="anchor" id="ch11_3_2_1_c_example_implementing_contiguous-buffer_dma_transactions"></a>
11.3.2.1. C Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define DMA_ALIGNMENT_REQUIREMENT 0xFF </span><span class="comment">/* According to the device requirements */</span><span class="preprocessor"></span></div>
<div class="line">BOOL DMATransactionRoutine(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, DWORD dwDMABufSize,</div>
<div class="line"><a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr, BOOL fPolling, BOOL fToDev)</div>
<div class="line">{</div>
<div class="line">    PVOID pBuf = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = <a class="code hl_define" href="kpstdlib_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Initialize the DMA transaction */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionInit(hDev, &amp;pBuf, u32LocalAddr, dwDMABufSize, fToDev,</div>
<div class="line">        &amp;pDma, fPolling))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionExecute(hDev, pDma, fPolling))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Wait for the DMA transaction to complete */</span></div>
<div class="line">    MyDMAWaitForCompletion(hDev, pDma, fPolling);</div>
<div class="line">    <span class="keywordflow">if</span> (!DMATransactionRelease(hDev, pDma))</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The DMA transaction can be reused as many times as you like</span></div>
<div class="line"><span class="comment">    * Notice: after each call to DMATransactionExecute</span></div>
<div class="line"><span class="comment">    * (WDC_DMATransactionExecute) there must be a call to</span></div>
<div class="line"><span class="comment">    * DMATransactionRelease (WDC_DMATransactionRelease) */</span></div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line"> </div>
<div class="line">Exit:</div>
<div class="line">    DMAClose(hDev, pDma, fPolling);</div>
<div class="line">    <a class="code hl_function" href="kpstdlib_8h_acc3b4a8c7b4ba9ec1fd2138ca3f6f650.html#acc3b4a8c7b4ba9ec1fd2138ca3f6f650">free</a>(pBuf);</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionInit: Initializes a Contiguous-Buffer DMA transaction buffer */</span></div>
<div class="line">BOOL DMATransactionInit(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, PVOID *ppBuf, <a class="code hl_typedef" href="windrvr_8h_ae1e6edbbc26d6fbc71a90190d0266018.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> u32LocalAddr,</div>
<div class="line">    DWORD dwDMABufSize, BOOL fToDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> **ppDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus, dwNumCmds, i;</div>
<div class="line">    DWORD dwOptions = fToDev ? <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a5408f0de29ead1f81d3bc25c695d1e5b">DMA_TO_DEVICE</a> : <a class="code hl_enumvalue" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a6b04244ec323a21648b1ec14716a51ec">DMA_FROM_DEVICE</a>;</div>
<div class="line">    <a class="code hl_struct" href="structWD__TRANSFER.html">WD_TRANSFER</a> *pTrans;</div>
<div class="line">    <a class="code hl_struct" href="structWDC__INTERRUPT__PARAMS.html">WDC_INTERRUPT_PARAMS</a> interruptsParams;</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    <span class="comment">/* Enable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">    {</div>
<div class="line">        pTrans = GetMyTransCmds(&amp;dwNumCmds);</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_aad293fa3cdd74b1d4dcaca8d36795e22.html#aad293fa3cdd74b1d4dcaca8d36795e22">pTransCmds</a> = pTrans;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a8f09a15cc59933c26eaeb5c8136ad886.html#a8f09a15cc59933c26eaeb5c8136ad886">dwNumCmds</a> = dwNumCmds;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a792da0266327ca28d405a9540e0f3e17.html#a792da0266327ca28d405a9540e0f3e17">dwOptions</a> = <a class="code hl_enumvalue" href="windrvr_8h_a99fb83031ce9923c84392b4e92f956b5.html#a99fb83031ce9923c84392b4e92f956b5a6e00c38fb16145a07a622cb15c4049a6">INTERRUPT_CMD_COPY</a>;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a0bf056911e1660f3449ee02e21f683b2.html#a0bf056911e1660f3449ee02e21f683b2">funcIntHandler</a> = MyDmaIntHandler;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_a31466da9f049274b0a377122f79605ae.html#a31466da9f049274b0a377122f79605ae">pData</a> = hDev;</div>
<div class="line">        interruptsParams.<a class="code hl_variable" href="structWDC__INTERRUPT__PARAMS_ad38a68453c9ccb8e894aaea239aa0356.html#ad38a68453c9ccb8e894aaea239aa0356">fUseKP</a> = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Initialize a Contiguous-Buffer DMA transaction buffer */</span></div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a5a309ccd603c490085737d42b0c0e365.html#a5a309ccd603c490085737d42b0c0e365">WDC_DMATransactionContigInit</a>(hDev, ppBuf, dwOptions, dwDMABufSize,</div>
<div class="line">        ppDma, &amp;interruptsParams, DMA_ALIGNMENT_REQUIREMENT);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a> != dwStatus)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to initialize a Contiguous-Buffer DMA transaction buffer. Error &quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;0x%lx - %s\n&quot;</span>, dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">    Exit:</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* DMATransactionExecute: Executes the DMA transaction */</span></div>
<div class="line">BOOL DMATransactionExecute(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    BOOL fRet = <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">    DWORD dwPage;</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> u64Offset;</div>
<div class="line"> </div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a3df10832c06baa617828081a18482c28.html#a3df10832c06baa617828081a18482c28">WDC_DMATransactionExecute</a>(pDma, DMATransactionProgram, hDev);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (dwStatus != <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Failed to execute DMA transaction. Error 0x%lx - %s\n&quot;</span>,</div>
<div class="line">            dwStatus, <a class="code hl_function" href="status__strings_8h_a8bc5849b8718e5f3a60bd8b1ef001288.html#a8bc5849b8718e5f3a60bd8b1ef001288">Stat2Str</a>(dwStatus));</div>
<div class="line">        <span class="keywordflow">goto</span> Exit;</div>
<div class="line">    }</div>
<div class="line">    fRet = <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">Exit:</div>
<div class="line">    <span class="keywordflow">return</span> fRet;</div>
<div class="line">}</div>
<div class="line"><span class="comment">/* DMATransactionProgram: Programs the device&#39;s DMA registers and starts the</span></div>
<div class="line"><span class="comment">* DMA */</span></div>
<div class="line"><span class="keywordtype">void</span> DMATransactionProgram(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev)</div>
<div class="line">{</div>
<div class="line">    PDEV_CTX pDevCtx = (PDEV_CTX)<a class="code hl_function" href="wdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1.html#a4cc38c7f222c2d20cc40243b2fad51f1">WDC_GetDevContext</a>(hDev);</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = pDevCtx-&gt;pDma;</div>
<div class="line">    BOOL fToDev = pDevCtx-&gt;fToDev;</div>
<div class="line">    <a class="code hl_typedef" href="windrvr_8h_aae17ebb9ef7279d026817fb22f8aebe9.html#aae17ebb9ef7279d026817fb22f8aebe9">UINT64</a> u64Offset;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* The value of u64Offset is the required offset on the device */</span></div>
<div class="line">    u64Offset = pDevCtx-&gt;u32LocalAddr + pDma-&gt;<a class="code hl_variable" href="structWD__DMA_a2028ecf3810b1aab32d4a7c8ece67e7b.html#a2028ecf3810b1aab32d4a7c8ece67e7b">dwBytesTransferred</a>;</div>
<div class="line">    <span class="comment">/* Use pDma-&gt;Page[0], u64Offset, fToDev,...</span></div>
<div class="line"><span class="comment">    * to program the device&#39;s DMA registers */</span></div>
<div class="line">    <span class="comment">/* Enable interrupts on hardware */</span></div>
<div class="line">    MyDMAInterruptHardwareEnable(hDev);</div>
<div class="line">    <span class="comment">/* Start DMA - write to the device to start the DMA transfer */</span></div>
<div class="line">    MyDMAStart(hDev, pDma);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* MyDmaIntHandler: Interrupt handler */</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_define" href="windrvr_8h_abd951991ce3a6320fb0d1eee9350d35d.html#abd951991ce3a6320fb0d1eee9350d35d">DLLCALLCONV</a> MyDmaIntHandler(PVOID pData)</div>
<div class="line">{</div>
<div class="line">    PDEV_CTX pDevCtx = (PDEV_CTX)<a class="code hl_function" href="wdc__lib_8h_a4cc38c7f222c2d20cc40243b2fad51f1.html#a4cc38c7f222c2d20cc40243b2fad51f1">WDC_GetDevContext</a>(hDev);</div>
<div class="line">    <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma = pDevCtx-&gt;pDma;</div>
<div class="line">    DWORD dwStatus;</div>
<div class="line">    dwStatus = <a class="code hl_function" href="wdc__lib_8h_a9d46d11094c1eb67990ab02cb274ced1.html#a9d46d11094c1eb67990ab02cb274ced1">WDC_DMATransferCompletedAndCheck</a>(pDma, <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (dwStatus == <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transaction completed */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dwStatus == <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215ca33b5db37829dbca045a0c0683ed52fba">WD_MORE_PROCESSING_REQUIRED</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transfer completed (but the transaction is not completed) */</span></div>
<div class="line">        <span class="comment">/* If the fRunCallback parameter given to</span></div>
<div class="line"><span class="comment">        * WDC_DMATransferCompletedAndCheck() is TRUE, then the</span></div>
<div class="line"><span class="comment">        * DMATransactionProgram function is automatically called</span></div>
<div class="line"><span class="comment">        * synchronously by WDC_DMATransferCompletedAndCheck */</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* DMA transfer failed */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMATransactionRelease: Releases the DMA transaction */</span></div>
<div class="line">BOOL DMATransactionRelease(<a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma)</div>
<div class="line">{</div>
<div class="line">    DWORD dwStatus = <a class="code hl_function" href="wdc__lib_8h_a37e6e178c0f6e37bd79e81d99ffcc3f0.html#a37e6e178c0f6e37bd79e81d99ffcc3f0">WDC_DMATransactionRelease</a>(pDma);</div>
<div class="line">    <span class="keywordflow">return</span> (dwStatus == <a class="code hl_enumvalue" href="windrvr_8h_a4be61f088cf6870c6ff37ab94aba215c.html#a4be61f088cf6870c6ff37ab94aba215caba582ffa048363d9da768914de1d5c41">WD_STATUS_SUCCESS</a>) ? <a class="code hl_define" href="kpstdlib_8h_aa8cecfc5c5c054d2875c03e77b7be15d.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a> : <a class="code hl_define" href="kpstdlib_8h_aa93f0eb578d23995850d61f7d61c55c1.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* DMAClose: Deletes a previously initiated Contiguous-Buffer DMA transaction */</span></div>
<div class="line"><span class="keywordtype">void</span> DMAClose(<a class="code hl_typedef" href="wdc__lib_8h_afe93a4914e351fedf921e137fa525e7f.html#afe93a4914e351fedf921e137fa525e7f">WDC_DEVICE_HANDLE</a> hDev, <a class="code hl_struct" href="structWD__DMA.html">WD_DMA</a> *pDma, BOOL fPolling)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Disable DMA interrupts (if not polling) */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!fPolling)</div>
<div class="line">        MyDMAInterruptDisable(hDev);</div>
<div class="line">    <a class="code hl_function" href="wdc__lib_8h_a0f8200bb5c7b0808e5f54d57f5e9c17b.html#a0f8200bb5c7b0808e5f54d57f5e9c17b">WDC_DMATransactionUninit</a>(pDma);</div>
<div class="line">}</div>
<div class="ttc" id="awdc__lib_8h_a5a309ccd603c490085737d42b0c0e365_html_a5a309ccd603c490085737d42b0c0e365"><div class="ttname"><a href="wdc__lib_8h_a5a309ccd603c490085737d42b0c0e365.html#a5a309ccd603c490085737d42b0c0e365">WDC_DMATransactionContigInit</a></div><div class="ttdeci">DWORD DLLCALLCONV WDC_DMATransactionContigInit(_In_ WDC_DEVICE_HANDLE hDev, _Outptr_ PVOID *ppBuf, _In_ DWORD dwOptions, _In_ DWORD dwDMABufSize, _Outptr_ WD_DMA **ppDma, _In_ WDC_INTERRUPT_PARAMS *pInterruptParams, _In_ DWORD dwAlignment)</div><div class="ttdoc">Initializes the transaction, allocates a contiguous DMA buffer, locks it in physical memory,...</div></div>
</div><!-- fragment --> <h3><a class="anchor" id="ch11_3_2_2_c-sharp_example_implementing_contiguous-buffer_dma_transactions"></a>
11.3.2.2. C# Example</h3>
<p >A detailed example, which is specific to the enhanced support for PLX chipsets can be found in the <code>WinDriver/samples/c/plx/dotnet/lib/</code> library and <code>WinDriver/samples/c/plx/dotnet/diag/</code> diagnostics library.</p>
<h3><a class="anchor" id="ch11_3_2_3_what_should_you_implement_implementing_contiguous-buffer_dma_transactions"></a>
11.3.2.3 What Should You Implement?</h3>
<p >In the code sample above, it is up to you to implement the following MyDMAxxx() routines and MY_DMA_TRANSFER_ELEMENT structure according to your device's specification and your needs:</p>
<ul>
<li>MY_DMA_TRANSFER_ELEMENT: DMA transfer element structure according to your device's specification.</li>
<li>MyDMAStart(): Write to the device to initiate DMA transfers.</li>
<li>MyDMAInterruptHardwareEnable(): Write/read the relevant register(s) on the device in order to physically enable the hardware DMA interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">Section 11.4</a> for details regarding interrupt handling with WinDriver).</li>
<li>MyDMAInterruptDisable(): Use <a class="el" href="wdc__lib_8h_a84e9d397d15f94a887c7eabf72aabc37.html#a84e9d397d15f94a887c7eabf72aabc37" title="Disables interrupt interrupt handling for the device, pursuant to a previous call to WDC_IntEnable()">WDC_IntDisable()</a> to disable the software interrupts and write/read the relevant register(s) on the device in order to physically disable the hardware DMA interrupts (see <a class="el" href="ch10_pci_advanced_features.html#ch10_4_single_root_i-o_virtualization_sr-iov">Section 11.4</a> for details regarding interrupt handling with WinDriver).</li>
<li>MyDMAWaitForCompletion(): Poll the device for completion or wait for a "DMA transfer done" interrupt.</li>
<li>MyDmaIntHandler: The device's interrupt handler. IntHandler is a pointer to a function prototype of your choice.</li>
</ul>
<h1><a class="anchor" id="ch11_4_dma_between_pci_devices_and_nvidia_gpus_with_gpudirect_linux_only"></a>
11.4. DMA between PCI devices and NVIDIA GPUs with GPUDirect (Linux only)</h1>
<h2><a class="anchor" id="ch11_4_1_what_is_gpudirect_for_rdma"></a>
11.4.1. What is GPUDirect for RDMA?</h2>
<p >GPUDirect for RDMA is a feature available on selected NVIDIA GPUs that allows performing Direct Memory Access (DMA) between GPUs and PCI Express devices. Check out NVIDIA’s website to make sure your GPU does support GPUDirect for this purpose.</p>
<p >NVIDIA GPUDirect RDMA is currently supported only on Linux. We strive to add support for further GPUs and OSes in the future, please contact <a href="#" onclick="location.href='mai'+'lto:'+'Win'+'Dr'+'ive'+'r@'+'jun'+'go'+'.co'+'m'; return false;">WinDr<span class="obfuscator">.nosp@m.</span>iver<span class="obfuscator">.nosp@m.</span>@jung<span class="obfuscator">.nosp@m.</span>o.co<span class="obfuscator">.nosp@m.</span>m</a> for further inquiries and suggestions.</p>
<h2><a class="anchor" id="ch11_4_2_system_requirements_dma_between_pci_devices_and_nvidia_gpus_with_gpudirect"></a>
11.4.2. System Requirements</h2>
<p >The following system requirements:</p>
<ul>
<li>NVIDIA GPU that supports GPUDirect.</li>
<li>PCIe device controlled by WinDriver.</li>
</ul>
<h2><a class="anchor" id="ch11_4_3_software_prerequisites"></a>
11.4.3. Software Prerequisites</h2>
<p >The following software prerequisities:</p>
<ul>
<li>Installed NVIDIA kernel drivers for your GPU.</li>
<li>Installed CUDA version that supports GPUDirect (we have tested with version 10) along with the NVCC compiler.</li>
</ul>
<h2><a class="anchor" id="ch11_4_4_windriver_installation"></a>
11.4.4. WinDriver installation</h2>
<p >Unpack WinDriver from the tar file.</p>
<div class="fragment"><div class="line">cd WinDriver/redist</div>
</div><!-- fragment --><p >Make sure your WinDriver kernel module is linked with NVIDIA’s kernel module to allow GPUDIRECT.</p>
<div class="fragment"><div class="line">./configure –with-gpudirect-source=&lt;&lt;YOUR_NVIDIA_KERNEL_SOURCE_DIRECTORY&gt;&gt;/kernel</div>
<div class="line">sudo make &amp;&amp; sudo make install</div>
</div><!-- fragment --><h2><a class="anchor" id="ch11_4_5_moving_dma_from_cpu_to_gpu"></a>
11.4.5. Moving DMA from CPU to GPU</h2>
<p >We strongly recommend making sure you have already implemented and tested a “regular” DMA routine between your device and the computer RAM before moving on to implementing a GPUDirect DMA routine. <br  />
 See previous sections for more info (<a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a> or <br  />
 <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a>).</p>
<p >Assuming you have already implemented a DMA routine in your WinDriver-based code, perform the following steps to perform DMA to the GPU memory instead of the main memory.</p>
<h2><a class="anchor" id="ch11_4_6_modify_compilation"></a>
11.4.6. Modify Compilation</h2>
<p >If compiling using Make/CMake, follow this instructions and see a detailed example below:</p>
<ul>
<li>Change your makefile to compile your app with the CUDA compiler (<code>nvcc</code>) instead of <code>gcc</code>.</li>
<li>Change your makefile to link your app with with the CUDA compiler (<code>nvcc</code>) instead of <code>ld</code>.</li>
<li>Add <code>-lcuda</code> to your linker flags(<code>LFLAGS</code>) in order to link with the CUDA shared libraries.</li>
<li>Remove <code>-fno-pie and -m$(USER_BITS)</code> from your linker flags.</li>
</ul>
<h2><a class="anchor" id="ch11_4_7_modify_your_code"></a>
11.4.7. Modify your code</h2>
<p >Add to your code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cuda.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
</div><!-- fragment --><p >Instead of using regular <code><a class="el" href="kpstdlib_8h_a736d9ab37afc2ba50e25346a3d49a8d9.html#a736d9ab37afc2ba50e25346a3d49a8d9">malloc()</a></code> to allocate the memory for the pBuf parameter in the function <code><a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a></code>, use <code>cudaMalloc()</code>.</p>
<p >Make sure that the dwOptions parameter of <code><a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a></code> contains the [DMA_GPUDIRECT] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555ad9ca63488ff663411de42a491d784996">DMA_GPUDIRECT</a>) flag.</p>
<p >Add the following code to enable synchronous memory operations with your DMA buffer (<code>pDma-&gt;pBuf</code> in this example)</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> flag = 1;</div>
<div class="line"><span class="keywordflow">if</span> (CUDA_SUCCESS != cuPointerSetAttribute(&amp;flag,</div>
<div class="line">    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS, (CUdeviceptr)pDma-&gt;pBuf))</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;cuDeviceGet failed\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p >Use CUDA functions to access the GPU memory such as: cudaMemcpy(), cudaFree() etc. Using regular memory management functions on pointers to GPU memory might lead to crashes.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Calling <code><a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a></code> with [DMA_GPUDIRECT] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555ad9ca63488ff663411de42a491d784996">DMA_GPUDIRECT</a>) flag with a buffer allocated with regular memory buffer (not allocated using <code>cudaMalloc()</code>) will result in an Internal System Error (Status 0x20000007). </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch11_4_8_cmake_example"></a>
11.4.8. CMake Example</h2>
<p >If using CMake to compile your code – use the following recipe as a guide.</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.0)</div>
<div class="line"> </div>
<div class="line">set(WD_BASEDIR ~/WinDriver) #change according to your installation path</div>
<div class="line"> </div>
<div class="line">project(my_wd_gpudirect_project C)</div>
<div class="line">include(${WD_BASEDIR}/include/wd.cmake)</div>
<div class="line">include_directories(</div>
<div class="line">    ${WD_BASEDIR}</div>
<div class="line">    ${WD_BASEDIR}/include</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">set(SRCS my_wd_gpudirect_project.c)</div>
<div class="line"> </div>
<div class="line">add_executable(my_wd_gpudirect_project ${SRCS} ${SAMPLE_SHARED_SRCS})</div>
<div class="line"> </div>
<div class="line">#link with and libwdapi1511 and libcuda</div>
<div class="line">target_link_libraries(my_wd_gpudirect_project wdapi${WD_VERSION} cuda)</div>
<div class="line">set_target_properties(my_wd_gpudirect_project PROPERTIES</div>
<div class="line">    RUNTIME_OUTPUT_DIRECTORY &quot;${ARCH}/&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">#remove definitions to allow compilation with nvcc</div>
<div class="line">remove_definitions(&quot;-Wno-unused-result -Wno-write-strings &quot;)</div>
<div class="line">set(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS &quot;&quot;)</div>
<div class="line"> </div>
<div class="line">#change compiler to nvcc</div>
<div class="line">set(CMAKE_C_COMPILER /usr/local/cuda-10.2/bin/nvcc)</div>
<div class="line"> </div>
<div class="line">#add GPUDIRECT definition to compilation</div>
<div class="line">target_compile_definitions(my_wd_gpudirect_project PRIVATE GPUDIRECT)</div>
</div><!-- fragment --><h1><a class="anchor" id="ch11_5_faq_improving_pci_performance"></a>
11.5. FAQ</h1>
<h2><a class="anchor" id="ch11_5_1_how_do_i_perform_system_or_slave_dma_using_windriver"></a>
11.5.1. How do I perform system or slave DMA using WinDriver?</h2>
<p >WinDriver supports the implementation of interrupt service routines and locking down DMA buffers into memory, giving you the physical addresses and lengths of the kernel DMA buffer.</p>
<p >Assuming you want to implement slave DMA for an ISA card, you will need to write the code to program the DMA controller yourself. There is no specific API to program the system DMAC on PCs, but you can use the generic WinDriver API for direct hardware access and DMA allocation from your application <br  />
 (see specifically <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a>, <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a>, <br  />
 and the <a class="el" href="wdc__lib_8h_a999f185bff32d67ac90cfc40750a49e5.html#a999f185bff32d67ac90cfc40750a49e5" title="Read/write 8/16/32/64 bits from the PCI configuration space.">WDC_PciReadCfg8()</a> / <a class="el" href="wdc__lib_8h_a878507aa6c55c431e89b43270dc59a73.html#a878507aa6c55c431e89b43270dc59a73" title="Reads 2 bytes (16 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg16()</a> / <a class="el" href="wdc__lib_8h_aa919caae0f60258ebae8b298e1a008fb.html#aa919caae0f60258ebae8b298e1a008fb" title="Reads 4 bytes (32 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg32()</a> / <a class="el" href="wdc__lib_8h_a9a360c5b140e8d839f18f4df0751fae4.html#a9a360c5b140e8d839f18f4df0751fae4" title="Reads 8 bytes (64 bits) from a specified offset in a PCI device&#39;s configuration space or a PCI Expres...">WDC_PciReadCfg64()</a> <br  />
 and <a class="el" href="wdc__lib_8h_a0ce3a209f04519ddd0bddf00abf62fd9.html#a0ce3a209f04519ddd0bddf00abf62fd9" title="Writes 1 byte (8 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express d...">WDC_PciWriteCfg8()</a> / <a class="el" href="wdc__lib_8h_af8c5ff2678888ca00f61625f6fc93149.html#af8c5ff2678888ca00f61625f6fc93149" title="Writes 2 bytes (16 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express...">WDC_PciWriteCfg16()</a> / <a class="el" href="wdc__lib_8h_aee6880b5b0f52f8746f5e82b549b6a8e.html#aee6880b5b0f52f8746f5e82b549b6a8e" title="Writes 4 bytes (32 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express...">WDC_PciWriteCfg32()</a> / <a class="el" href="wdc__lib_8h_a482050e201d5b2e492902ac58699ae75.html#a482050e201d5b2e492902ac58699ae75" title="Writes 8 bytes (64 bits) to a specified offset in a PCI device&#39;s configuration space or a PCI Express...">WDC_PciWriteCfg64()</a> or the lower-level <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a> and <a class="el" href="windrvr_8h_ac7801059e5aee0b0a5f314f96bd72603.html#ac7801059e5aee0b0a5f314f96bd72603" title="Executes a single read/write instruction to an I/O port or to a memory address.">WD_Transfer()</a> APIs).</p>
<h2><a class="anchor" id="ch11_5_2_i_have_locked_a_memory_buffer_for_dma_on_windows_now_when_i_access_this_memory_directly_using_the_user-mode_pointer_it_seems_to_be_5_times_slower_than_accessing_a_regular_memory_buffer_allocated_with_malloc_why"></a>
11.5.2. I have locked a memory buffer for DMA on Windows. Now, when I access this memory directly, using the user-mode pointer, it seems to be 5 times slower than accessing a “regular” memory buffer, allocated with malloc(). Why?</h2>
<p >“Regular” memory (stack, heap, etc.) is cached by the operating system. When using WinDriver DMA APIs, the data is non-cached, in order to make it DMA-safe. Therefore, the memory access is slower. Note that this is the correct behavior for DMA.</p>
<p >When performing Contiguous Buffer DMA, you can set the DMA_ALLOW_CACHE flag in the dwOptions parameter of <a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a>, or directly in the <code>dwOptions</code> field of the <a class="el" href="structWD__DMA.html">WD_DMA</a> structure that is passed to <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a> (when using the low-level WinDriver API), in order to allocate a cached DMA buffer. When working on Windows x86 and x86_64 platforms, it is recommended to always set this flag.</p>
<p >If you have allocated the memory in the user mode and then passed its address to <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> or to the low-level <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a> function in order to lock a Scatter/Gather DMA buffer, then calling <a class="el" href="windrvr_8h_ac5ef53e8b8e24f5daa0b5f79e7799b93.html#ac5ef53e8b8e24f5daa0b5f79e7799b93" title="Unlocks a DMA buffer.">WD_DMAUnlock()</a> will unlock the memory buffer and it will now function like other “regular” memory in terms of access speed.</p>
<h2><a class="anchor" id="ch11_5_3_my_attempt_to_allocate_and_lock_a_1gb_dma_buffer_with_windriver_on_windows_fails_is_this_a_limitation_of_the_operating_system"></a>
11.5.3. My attempt to allocate and lock a 1GB DMA buffer with WinDriver on Windows fails. Is this a limitation of the operating system?</h2>
<p >WinDriver does not impose any inherent limitation on the size of the DMA buffer that can be allocated using its DMA APIs. However, the success of the DMA allocation is dependent of the amount of available system resources at the time of the attempted allocation. Therefore, the earlier your try to allocate the buffer, the better your chances of succeeding.</p>
<p >For contiguous-buffer DMA allocation, there must be enough contiguous physical memory for the allocation. On Windows, WinDriver allows preallocation of DMA buffers to evade this, so please refer to the relevant chapter of the manaul for more information.</p>
<p >When allocating a Scatter/Gather DMA buffer that is larger than 1MB, using the low-level WinDriver API, be sure to set the [DMA_LARGE_BUFFER] (<a class="el" href="windrvr_8h_ada5365d842d0c9e6e733231afd74e555.html#ada5365d842d0c9e6e733231afd74e555a9d5b8bed9d9e8bdf452736b6dc5a5f0d">DMA_LARGE_BUFFER</a>) flag in the dwOptions field of the <a class="el" href="structWD__DMA.html">WD_DMA()</a> structure that is passed to <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a>. (When using the high-level <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> function, this flag is already handled internally by the function.)</p>
<p >The DMA buffer allocated by WinDriver uses page-locked memory, to ensure a safe DMA operation. This memory is allocated from Windows' non-paged kernel pool of memory. The size of this pool is fixed at boot time by a Registry setting. You can increase the allocated memory by increasing the value of the <code>NonPagedPoolSize</code> Registry entry, found under <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</code>.</p>
<p >Sometimes, there is enough contiguous memory, but there are not enough page table entries to map the memory. Even after increasing the value of the relevant Registry entries, the memory allocation might still fail, specifically when trying to allocate a very large buffer (such as 1GB). The solution in this case is to try decreasing the size of the buffer you are trying to lock, until you succeed.</p>
<blockquote class="doxtable">
<p >&zwj;<b>⚠ Attention</b></p>
<blockquote class="doxtable">
<p >&zwj;Please note that the WinDriver DMA allocation APIs ((<a class="el" href="wdc__lib_8h_a95ffd06d0067799a13db513a87ddabe5.html#a95ffd06d0067799a13db513a87ddabe5" title="Allocates a contiguous DMA buffer, locks it in physical memory, and returns mappings of the allocated...">WDC_DMAContigBufLock()</a> / <a class="el" href="wdc__lib_8h_a08bdeefcdb49c8d3313462ec463b2d93.html#a08bdeefcdb49c8d3313462ec463b2d93" title="Locks a pre-allocated user-mode memory buffer for DMA and returns the corresponding physical mappings...">WDC_DMASGBufLock()</a> / <a class="el" href="windrvr_8h_a4c92cd1c19dea2fd93fecd96f7e8cd94.html#a4c92cd1c19dea2fd93fecd96f7e8cd94" title="Enables contiguous-buffer or Scatter/Gather DMA.">WD_DMALock()</a>) also map the physical memory of the allocated buffer into virtual user mode space. Therefore, there must also be enough free virtual memory to enable the mapping of the entire buffer into the user space. </p>
</blockquote>
</blockquote>
<h2><a class="anchor" id="ch11_5_4_how_do_i_perform_pci_dma_writes_from_system_memory_to_my_card_using_windriver"></a>
11.5.4. How do I perform PCI DMA Writes from system memory to my card, using WinDriver?</h2>
<p >See <a class="el" href="ch11_improving_pci_performance.html#ch11_2_performing_direct_memory_access_dma">11.2. Performing Direct Memory Access (DMA)</a> and <a class="el" href="ch11_improving_pci_performance.html#ch11_3_performing_direct_memory_access_dma_transactions">11.3. Performing Direct Memory Access (DMA) transactions</a>.</p>
<h2><a class="anchor" id="ch11_5_5_how_do_i_perform_direct_block_transfers_from_one_pci_card_to_another"></a>
11.5.5. How do I perform Direct Block transfers from one PCI card to another?</h2>
<p >Locate and register both cards (using <a class="el" href="wdc__lib_8h_a15790844cb433fbaaf8c390a368d0efb.html#a15790844cb433fbaaf8c390a368d0efb" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevices()</a>, <a class="el" href="wdc__lib_8h_a920d348804f4ee3aa118ebf073d33698.html#a920d348804f4ee3aa118ebf073d33698" title="Retrieves a PCI device&#39;s resources information (memory and I/O ranges and interrupt information).">WDC_PciGetDeviceInfo()</a> and <br  />
 <a class="el" href="wdc__lib_8h_a15790844cb433fbaaf8c390a368d0efb.html#a15790844cb433fbaaf8c390a368d0efb" title="Scans the PCI bus for all devices with the specified vendor and device ID combination and returns inf...">WDC_PciScanDevices()</a>). At least one of the cards must be PCI DMA Master Capable.</p>
<p >Program it with the physical address of the Slave card. Obtaining this address is possible by using <code>pciCard.Card.Item[i].I.Mem.pPhysicalAddr</code>, set by <a class="el" href="wdc__lib_8h_a920d348804f4ee3aa118ebf073d33698.html#a920d348804f4ee3aa118ebf073d33698" title="Retrieves a PCI device&#39;s resources information (memory and I/O ranges and interrupt information).">WDC_PciGetDeviceInfo()</a> for the slave card.</p>
<p >Refer to the DMA section of this manual for more info regarding programming DMA using WinDriver. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
